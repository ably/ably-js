'use strict';

define(['ably', 'json-rpc-2.0'], function (Ably, { JSONRPCClient, JSONRPCServer, JSONRPCServerAndClient }) {
  // copied from crypto test
  var msgpack = typeof window == 'object' ? Ably.msgpack : require('@ably/msgpack-js');
  // similar approach
  var WebSocket = typeof window == 'object' ? window.WebSocket : require('ws');
  var BufferUtils = Ably.Realtime.Platform.BufferUtils;

  function log(...args) {
    console.log('Interception proxy client:', ...args);
  }

  class InterceptionProxyClient {
    currentContext = null;

    constructor() {
      this.jsonRPC = new JSONRPCServerAndClient(
        new JSONRPCServer(),
        new JSONRPCClient((request) => {
          const data = JSON.stringify(request);
          log('sending data to control server:', data);
          this.webSocket.send(data);
        }),
      );

      this.jsonRPC.addMethod('transformInterceptedMessage', (params) => this.transformInterceptedMessage(params));
    }

    // this expects the interception proxy to already be running (i.e. the test suite doesn't launch it)
    // this method is called by test suite’s root hooks. test cases shouldn't call this method; rather, they should use `intercept`
    async connect() {
      this.webSocket = new WebSocket('ws://localhost:8001');

      await new Promise((resolve, reject) => {
        this.webSocket.addEventListener('open', () => {
          log('connected to interception proxy');
          resolve();
        });
        this.webSocket.addEventListener('error', (error) => {
          log('failed to connect to interception proxy:', error);
          reject(error);
        });
        this.webSocket.addEventListener('message', ({ data }) => {
          log('got control API message', data);
          this.jsonRPC.receiveAndSend(JSON.parse(data));
        });
      });

      await this.startInterception();
      log('startInterception completed');

      // TODO something if connection lost
    }

    async startInterception() {
      // i.e. for browser we use proxy, for Node we use local
      const params = typeof window == 'object' ? { mode: 'proxy' } : { mode: 'local', pid: process.pid };

      log('sending startInterception request with params', params);
      await this.jsonRPC.request('startInterception', params);
    }

    async disconnect() {
      if (this.webSocket.readyState === 3) {
        // already closed
        log('already disconnected');
        return;
      }

      this.webSocket.close();

      return new Promise((resolve) => {
        this.webSocket.addEventListener('close', () => {
          log('disconnected');
          resolve();
        });
      });
    }

    // TODO explain motivation for this API (so that a lingering test can’t accidentally override the interception in your test; of course, the interception in your test might accidentally _intercept_ messages sent by a lingering test but that’s a separate issue)
    //
    // This is written as (done, action) for compatibility with the way our tests are currently written; a promise-based version would be good to have too
    //
    // action receives a context object. it can modify the following properties of this object to modify the interception:
    //
    // - `transformClientMessage` or `transformServerMessage` (for message from client or server respectively)
    //
    //   Receives an object with the following properties:
    //
    //   - id: a unique identifier for this WebSocket message (generated by the interception proxy)
    //   - connectionID: a unique identifier for this WebSocket connection (generated by the interception proxy)
    //   - deserialized: a JSON-like object (i.e. the result of JSON.parse or msgpack.decode)
    //
    //   And returns one of:
    //
    //   - a JSON-like object (to modify the message)
    //   - `null` (to drop the message)
    //
    //   Can also return a promise.
    //
    //   If not set, then messages will be passed through unaltered.
    //
    //   TODO some thoughts on API:
    //
    //   - user currently has to make sure they remember to return something from the transform* function, even if they’re failing their test in some exceptional manner — this is to make sure that the connection can be allowed to disconnect at the proxy
    //
    //   - users might think that they can directly mutate the object passed to transform* functions
    intercept(done, action) {
      if (this.currentContext !== null) {
        throw new Error(
          'A call to `intercept` is already active; check you’re not running multiple tests at the same time',
        );
      }

      this.currentContext = {
        transformClientMessage: null,
        transformServerMessage: null,
      };

      const newDone = (error) => {
        this.currentContext = null;
        done(error);
      };

      action(newDone, this.currentContext);
    }

    async transformInterceptedMessage(paramsDTO) {
      let deserialized;
      if (paramsDTO.type === 'binary') {
        const data = BufferUtils.base64Decode(paramsDTO.data);
        deserialized = msgpack.decode(data);
      } else if (paramsDTO.type === 'text') {
        const data = paramsDTO.data;
        deserialized = JSON.parse(data);
      }

      log('awaiting response of transformInterceptedMessage for message', paramsDTO, 'deserialized to', deserialized);

      const message = { id: paramsDTO.id, connectionID: paramsDTO.connectionID, deserialized };

      const noOpTransformInterceptedMessage = (message) => {
        log(`default transformInterceptedMessage implementation passing message ${message.id} unaltered`);
        return message.deserialized;
      };

      const contextTransformInterceptedMessage =
        (paramsDTO.fromClient
          ? this.currentContext?.transformClientMessage
          : this.currentContext?.transformServerMessage) ?? noOpTransformInterceptedMessage;

      const result = await contextTransformInterceptedMessage(message);
      log(`got result of transforming message ${message.id}`, result);

      if (result === null) {
        return { action: 'drop' };
      } else {
        let data;

        if (paramsDTO.type === 'binary') {
          const serialized = msgpack.encode(result);
          data = BufferUtils.base64Encode(serialized);
        } else if (paramsDTO.type === 'text') {
          data = JSON.stringify(result);
        }

        return { action: 'replace', type: paramsDTO.type, data };
      }
    }
  }

  return (module.exports = new InterceptionProxyClient());
});
