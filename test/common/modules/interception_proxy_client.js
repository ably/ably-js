'use strict';

define(['ably', 'json-rpc-2.0'], function (Ably, { JSONRPCClient, JSONRPCServer, JSONRPCServerAndClient }) {
  // copied from crypto test
  var msgpack = typeof window == 'object' ? Ably.msgpack : require('@ably/msgpack-js');
  // similar approach
  var WebSocket = typeof window == 'object' ? window.WebSocket : require('ws');
  var BufferUtils = Ably.Realtime.Platform.BufferUtils;

  function log(...args) {
    console.log('Interception proxy client:', ...args);
  }

  function serialize(type, deserialized) {
    let data;

    if (type === 'binary') {
      const serialized = msgpack.encode(deserialized);
      data = BufferUtils.base64Encode(serialized);
    } else if (type === 'text') {
      data = JSON.stringify(deserialized);
    }

    return { type, data };
  }

  class InterceptionProxyClient {
    currentContext = null;

    constructor() {
      this.jsonRPC = new JSONRPCServerAndClient(
        new JSONRPCServer(),
        new JSONRPCClient((request) => {
          const data = JSON.stringify(request);
          log('sending data to control server:', data);
          this.webSocket.send(data);
        }),
      );

      this.jsonRPC.addMethod('transformInterceptedMessage', (params) => this.transformInterceptedMessage(params));
    }

    // this expects the interception proxy to already be running (i.e. the test suite doesn't launch it)
    // this method is called by test suite’s root hooks. test cases shouldn't call this method; rather, they should use `intercept`
    async connect() {
      this.webSocket = new WebSocket('ws://localhost:8001');

      await new Promise((resolve, reject) => {
        this.webSocket.addEventListener('open', () => {
          log('connected to interception proxy');
          resolve();
        });
        this.webSocket.addEventListener('error', (error) => {
          log('failed to connect to interception proxy:', error);
          reject(error);
        });
        this.webSocket.addEventListener('message', ({ data }) => {
          log('got control API message', data);
          this.jsonRPC.receiveAndSend(JSON.parse(data));
        });
      });

      await this.startInterception();
      log('startInterception completed');

      // TODO something if connection lost
    }

    async startInterception() {
      // i.e. for browser we use proxy, for Node we use local
      const params = typeof window == 'object' ? { mode: 'proxy' } : { mode: 'local', pid: process.pid };

      log('sending startInterception request with params', params);
      await this.jsonRPC.request('startInterception', params);
    }

    async disconnect() {
      if (this.webSocket.readyState === 3) {
        // already closed
        log('already disconnected');
        return;
      }

      this.webSocket.close();

      return new Promise((resolve) => {
        this.webSocket.addEventListener('close', () => {
          log('disconnected');
          resolve();
        });
      });
    }

    // TODO explain motivation for this API (so that a lingering test can’t accidentally override the interception in your test; of course, the interception in your test might accidentally _intercept_ messages sent by a lingering test but that’s a separate issue). More broadly it’s a way of ensuring a test case’s effects don’t outlive its execution; perhaps we could do this using hooks instead
    //
    // This is written as (done, action) for compatibility with the way our tests are currently written; a promise-based version would be good to have too
    //
    // action receives a context object. it can modify the following properties of this object to modify the interception:
    //
    // - `transformClientMessage` or `transformServerMessage` (for message from client or server respectively)
    //
    //   Receives an object with the following properties:
    //
    //   - id: a unique identifier for this WebSocket message (generated by the interception proxy)
    //   - connectionID: a unique identifier for this WebSocket connection (generated by the interception proxy)
    //   - deserialized: a JSON-like object (i.e. the result of JSON.parse or msgpack.decode)
    //
    //   And returns one of:
    //
    //   - a JSON-like object (to modify the message)
    //   - `null` (to drop the message)
    //
    //   Can also return a promise.
    //
    //   If not set, then messages will be passed through unaltered.
    //
    //   TODO some thoughts on API:
    //
    //   - user currently has to make sure they remember to return something from the transform* function, even if they’re failing their test in some exceptional manner — this is to make sure that the connection can be allowed to disconnect at the proxy
    //
    //   - users might think that they can directly mutate the object passed to transform* functions
    intercept(done, action) {
      if (this.currentContext !== null) {
        throw new Error(
          'A call to `intercept` is already active; check you’re not running multiple tests at the same time',
        );
      }

      this.currentContext = new InterceptionContext(this.jsonRPC);

      const newDone = (error) => {
        this.currentContext = null;
        done(error);
      };

      action(newDone, this.currentContext);
    }

    async transformInterceptedMessage(paramsDTO) {
      this.currentContext?._recordSeenConnection(paramsDTO);

      let deserialized;
      if (paramsDTO.type === 'binary') {
        const data = BufferUtils.base64Decode(paramsDTO.data);
        deserialized = msgpack.decode(data);
      } else if (paramsDTO.type === 'text') {
        const data = paramsDTO.data;
        deserialized = JSON.parse(data);
      }

      log('awaiting response of transformInterceptedMessage for message', paramsDTO, 'deserialized to', deserialized);

      const message = { id: paramsDTO.id, connectionID: paramsDTO.connectionID, deserialized };

      const noOpTransformInterceptedMessage = (message) => {
        log(`default transformInterceptedMessage implementation passing message ${message.id} unaltered`);
        return message.deserialized;
      };

      const contextTransformInterceptedMessage =
        (paramsDTO.fromClient
          ? this.currentContext?.transformClientMessage
          : this.currentContext?.transformServerMessage) ?? noOpTransformInterceptedMessage;

      const result = await contextTransformInterceptedMessage(message);
      log(`got result of transforming message ${message.id}`, result);

      if (result === null) {
        return { action: 'drop' };
      } else {
        return { action: 'replace', ...serialize(paramsDTO.type, result) };
      }
    }
  }

  class InterceptionContext {
    transformClientMessage = null;
    transformServerMessage = null;
    // TODO this is a temporary API until I figure out what the right thing to do is (probably to add an interception proxy notification when a new connection is intercepted, and then infer it from the query param), but document it anyway
    // elements are { type: 'binary' | 'text' }
    //
    // keyed by connection ID, ordered oldest-to-newest connection
    #seenConnections = new Map();

    constructor(jsonRPC) {
      this.jsonRPC = jsonRPC;
    }

    _recordSeenConnection(transformInterceptedMessageParamsDTO) {
      const { connectionID, type } = transformInterceptedMessageParamsDTO;

      if (this.#seenConnections.has(connectionID)) {
        return;
      }

      this.#seenConnections.set(connectionID, { type });
    }

    // TODO the term "connection ID" is a bit overloaded (becuse it’s an Ably concept too)
    get latestConnectionID() {
      if (this.#seenConnections.size === 0) {
        return null;
      }

      return Array.from(this.#seenConnections.keys()).pop();
    }

    async injectMessage(connectionID, deserialized, fromClient) {
      const seenConnection = this.#seenConnections.get(connectionID);
      if (!seenConnection) {
        throw new Error(`Cannot inject message — have not seen a connection with ID ${connectionID}`);
      }

      const params = {
        connectionID,
        fromClient,
        ...serialize(seenConnection.type, deserialized),
      };

      log('sending injectMessage request with params', params);
      await this.jsonRPC.request('injectMessage', params);
    }
  }

  return (module.exports = new InterceptionProxyClient());
});
