{
  "version": 3,
  "sources": ["../node_modules/bops/from.js", "../node_modules/bops/to.js", "../node_modules/bops/is.js", "../node_modules/bops/subarray.js", "../node_modules/bops/join.js", "../node_modules/bops/copy.js", "../node_modules/bops/create.js", "../node_modules/bops/read.js", "../node_modules/bops/write.js", "../node_modules/bops/index.js", "../node_modules/@ably/msgpack-js/msgpack.js", "../src/common/platform.ts", "../src/common/lib/util/logger.ts", "../src/common/lib/util/utils.ts", "../src/common/lib/types/errorinfo.ts", "../package.json", "../src/common/lib/util/defaults.ts", "../src/common/lib/util/multicaster.ts", "../src/common/constants/HttpMethods.ts", "../src/common/constants/HttpStatusCodes.ts", "../src/common/lib/client/auth.ts", "../src/common/types/http.ts", "../src/common/lib/client/baseclient.ts", "../src/common/lib/types/devicedetails.ts", "../src/common/lib/client/resource.ts", "../src/common/lib/client/paginatedresource.ts", "../src/common/lib/types/pushchannelsubscription.ts", "../src/common/lib/client/push.ts", "../src/common/lib/types/protocolmessagecommon.ts", "../src/common/lib/types/basemessage.ts", "../src/common/lib/types/presencemessage.ts", "../src/common/lib/client/restpresence.ts", "../src/common/lib/types/message.ts", "../src/common/lib/client/restchannel.ts", "../src/common/lib/types/stats.ts", "../src/common/lib/client/restchannelmixin.ts", "../src/common/lib/client/restpresencemixin.ts", "../src/common/lib/client/rest.ts", "../src/common/lib/client/baserest.ts", "../src/common/lib/client/modularplugins.ts", "../src/common/lib/types/defaultmessage.ts", "../src/common/lib/types/defaultpresencemessage.ts", "../src/common/lib/client/defaultrest.ts", "../src/common/lib/util/eventemitter.ts", "../src/common/lib/types/protocolmessage.ts", "../src/common/lib/transport/messagequeue.ts", "../src/common/lib/transport/protocol.ts", "../src/common/lib/client/connectionstatechange.ts", "../src/common/lib/transport/connectionerrors.ts", "../src/common/lib/transport/transport.ts", "../src/common/constants/TransportName.ts", "../src/common/lib/transport/connectionmanager.ts", "../src/common/lib/client/connection.ts", "../src/common/lib/client/channelstatechange.ts", "../src/common/lib/client/realtimechannel.ts", "../src/common/lib/client/baserealtime.ts", "../src/common/lib/client/presencemap.ts", "../src/common/lib/client/realtimepresence.ts", "../src/common/lib/transport/websockettransport.ts", "../src/common/lib/client/filteredsubscriptions.ts", "../src/common/lib/client/defaultrealtime.ts", "../src/platform/nodejs/lib/util/bufferutils.ts", "../src/platform/nodejs/lib/util/crypto.ts", "../src/platform/nodejs/lib/util/http.ts", "../src/platform/nodejs/config.ts", "../src/common/constants/XHRStates.ts", "../src/common/lib/transport/comettransport.ts", "../src/platform/nodejs/lib/transport/nodecomettransport.js", "../src/platform/nodejs/lib/transport/index.ts", "../src/platform/nodejs/lib/util/defaults.ts", "../src/platform/nodejs/index.ts"],
  "sourcesContent": ["var Buffer = require('buffer').Buffer\n\nvar version = ((process || {}).version || 'v0.0.0').slice(1).split('.')[0]\n\nmodule.exports = (\n  Number(version) < 6\n  ? function from(source, encoding) { return new Buffer(source, encoding) }\n  : function from(source, encoding) { return Buffer.from(source, encoding) }\n)\n", "module.exports = function(source, encoding) {\n  return source.toString(encoding)\n}\n", "var Buffer = require('buffer').Buffer\n\nmodule.exports = function(buffer) {\n  return Buffer.isBuffer(buffer);\n}\n", "module.exports = function(source, from, to) {\n  return arguments.length === 2 ?\n    source.slice(from) :\n    source.slice(from, to)\n}\n", "var Buffer = require('buffer').Buffer\n\nmodule.exports = function(targets, hint) {\n  return hint !== undefined ?\n    Buffer.concat(targets, hint) :\n    Buffer.concat(targets)\n}\n", "module.exports = copy\n\nfunction copy(source, target, target_start, source_start, source_end) {\n  return source.copy(target, target_start, source_start, source_end)\n}\n", "var Buffer = require('buffer').Buffer\n\nvar version = ((process || {}).version || 'v0.0.0').slice(1).split('.')[0]\n\nmodule.exports = (\n  Number(version) < 6\n  ? function create(size) { return new Buffer(size) }\n  : function create(size) { return Buffer.alloc(size) }\n)\n", "var proto = {}\n  , rex = /read.+/\n  , buildFn\n\nbuildFn = function(key) {\n  var code = '' +\n    'return buf.' + key + '(' + ['a', 'b', 'c'].join(',' ) + ')'\n\n  return new Function(['buf', 'a', 'b', 'c'], code)\n}\n\nmodule.exports = proto\n\nfor(var key in Buffer.prototype) {\n  if(rex.test(key)) {\n    proto[key] = buildFn(key)\n  }\n}\n", "var Buffer = require('buffer').Buffer\n\nvar proto = {}\n  , rex = /write.+/\n  , buildFn\n\nbuildFn = function(key) {\n  var code = '' +\n    'return buf.' + key + '(' + ['a', 'b', 'c'].join(',' ) + ')'\n\n  return new Function(['buf', 'a', 'b', 'c'], code)\n}\n\nmodule.exports = proto\n\nfor(var key in Buffer.prototype) {\n  if(rex.test(key)) {\n    proto[key] = buildFn(key)\n  }\n}\n", "var proto = {}\nmodule.exports = proto\n\nproto.from = require('./from.js')\nproto.to = require('./to.js')\nproto.is = require('./is.js')\nproto.subarray = require('./subarray.js')\nproto.join = require('./join.js')\nproto.copy = require('./copy.js')\nproto.create = require('./create.js')\n\nmix(require('./read.js'), proto)\nmix(require('./write.js'), proto)\n\nfunction mix(from, into) {\n  for(var key in from) {\n    into[key] = from[key]\n  }\n}\n", "\"use strict\";\n\nvar bops = require('bops');\n\nexports.encode = function (value, sparse) {\n  var size = sizeof(value, sparse)\n  if(size == 0)\n    return undefined\n  var buffer = bops.create(size);\n  encode(value, buffer, 0, sparse);\n  return buffer;\n};\n\nexports.decode = decode;\n\nvar SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;\nfunction readInt64BE(buf, offset) {\n\toffset = offset || 0;\n\treturn buf.readInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n}\n\nfunction readUInt64BE(buf, offset) {\n\toffset = offset || 0;\n\treturn buf.readUInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n}\n\nfunction writeInt64BE(buf, val, offset) {\n    if (val < 0x8000000000000000) {\n        buf.writeInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n    } else {\n        buf.writeUInt32BE(0x7fffffff, offset);\n        buf.writeUInt32BE(0xffffffff, offset + 4);\n    }\n}\n\nfunction writeUInt64BE(buf, val, offset) {\n    if (val < 0x10000000000000000) {\n        buf.writeUInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n    } else {\n        buf.writeUInt32BE(0xffffffff, offset);\n        buf.writeUInt32BE(0xffffffff, offset + 4);\n    }\n}\n\n// https://gist.github.com/frsyuki/5432559 - v5 spec\n//\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\n// should translate to exactly 0xd40000 \n//\n// +--------+--------+--------+\n// |  0xd4  |  0x00  |  0x00  |\n// +--------+--------+--------+\n//    ^ fixext |        ^ value part unused (fixed to be 0)\n//             ^ indicates undefined value\n//\n\nfunction Decoder(buffer, offset) {\n  this.offset = offset || 0;\n  this.buffer = buffer;\n  this.bufferLength = buffer.length\n}\nDecoder.prototype.map = function (length) {\n  /* minimal map: every key and value is one byte */\n  if((length * 2) > this.bufferLength) {\n    throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a map of length ${length})`);\n  }\n  var value = {};\n  for (var i = 0; i < length; i++) {\n    var key = this.parse();\n    value[key] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.bin = Decoder.prototype.buf = function (length) {\n  if(length > this.bufferLength) {\n    throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a binary of length ${length})`);\n  }\n  var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.str = function (length) {\n  if(length > this.bufferLength) {\n    throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a string of length ${length})`);\n  }\n  var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.array = function (length) {\n  if(length > this.bufferLength) {\n    throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced an array of length ${length})`);\n  }\n  var value = new Array(length);\n  for (var i = 0; i < length; i++) {\n    value[i] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.parse = function () {\n  var type = this.buffer[this.offset];\n  var value, length, extType;\n\n  if (type === undefined) {\n    throw new Error('malformed messagepack (referenced offset is outside buffer)');\n  }\n\n  // Positive FixInt\n  if ((type & 0x80) === 0x00) {\n    this.offset++;\n    return type;\n  }\n  // FixMap\n  if ((type & 0xf0) === 0x80) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.map(length);\n  }\n  // FixArray\n  if ((type & 0xf0) === 0x90) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.array(length);\n  }\n  // FixStr\n  if ((type & 0xe0) === 0xa0) {\n    length = type & 0x1f;\n    this.offset++;\n    return this.str(length);\n  }\n  // Negative FixInt\n  if ((type & 0xe0) === 0xe0) {\n    value = bops.readInt8(this.buffer, this.offset);\n    this.offset++;\n    return value;\n  }\n  switch (type) {\n  // nil\n  case 0xc0:\n    this.offset++;\n    return null;\n  // 0xc1: (never used)\n  // false\n  case 0xc2:\n    this.offset++;\n    return false;\n  // true\n  case 0xc3:\n    this.offset++;\n    return true;\n  // bin 8\n  case 0xc4:\n    length = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return this.bin(length);\n  // bin 16\n  case 0xc5:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.bin(length);\n  // bin 32\n  case 0xc6:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.bin(length);\n  // ext 8\n  case 0xc7:\n    length = bops.readUInt8(this.buffer, this.offset + 1);\n    extType = bops.readUInt8(this.buffer, this.offset + 2);\n    this.offset += 3;\n    return [extType, this.bin(length)];\n  // ext 16\n  case 0xc8:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    extType = bops.readUInt8(this.buffer, this.offset + 3);\n    this.offset += 4;\n    return [extType, this.bin(length)];\n  // ext 32\n  case 0xc9:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    extType = bops.readUInt8(this.buffer, this.offset + 5);\n    this.offset += 6;\n    return [extType, this.bin(length)];\n  // float 32\n  case 0xca:\n    value = bops.readFloatBE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // float 64 / double\n  case 0xcb:\n    value = bops.readDoubleBE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // uint8\n  case 0xcc:\n    value = this.buffer[this.offset + 1];\n    this.offset += 2;\n    return value;\n  // uint 16\n  case 0xcd:\n    value = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // uint 32\n  case 0xce:\n    value = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // uint64\n  case 0xcf:\n    value = readUInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // int 8\n  case 0xd0:\n    value = bops.readInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return value;\n  // int 16\n  case 0xd1:\n    value = bops.readInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // int 32\n  case 0xd2:\n    value = bops.readInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // int 64\n  case 0xd3:\n    value = readInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n\n  // fixext 1 / undefined\n  case 0xd4:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    value = bops.readUInt8(this.buffer, this.offset + 2);\n    this.offset += 3;\n    return (extType === 0 && value === 0) ? undefined : [extType, value];\n  // fixext 2\n  case 0xd5:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(2)];\n  // fixext 4\n  case 0xd6:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(4)];\n  // fixext 8\n  case 0xd7:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(8)];\n  // fixext 16\n  case 0xd8:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(16)];\n  // str 8\n  case 0xd9:\n    length = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return this.str(length);\n  // str 16\n  case 0xda:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.str(length);\n  // str 32\n  case 0xdb:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.str(length);\n  // array 16\n  case 0xdc:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.array(length);\n  // array 32\n  case 0xdd:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.array(length);\n  // map 16:\n  case 0xde:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.map(length);\n  // map 32\n  case 0xdf:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.map(length);\n  }\n\n  throw new Error(\"Unknown type 0x\" + type.toString(16));\n};\nfunction decode(buffer) {\n  var decoder = new Decoder(buffer);\n  var value = decoder.parse();\n  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + \" trailing bytes\");\n  return value;\n}\n\nfunction encodeableKeys (value, sparse) {\n  return Object.keys(value).filter(function (e) {\n    var val = value[e], type = typeof(val);\n    return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);\n  })\n}\n\nfunction encode(value, buffer, offset, sparse, isMapElement) {\n  var type = typeof value;\n  var length, size;\n\n  // Strings Bytes\n  if (type === \"string\") {\n    value = bops.from(value);\n    length = value.length;\n    // fixstr\n    if (length < 0x20) {\n      buffer[offset] = length | 0xa0;\n      bops.copy(value, buffer, offset + 1);\n      return 1 + length;\n    }\n    // str 8\n    if (length < 0x100) {\n      buffer[offset] = 0xd9;\n      bops.writeUInt8(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 2);\n      return 2 + length;\n    }\n    // str 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xda;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // str 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xdb;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    // bin 8\n    if (length < 0x100) {\n      buffer[offset] = 0xc4;\n      bops.writeUInt8(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 2);\n      return 2 + length;\n    }\n    // bin 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xc5;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // bin 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xc6;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    if (Math.floor(value) !== value) {\n      buffer[offset] =  0xcb;\n      bops.writeDoubleBE(buffer, value, offset + 1);\n      return 9;\n    }\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) {\n        buffer[offset] = value;\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        buffer[offset] = 0xcc;\n        buffer[offset + 1] = value;\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        buffer[offset] = 0xcd;\n        bops.writeUInt16BE(buffer, value, offset + 1);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        buffer[offset] = 0xce;\n        bops.writeUInt32BE(buffer, value, offset + 1);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        buffer[offset] = 0xcf;\n        writeUInt64BE(buffer, value, offset + 1);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) {\n      bops.writeInt8(buffer, value, offset);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      buffer[offset] = 0xd0;\n      bops.writeInt8(buffer, value, offset + 1);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      buffer[offset] = 0xd1;\n      bops.writeInt16BE(buffer, value, offset + 1);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      buffer[offset] = 0xd2;\n      bops.writeInt32BE(buffer, value, offset + 1);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      buffer[offset] = 0xd3;\n      writeInt64BE(buffer, value, offset + 1);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  if (type === \"undefined\") {\n    if(sparse && isMapElement) return 0;\n    buffer[offset] = 0xd4;\n    buffer[offset + 1] = 0x00; // fixext special type/value\n    buffer[offset + 2] = 0x00;\n    return 3;\n  }\n\n  // null\n  if (value === null) {\n    if(sparse && isMapElement) return 0;\n    buffer[offset] = 0xc0;\n    return 1;\n  }\n\n  // Boolean\n  if (type === \"boolean\") {\n    buffer[offset] = value ? 0xc3 : 0xc2;\n    return 1;\n  }\n\n  if('function' === typeof value.toJSON)\n    return encode(value.toJSON(), buffer, offset, sparse)\n\n  // Container Types\n  if (type === \"object\") {\n\n    size = 0;\n    var isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = value.length;\n    }\n    else {\n      var keys = encodeableKeys(value, sparse)\n      length = keys.length;\n    }\n\n    // fixarray\n    if (length < 0x10) {\n      buffer[offset] = length | (isArray ? 0x90 : 0x80);\n      size = 1;\n    }\n    // array 16 / map 16\n    else if (length < 0x10000) {\n      buffer[offset] = isArray ? 0xdc : 0xde;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      size = 3;\n    }\n    // array 32 / map 32\n    else if (length < 0x100000000) {\n      buffer[offset] = isArray ? 0xdd : 0xdf;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (var i = 0; i < length; i++) {\n        size += encode(value[i], buffer, offset + size, sparse);\n      }\n    }\n    else {\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += encode(key, buffer, offset + size);\n        size += encode(value[key], buffer, offset + size, sparse, true);\n      }\n    }\n\n    return size;\n  }\n  if(type === \"function\")\n    return undefined\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction sizeof(value, sparse, isMapElement) {\n  var type = typeof value;\n  var length, size;\n\n  // Raw Bytes\n  if (type === \"string\") {\n    // TODO: this creates a throw-away buffer which is probably expensive on browsers.\n    length = bops.from(value).length;\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    // double\n    if (Math.floor(value) !== value) return 9;\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  // Boolean\n  if (type === \"boolean\") return 1;\n\n  // undefined, null\n  if (value === null) return (sparse && isMapElement) ? 0 : 1;\n  if (value === undefined) return (sparse && isMapElement) ? 0 : 3;\n\n  if('function' === typeof value.toJSON)\n    return sizeof(value.toJSON(), sparse)\n\n  // Container Types\n  if (type === \"object\") {\n\n    size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (var i = 0; i < length; i++) {\n        size += sizeof(value[i], sparse);\n      }\n    }\n    else {\n      var keys = encodeableKeys(value, sparse)\n      length = keys.length;\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += sizeof(key) + sizeof(value[key], sparse, true);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  if(type === \"function\")\n    return 0\n  throw new Error(\"Unknown type \" + type);\n}\n\n\n", "import { IPlatformConfig } from './types/IPlatformConfig';\nimport { IPlatformHttpStatic } from './types/http';\nimport IDefaults from './types/IDefaults';\nimport IWebStorage from './types/IWebStorage';\nimport IBufferUtils from './types/IBufferUtils';\nimport * as WebBufferUtils from '../platform/web/lib/util/bufferutils';\nimport * as NodeBufferUtils from '../platform/nodejs/lib/util/bufferutils';\nimport { IUntypedCryptoStatic } from '../common/types/ICryptoStatic';\nimport TransportName from './constants/TransportName';\nimport { TransportCtor } from './lib/transport/transport';\n\nexport type Bufferlike = WebBufferUtils.Bufferlike | NodeBufferUtils.Bufferlike;\ntype BufferUtilsOutput = WebBufferUtils.Output | NodeBufferUtils.Output;\ntype ToBufferOutput = WebBufferUtils.ToBufferOutput | NodeBufferUtils.ToBufferOutput;\n\nexport type TransportImplementations = Partial<Record<TransportName, TransportCtor>>;\n\nexport default class Platform {\n  static Config: IPlatformConfig;\n  /*\n     What we actually _want_ is for Platform to be a generic class\n     parameterised by Bufferlike etc, but that requires far-reaching changes to\n     components that make use of Platform. So instead we have to advertise a\n     BufferUtils object that accepts a broader range of data types than it\n     can in reality handle.\n   */\n  static BufferUtils: IBufferUtils<Bufferlike, BufferUtilsOutput, ToBufferOutput>;\n  /*\n     We\u2019d like this to be ICryptoStatic with the correct generic arguments,\n     but Platform doesn\u2019t currently allow that, as described in the BufferUtils\n     comment above.\n   */\n  static Crypto: IUntypedCryptoStatic | null;\n  static Http: IPlatformHttpStatic;\n  static Transports: {\n    order: TransportName[];\n    // Transport implementations that always come with this platform\n    bundledImplementations: TransportImplementations;\n  };\n  static Defaults: IDefaults;\n  static WebStorage: IWebStorage | null;\n}\n", "import Platform from 'common/platform';\n\nexport type LoggerOptions = {\n  handler: LoggerFunction;\n  level: LogLevels;\n};\ntype LoggerFunction = (...args: string[]) => void;\n\n// Workaround for salesforce lightning locker compatibility\n// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\n\nenum LogLevels {\n  None = 0,\n  Error = 1,\n  Major = 2,\n  Minor = 3,\n  Micro = 4,\n}\n\nfunction pad(timeSegment: number, three?: number) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, '0');\n}\n\nfunction getHandler(logger: Function): Function {\n  return Platform.Config.logTimestamps\n    ? function (msg: unknown) {\n        const time = new Date();\n        logger(\n          pad(time.getHours()) +\n            ':' +\n            pad(time.getMinutes()) +\n            ':' +\n            pad(time.getSeconds()) +\n            '.' +\n            pad(time.getMilliseconds(), 1) +\n            ' ' +\n            msg,\n        );\n      }\n    : function (msg: string) {\n        logger(msg);\n      };\n}\n\nconst getDefaultLoggers = (): [Function, Function] => {\n  let consoleLogger;\n  let errorLogger;\n\n  // we expect ably-js to be run in environments which have `console` object available with its `log` function\n  if (typeof globalObject?.console?.log === 'function') {\n    consoleLogger = function (...args: unknown[]) {\n      console.log.apply(console, args);\n    };\n\n    errorLogger = console.warn\n      ? function (...args: unknown[]) {\n          console.warn.apply(console, args);\n        }\n      : consoleLogger;\n  } else {\n    // otherwise we should fallback to noop for log functions\n    consoleLogger = errorLogger = function () {};\n  }\n\n  return [consoleLogger, errorLogger].map(getHandler) as [Function, Function];\n};\n\nclass Logger {\n  private static defaultLogLevel: LogLevels = LogLevels.Error;\n  private static defaultLogHandler: Function;\n  private static defaultLogErrorHandler: Function;\n\n  private logLevel: LogLevels;\n  private logHandler: Function;\n  private logErrorHandler: Function;\n\n  // public constants\n  static readonly LOG_NONE: LogLevels = LogLevels.None;\n  static readonly LOG_ERROR: LogLevels = LogLevels.Error;\n  static readonly LOG_MAJOR: LogLevels = LogLevels.Major;\n  static readonly LOG_MINOR: LogLevels = LogLevels.Minor;\n  static readonly LOG_MICRO: LogLevels = LogLevels.Micro;\n\n  /**\n   * This logger instance should only be used when there is no more appropriate logger to use, for example when implementing a public static method or function whose API doesn\u2019t accept any logging configuration.\n   */\n  static defaultLogger: Logger;\n\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new Logger();\n  }\n\n  constructor() {\n    this.logLevel = Logger.defaultLogLevel;\n    this.logHandler = Logger.defaultLogHandler;\n    this.logErrorHandler = Logger.defaultLogErrorHandler;\n  }\n\n  /* public static functions */\n  /**\n   * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n   *\n   * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you can\u2019t dynamically specify the log level.\n   */\n  static logAction = (logger: Logger, level: LogLevels, action: string, message?: string) => {\n    this.logActionNoStrip(logger, level, action, message);\n  };\n\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger: Logger, level: LogLevels, action: string, message?: string) {\n    logger.logAction(level, action, message);\n  }\n\n  private logAction(level: LogLevels, action: string, message?: string) {\n    if (this.shouldLog(level)) {\n      (level === LogLevels.Error ? this.logErrorHandler : this.logHandler)('Ably: ' + action + ': ' + message, level);\n    }\n  }\n\n  deprecated = (description: string, msg: string) => {\n    this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n  };\n\n  renamedClientOption(oldName: string, newName: string) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\n    );\n  }\n\n  renamedMethod(className: string, oldName: string, newName: string) {\n    this.deprecationWarning(\n      `\\`${className}\\`\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\n    );\n  }\n\n  deprecationWarning(message: string) {\n    if (this.shouldLog(LogLevels.Error)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, LogLevels.Error);\n    }\n  }\n\n  /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n\t   the object being serialised if the log level will not output the message */\n  shouldLog = (level: LogLevels) => {\n    return level <= this.logLevel;\n  };\n\n  setLog = (level: LogLevels | undefined, handler: Function | undefined) => {\n    if (level !== undefined) this.logLevel = level;\n    if (handler !== undefined) this.logHandler = this.logErrorHandler = handler;\n  };\n}\n\nexport default Logger;\n", "import Platform from 'common/platform';\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport { ModularPlugins } from '../client/modularplugins';\nimport { MsgPack } from 'common/types/msgpack';\n\nfunction randomPosn(arrOrStr: Array<unknown> | string) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\n\n/**\n * Add a set of properties to a target object\n *\n * @param target the target object\n * @param args objects, which enumerable properties are added to target, by reference only\n * @returns target object with added properties\n */\nexport function mixin(\n  target: Record<string, unknown>,\n  ...args: Array<object | undefined | null>\n): Record<string, unknown> {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = (source as Record<string, unknown>)[key];\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Creates a copy of enumerable properties of the source object\n *\n * @param src object to copy\n * @returns copy of src\n */\nexport function copy<T = Record<string, unknown>>(src: T | Record<string, unknown> | null | undefined): T {\n  return mixin({}, src as Record<string, unknown>) as T;\n}\n\n/*\n * Ensures that an Array object is always returned\n * returning the original Array of obj is an Array\n * else wrapping the obj in a single element Array\n */\nexport function ensureArray(obj: Record<string, unknown>): unknown[] {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\nexport function isObject(ob: unknown): ob is Record<string, unknown> {\n  return Object.prototype.toString.call(ob) == '[object Object]';\n}\n\n/*\n * Determine whether or not an object contains\n * any enumerable properties.\n * ob: the object\n */\nexport function isEmpty(ob: Record<string, unknown> | unknown[]): boolean {\n  for (const prop in ob) return false;\n  return true;\n}\n\n/**\n * Checks if `value` is `null` or `undefined`.\n *\n * Source: https://github.com/lodash/lodash/blob/main/src/isNil.ts\n */\nexport function isNil(arg: unknown): arg is null | undefined {\n  return arg == null;\n}\n\n/*\n * Perform a simple shallow clone of an object.\n * Result is an object irrespective of whether\n * the input is an object or array. All\n * enumerable properties are copied.\n * ob: the object\n */\nexport function shallowClone(ob: Record<string, unknown>): Record<string, unknown> {\n  const result = new Object() as Record<string, unknown>;\n  for (const prop in ob) result[prop] = ob[prop];\n  return result;\n}\n\n/*\n * Clone an object by creating a new object with the\n * given object as its prototype. Optionally\n * a set of additional own properties can be\n * supplied to be added to the newly created clone.\n * ob:            the object to be cloned\n * ownProperties: optional object with additional\n *                properties to add\n */\nexport function prototypicalClone(\n  ob: Record<string, unknown>,\n  ownProperties: Record<string, unknown>,\n): Record<string, unknown> {\n  class F {}\n  F.prototype = ob;\n  const result = new F() as Record<string, unknown>;\n  if (ownProperties) mixin(result, ownProperties);\n  return result;\n}\n\n/*\n * Declare a constructor to represent a subclass\n * of another constructor\n * If platform has a built-in version we use that from Platform, else we\n * define here (so can make use of other Utils fns)\n * See node.js util.inherits\n */\nexport const inherits = function (ctor: any, superCtor: Function) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\n\n/*\n * Determine whether or not an object has an enumerable\n * property whose value equals a given value.\n * ob:  the object\n * val: the value to find\n */\nexport function containsValue(ob: Record<string, unknown>, val: unknown): boolean {\n  for (const i in ob) {\n    if (ob[i] == val) return true;\n  }\n  return false;\n}\n\nexport function intersect<K extends string, T>(arr: Array<K>, ob: K[] | Partial<Record<K, T>>): K[] {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\n\nexport function arrIntersect<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1) result.push(member);\n  }\n  return result;\n}\n\nexport function arrIntersectOb<K extends string>(arr: Array<K>, ob: Partial<Record<K, unknown>>): K[] {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob) result.push(member);\n  }\n  return result;\n}\n\nexport function arrSubtract<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const element = arr1[i];\n    if (arr2.indexOf(element) == -1) result.push(element);\n  }\n  return result;\n}\n\nexport function arrDeleteValue<T>(arr: Array<T>, val: T): boolean {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res) arr.splice(idx, 1);\n  return res;\n}\n\nexport function arrWithoutValue<T>(arr: Array<T>, val: T): Array<T> {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\n\n/*\n * Construct an array of the keys of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nexport function keysArray(ob: Record<string, unknown>, ownOnly?: boolean): Array<string> {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n    result.push(prop);\n  }\n  return result;\n}\n\n/*\n * Construct an array of the values of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nexport function valuesArray<T>(ob: Record<string, T>, ownOnly?: boolean): T[] {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\n\nexport function forInOwnNonNullProperties(ob: Record<string, unknown>, fn: (prop: string) => void): void {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\n\nexport function allSame(arr: Array<Record<string, unknown>>, prop: string): boolean {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function (item) {\n    return item[prop] === first;\n  });\n}\n\nexport enum Format {\n  msgpack = 'msgpack',\n  json = 'json',\n}\n\nexport function arrPopRandomElement<T>(arr: Array<T>): T {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\n\nexport function toQueryString(params?: Record<string, string> | null): string {\n  const parts = [];\n  if (params) {\n    for (const key in params) parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\n  }\n  return parts.length ? '?' + parts.join('&') : '';\n}\n\nexport function parseQueryString(query: string): Record<string, string> {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result: Record<string, string> = {};\n\n  while ((match = search.exec(query))) result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n\n  return result;\n}\n\nexport function isErrorInfoOrPartialErrorInfo(err: unknown): err is ErrorInfo | PartialErrorInfo {\n  return typeof err == 'object' && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\n\nexport function inspectError(err: unknown): string {\n  if (\n    err instanceof Error ||\n    (err as ErrorInfo)?.constructor?.name === 'ErrorInfo' ||\n    (err as PartialErrorInfo)?.constructor?.name === 'PartialErrorInfo'\n  )\n    return (err as Error).toString();\n  return Platform.Config.inspect(err);\n}\n\nexport function inspectBody(body: unknown): string {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return (body as any).toString();\n  } else if (typeof body === 'string') {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\n\n/* Data is assumed to be either a string or a buffer. */\nexport function dataSizeBytes(data: string | Buffer): number {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === 'string') {\n    return Platform.Config.stringByteSize(data);\n  }\n  throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);\n}\n\nexport function cheapRandStr(): string {\n  return String(Math.random()).substr(2);\n}\n\n/* Takes param the minimum number of bytes of entropy the string must\n * include, not the length of the string. String length produced is not\n * guaranteed. */\nexport const randomString = async (numBytes: number): Promise<string> => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\n\n/* Pick n elements at random without replacement from an array */\nexport function arrChooseN<T>(arr: Array<T>, n: number): Array<T> {\n  const numItems = Math.min(n, arr.length),\n    mutableArr = arr.slice(),\n    result: Array<T> = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\n\n/**\n * Uses a callback to communicate the result of a `Promise`. The first argument passed to the callback will be either an error (when the promise is rejected) or `null` (when the promise is fulfilled). In the case where the promise is fulfilled, the resulting value will be passed to the callback as a second argument.\n */\nexport function whenPromiseSettles<T, E = unknown>(\n  promise: Promise<T>,\n  callback?: (err: E | null, result?: T) => void,\n) {\n  promise\n    .then((result) => {\n      callback?.(null, result);\n    })\n    .catch((err: unknown) => {\n      // We make no guarantees about the type of the error that gets passed to the callback. Issue https://github.com/ably/ably-js/issues/1617 will think about how to correctly handle error types.\n      callback?.(err as E);\n    });\n}\n\nexport function decodeBody<T>(body: unknown, MsgPack: MsgPack | null, format?: Format | null): T {\n  if (format == 'msgpack') {\n    if (!MsgPack) {\n      throwMissingPluginError('MsgPack');\n    }\n    return MsgPack.decode(body as Buffer);\n  }\n\n  return JSON.parse(String(body));\n}\n\nexport function encodeBody(body: unknown, MsgPack: MsgPack | null, format?: Format): string | Buffer {\n  if (format == 'msgpack') {\n    if (!MsgPack) {\n      throwMissingPluginError('MsgPack');\n    }\n    return MsgPack.encode(body, true) as Buffer;\n  }\n\n  return JSON.stringify(body);\n}\n\nexport function allToLowerCase(arr: Array<string>): Array<string> {\n  return arr.map(function (element) {\n    return element && element.toLowerCase();\n  });\n}\n\nexport function allToUpperCase(arr: Array<string>): Array<string> {\n  return arr.map(function (element) {\n    return element && element.toUpperCase();\n  });\n}\n\nexport function getBackoffCoefficient(count: number) {\n  return Math.min((count + 2) / 3, 2);\n}\n\nexport function getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\n\n/**\n *\n * @param initialTimeout initial timeout value\n * @param retryAttempt integer indicating retryAttempt\n * @returns RetryTimeout value for given timeout and retryAttempt.\n * If x is the value generated then,\n * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,\n * Lower bound = 0.8 * Upper bound,\n * Lower bound < x < Upper bound\n */\nexport function getRetryTime(initialTimeout: number, retryAttempt: number) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\n\nexport function getGlobalObject() {\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  return self;\n}\n\nexport function shallowEquals(source: Record<string, unknown>, target: Record<string, unknown>) {\n  return (\n    Object.keys(source).every((key) => source[key] === target[key]) &&\n    Object.keys(target).every((key) => target[key] === source[key])\n  );\n}\n\nexport function matchDerivedChannel(name: string) {\n  /**\n   * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to\n   * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of\n   * channel params that work with derived channels.\n   *\n   * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,\n   * but it does not create any situation where the regex engine has to\n   * explore a large number of possible matches so it\u2019s safe to ignore\n   */\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/; // eslint-disable-line\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo('regex match failed', 400, 40010);\n  }\n  // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo\n  if (match![2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  // Return match values to be added to derive channel quantifier.\n  return {\n    qualifierParam: match[3] || '',\n    channelName: match[4],\n  };\n}\n\nexport function toBase64(str: string) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\n\nexport function arrEquals(a: any[], b: any[]) {\n  return (\n    a.length === b.length &&\n    a.every(function (val, i) {\n      return val === b[i];\n    })\n  );\n}\n\nexport function createMissingPluginError(pluginName: keyof ModularPlugins): ErrorInfo {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\n\nexport function throwMissingPluginError(pluginName: keyof ModularPlugins): never {\n  throw createMissingPluginError(pluginName);\n}\n\nexport async function withTimeoutAsync<A>(promise: Promise<A>, timeout = 5000, err = 'Timeout expired'): Promise<A> {\n  const e = new ErrorInfo(err, 50000, 500);\n  return Promise.race([promise, new Promise<A>((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\n\ntype NonFunctionKeyNames<A> = { [P in keyof A]: A[P] extends Function ? never : P }[keyof A];\nexport type Properties<A> = Pick<A, NonFunctionKeyNames<A>>;\n", "import Platform from 'common/platform';\nimport * as Utils from '../util/utils';\nimport * as API from '../../../../ably';\n\nexport interface IPartialErrorInfo extends Error {\n  code: number | null;\n  statusCode?: number;\n  cause?: string | Error | ErrorInfo;\n  href?: string;\n}\n\nfunction toString(err: ErrorInfo | PartialErrorInfo) {\n  let result = '[' + err.constructor.name;\n  if (err.message) result += ': ' + err.message;\n  if (err.statusCode) result += '; statusCode=' + err.statusCode;\n  if (err.code) result += '; code=' + err.code;\n  if (err.cause) result += '; cause=' + Utils.inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1)) result += '; see ' + err.href + ' ';\n  result += ']';\n  return result;\n}\n\nexport interface IConvertibleToErrorInfo {\n  message: string;\n  code: number;\n  statusCode: number;\n}\n\nexport interface IConvertibleToPartialErrorInfo {\n  message: string;\n  code: number | null;\n  statusCode?: number;\n}\n\nexport default class ErrorInfo extends Error implements IPartialErrorInfo, API.ErrorInfo {\n  code: number;\n  statusCode: number;\n  cause?: string | Error | ErrorInfo;\n  href?: string;\n\n  constructor(message: string, code: number, statusCode: number, cause?: string | Error | ErrorInfo) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== 'undefined') {\n      Object.setPrototypeOf(this, ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n\n  toString(): string {\n    return toString(this);\n  }\n\n  static fromValues(values: IConvertibleToErrorInfo): ErrorInfo {\n    const { message, code, statusCode } = values;\n    if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {\n      throw new Error('ErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = 'https://help.ably.io/error/' + result.code;\n    }\n    return result;\n  }\n}\n\nexport class PartialErrorInfo extends Error implements IPartialErrorInfo {\n  code: number | null;\n  statusCode?: number;\n  cause?: string | Error | ErrorInfo;\n  href?: string;\n\n  constructor(message: string, code: number | null, statusCode?: number, cause?: string | Error | ErrorInfo) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== 'undefined') {\n      Object.setPrototypeOf(this, PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n\n  toString(): string {\n    return toString(this);\n  }\n\n  static fromValues(values: IConvertibleToPartialErrorInfo): PartialErrorInfo {\n    const { message, code, statusCode } = values;\n    if (\n      typeof message !== 'string' ||\n      (!Utils.isNil(code) && typeof code !== 'number') ||\n      (!Utils.isNil(statusCode) && typeof statusCode !== 'number')\n    ) {\n      throw new Error('PartialErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = 'https://help.ably.io/error/' + result.code;\n    }\n    return result;\n  }\n}\n", "{\n  \"name\": \"ably\",\n  \"description\": \"Realtime client library for Ably, the realtime messaging service\",\n  \"version\": \"2.6.0\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ably/ably-js/issues\",\n    \"email\": \"support@ably.com\"\n  },\n  \"main\": \"./build/ably-node.js\",\n  \"browser\": \"./build/ably.js\",\n  \"react-native\": \"./build/ably-reactnative.js\",\n  \"typings\": \"./ably.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./ably.d.ts\",\n      \"node\": \"./build/ably-node.js\",\n      \"react-native\": \"./build/ably-reactnative.js\",\n      \"default\": \"./build/ably.js\"\n    },\n    \"./modular\": {\n      \"types\": \"./modular.d.ts\",\n      \"import\": \"./build/modular/index.mjs\"\n    },\n    \"./react\": {\n      \"require\": \"./react/cjs/index.js\",\n      \"import\": \"./react/mjs/index.js\"\n    },\n    \"./push\": {\n      \"types\": \"./push.d.ts\",\n      \"import\": \"./build/push.js\"\n    }\n  },\n  \"files\": [\n    \"build/**\",\n    \"ably.d.ts\",\n    \"push.d.ts\",\n    \"modular.d.ts\",\n    \"resources/**\",\n    \"src/**\",\n    \"react/**\"\n  ],\n  \"dependencies\": {\n    \"@ably/msgpack-js\": \"^0.4.0\",\n    \"fastestsmallesttextencoderdecoder\": \"^1.0.22\",\n    \"got\": \"^11.8.5\",\n    \"ulid\": \"^2.3.0\",\n    \"ws\": \"^8.17.1\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=16.8.0\",\n    \"react-dom\": \">=16.8.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"react-dom\": {\n      \"optional\": true\n    }\n  },\n  \"devDependencies\": {\n    \"@ably/vcdiff-decoder\": \"1.0.6\",\n    \"@arethetypeswrong/cli\": \"^0.13.1\",\n    \"@babel/generator\": \"^7.23.6\",\n    \"@babel/parser\": \"^7.23.6\",\n    \"@babel/traverse\": \"^7.23.7\",\n    \"@testing-library/react\": \"^13.3.0\",\n    \"@types/cli-table\": \"^0.3.4\",\n    \"@types/jmespath\": \"^0.15.2\",\n    \"@types/node\": \"^18.0.0\",\n    \"@types/request\": \"^2.48.7\",\n    \"@types/ws\": \"^8.2.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.6\",\n    \"@typescript-eslint/parser\": \"^5.59.6\",\n    \"@vitejs/plugin-react\": \"^1.3.2\",\n    \"async\": \"ably-forks/async#requirejs\",\n    \"aws-sdk\": \"^2.1413.0\",\n    \"chai\": \"^4.2.0\",\n    \"cli-table\": \"^0.3.11\",\n    \"cors\": \"^2.8.5\",\n    \"csv\": \"^6.3.9\",\n    \"dox\": \"^1.0.0\",\n    \"esbuild\": \"^0.18.10\",\n    \"esbuild-plugin-umd-wrapper\": \"ably-forks/esbuild-plugin-umd-wrapper#1.0.7-optional-amd-named-module\",\n    \"esbuild-runner\": \"^2.2.2\",\n    \"eslint\": \"^7.13.0\",\n    \"eslint-plugin-import\": \"^2.28.0\",\n    \"eslint-plugin-jsdoc\": \"^40.0.0\",\n    \"eslint-plugin-react\": \"^7.32.2\",\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\n    \"eslint-plugin-security\": \"^1.4.0\",\n    \"express\": \"^4.17.1\",\n    \"glob\": \"^10.4.2\",\n    \"grunt\": \"^1.6.1\",\n    \"grunt-cli\": \"~1.2.0\",\n    \"grunt-shell\": \"~1.1\",\n    \"grunt-webpack\": \"^5.0.0\",\n    \"hexy\": \"~0.2\",\n    \"jmespath\": \"^0.16.0\",\n    \"jsdom\": \"^20.0.0\",\n    \"minimist\": \"^1.2.5\",\n    \"mocha\": \"^8.1.3\",\n    \"mocha-junit-reporter\": \"^2.2.1\",\n    \"path-browserify\": \"^1.0.1\",\n    \"playwright\": \"^1.39.0\",\n    \"prettier\": \"^3.3.3\",\n    \"process\": \"^0.11.10\",\n    \"react\": \">=18.1.0\",\n    \"react-dom\": \">=18.1.0\",\n    \"requirejs\": \"~2.1\",\n    \"shelljs\": \"~0.8\",\n    \"source-map-explorer\": \"^2.5.2\",\n    \"source-map-support\": \"^0.5.21\",\n    \"stream-browserify\": \"^3.0.0\",\n    \"ts-loader\": \"^9.4.2\",\n    \"tsconfig-paths-webpack-plugin\": \"^4.0.1\",\n    \"tslib\": \"^2.3.1\",\n    \"typedoc\": \"^0.24.7\",\n    \"typescript\": \"^4.9.5\",\n    \"vite\": \"^4.4.9\",\n    \"vitest\": \"^0.18.0\",\n    \"webpack\": \"^5.79.0\",\n    \"webpack-cli\": \"^5.0.1\"\n  },\n  \"engines\": {\n    \"node\": \">=16\"\n  },\n  \"repository\": \"ably/ably-js\",\n  \"jspm\": {\n    \"registry\": \"npm\",\n    \"directories\": {\n      \"lib\": \"build\"\n    },\n    \"main\": \"ably\"\n  },\n  \"scripts\": {\n    \"start:react\": \"npx vite serve\",\n    \"grunt\": \"grunt\",\n    \"test\": \"npm run test:node\",\n    \"test:node\": \"npm run build:node && npm run build:push && mocha\",\n    \"test:grep\": \"npm run build:node && npm run build:push && mocha --grep\",\n    \"test:node:skip-build\": \"mocha\",\n    \"test:webserver\": \"grunt test:webserver\",\n    \"test:playwright\": \"node test/support/runPlaywrightTests.js\",\n    \"test:react\": \"vitest run\",\n    \"test:package\": \"grunt test:package\",\n    \"concat\": \"grunt concat\",\n    \"build\": \"grunt build:all && npm run build:react\",\n    \"build:node\": \"grunt build:node\",\n    \"build:browser\": \"grunt build:browser\",\n    \"build:react\": \"npm run build:react:mjs && npm run build:react:cjs && cp src/platform/react-hooks/res/package.react.json react/package.json\",\n    \"build:react:mjs\": \"tsc --project src/platform/react-hooks/tsconfig.mjs.json && cp src/platform/react-hooks/res/package.mjs.json react/mjs/package.json\",\n    \"build:react:cjs\": \"tsc --project src/platform/react-hooks/tsconfig.cjs.json && cp src/platform/react-hooks/res/package.cjs.json react/cjs/package.json\",\n    \"build:push\": \"grunt build:push\",\n    \"requirejs\": \"grunt requirejs\",\n    \"lint\": \"eslint .\",\n    \"lint:fix\": \"eslint --fix .\",\n    \"prepare\": \"npm run build\",\n    \"format\": \"prettier --write .\",\n    \"format:check\": \"prettier --check .\",\n    \"sourcemap\": \"source-map-explorer build/ably.min.js\",\n    \"modulereport\": \"tsc --noEmit --esModuleInterop scripts/moduleReport.ts && esr scripts/moduleReport.ts\",\n    \"speccoveragereport\": \"tsc --noEmit --esModuleInterop --target ES2017 --moduleResolution node scripts/specCoverageReport.ts && esr scripts/specCoverageReport.ts\",\n    \"process-private-api-data\": \"tsc --noEmit --esModuleInterop --strictNullChecks scripts/processPrivateApiData/run.ts && esr scripts/processPrivateApiData/run.ts\",\n    \"docs\": \"typedoc\"\n  }\n}\n", "import Platform from 'common/platform';\nimport * as Utils from './utils';\nimport Logger from './logger';\nimport ErrorInfo from 'common/lib/types/errorinfo';\nimport { version } from '../../../../package.json';\nimport ClientOptions, { NormalisedClientOptions } from 'common/types/ClientOptions';\nimport IDefaults from '../../types/IDefaults';\nimport { MsgPack } from 'common/types/msgpack';\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\nimport { ChannelOptions } from 'common/types/channel';\nimport { ModularPlugins } from '../client/modularplugins';\n\nlet agent = 'ably-js/' + version;\n\ntype CompleteDefaults = IDefaults & {\n  ENVIRONMENT: string;\n  REST_HOST: string;\n  REALTIME_HOST: string;\n  FALLBACK_HOSTS: string[];\n  PORT: number;\n  TLS_PORT: number;\n  TIMEOUTS: {\n    disconnectedRetryTimeout: number;\n    suspendedRetryTimeout: number;\n    httpRequestTimeout: number;\n    httpMaxRetryDuration: number;\n    channelRetryTimeout: number;\n    fallbackRetryTimeout: number;\n    connectionStateTtl: number;\n    realtimeRequestTimeout: number;\n    recvTimeout: number;\n    webSocketConnectTimeout: number;\n    webSocketSlowTimeout: number;\n  };\n  httpMaxRetryCount: number;\n  maxMessageSize: number;\n  version: string;\n  protocolVersion: number;\n  agent: string;\n  getHost(options: ClientOptions, host?: string | null, ws?: boolean): string;\n  getPort(options: ClientOptions, tls?: boolean): number | undefined;\n  getHttpScheme(options: ClientOptions): string;\n  environmentFallbackHosts(environment: string): string[];\n  getFallbackHosts(options: NormalisedClientOptions): string[];\n  getHosts(options: NormalisedClientOptions, ws?: boolean): string[];\n  checkHost(host: string): void;\n  objectifyOptions(\n    options: undefined | ClientOptions | string,\n    allowKeyOrToken: boolean,\n    sourceForErrorMessage: string,\n    logger: Logger,\n    modularPluginsToInclude?: ModularPlugins,\n  ): ClientOptions;\n  normaliseOptions(options: ClientOptions, MsgPack: MsgPack | null, logger: Logger | null): NormalisedClientOptions;\n  defaultGetHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\n  defaultPostHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\n};\n\nconst Defaults = {\n  ENVIRONMENT: '',\n  REST_HOST: 'rest.ably.io',\n  REALTIME_HOST: 'realtime.ably.io',\n  FALLBACK_HOSTS: [\n    'A.ably-realtime.com',\n    'B.ably-realtime.com',\n    'C.ably-realtime.com',\n    'D.ably-realtime.com',\n    'E.ably-realtime.com',\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15000,\n    suspendedRetryTimeout: 30000,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 10000,\n    httpMaxRetryDuration: 15000,\n    channelRetryTimeout: 15000,\n    fallbackRetryTimeout: 600000,\n    /* For internal / test use only: */\n    connectionStateTtl: 120000,\n    realtimeRequestTimeout: 10000,\n    recvTimeout: 90000,\n    webSocketConnectTimeout: 10000,\n    webSocketSlowTimeout: 4000,\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n\n  version,\n  protocolVersion: 3,\n  agent,\n  getHost,\n  getPort,\n  getHttpScheme,\n  environmentFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders,\n};\n\nexport function getHost(options: ClientOptions, host?: string | null, ws?: boolean): string {\n  if (ws) host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;\n  else host = host || options.restHost;\n\n  return host as string;\n}\n\nexport function getPort(options: ClientOptions, tls?: boolean): number | undefined {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\n\nexport function getHttpScheme(options: ClientOptions): string {\n  return options.tls ? 'https://' : 'http://';\n}\n\n// construct environment fallback hosts as per RSC15i\nexport function environmentFallbackHosts(environment: string): string[] {\n  return [\n    environment + '-a-fallback.ably-realtime.com',\n    environment + '-b-fallback.ably-realtime.com',\n    environment + '-c-fallback.ably-realtime.com',\n    environment + '-d-fallback.ably-realtime.com',\n    environment + '-e-fallback.ably-realtime.com',\n  ];\n}\n\nexport function getFallbackHosts(options: NormalisedClientOptions): string[] {\n  const fallbackHosts = options.fallbackHosts,\n    httpMaxRetryCount =\n      typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n\n  return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\n\nexport function getHosts(options: NormalisedClientOptions, ws?: boolean): string[] {\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\n}\n\nfunction checkHost(host: string): void {\n  if (typeof host !== 'string') {\n    throw new ErrorInfo('host must be a string; was a ' + typeof host, 40000, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo('host must not be zero-length', 40000, 400);\n  }\n}\n\nfunction getRealtimeHost(options: ClientOptions, production: boolean, environment: string, logger: Logger): string {\n  if (options.realtimeHost) return options.realtimeHost;\n  /* prefer setting realtimeHost to restHost as a custom restHost typically indicates\n   * a development environment is being used that can't be inferred by the library */\n  if (options.restHost) {\n    Logger.logAction(\n      logger,\n      Logger.LOG_MINOR,\n      'Defaults.normaliseOptions',\n      'restHost is set to \"' +\n        options.restHost +\n        '\" but realtimeHost is not set, so setting realtimeHost to \"' +\n        options.restHost +\n        '\" too. If this is not what you want, please set realtimeHost explicitly.',\n    );\n    return options.restHost;\n  }\n  return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;\n}\n\nfunction getTimeouts(options: ClientOptions) {\n  /* Allow values passed in options to override default timeouts */\n  const timeouts: Record<string, number> = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = (options as Record<string, number>)[prop] || (Defaults.TIMEOUTS as Record<string, number>)[prop];\n  }\n  return timeouts;\n}\n\nexport function getAgentString(options: ClientOptions): string {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent in options.agents) {\n      agentStr += ' ' + agent + '/' + options.agents[agent];\n    }\n  }\n  return agentStr;\n}\n\nexport function objectifyOptions(\n  options: undefined | ClientOptions | string,\n  allowKeyOrToken: boolean,\n  sourceForErrorMessage: string,\n  logger: Logger,\n  modularPluginsToInclude?: ModularPlugins,\n): ClientOptions {\n  if (options === undefined) {\n    const msg = allowKeyOrToken\n      ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token`\n      : `${sourceForErrorMessage} must be initialized with a client options object`;\n    Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n\n  let optionsObj: ClientOptions;\n\n  if (typeof options === 'string') {\n    if (options.indexOf(':') == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\u2019s \\`token\\` property.)`;\n        Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\u2019s \\`key\\` property.)`;\n        Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n\n  if (modularPluginsToInclude) {\n    optionsObj = { ...optionsObj, plugins: { ...modularPluginsToInclude, ...optionsObj.plugins } };\n  }\n\n  return optionsObj;\n}\n\nexport function normaliseOptions(\n  options: ClientOptions,\n  MsgPack: MsgPack | null,\n  logger: Logger | null, // should only be omitted by tests\n): NormalisedClientOptions {\n  const loggerToUse = logger ?? Logger.defaultLogger;\n\n  if (typeof options.recover === 'function' && options.closeOnUnload === true) {\n    Logger.logAction(\n      loggerToUse,\n      Logger.LOG_ERROR,\n      'Defaults.normaliseOptions',\n      'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter',\n    );\n    options.recover = undefined;\n  }\n\n  if (!('closeOnUnload' in options)) {\n    /* Have closeOnUnload default to true unless we have any indication that\n     * the user may want to recover the connection */\n    options.closeOnUnload = !options.recover;\n  }\n\n  if (!('queueMessages' in options)) options.queueMessages = true;\n\n  /* infer hosts and fallbacks based on the configured environment */\n  const environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;\n  const production = !environment || environment === 'production';\n\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\n  }\n\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);\n  const realtimeHost = getRealtimeHost(options, production, environment, loggerToUse);\n\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\n\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!('tls' in options)) options.tls = true;\n\n  const timeouts = getTimeouts(options);\n\n  if (MsgPack) {\n    if ('useBinaryProtocol' in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n\n  const headers: Record<string, string> = {};\n  if (options.clientId) {\n    headers['X-Ably-ClientId'] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n\n  if (!('idempotentRestPublishing' in options)) {\n    options.idempotentRestPublishing = true;\n  }\n\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split('?');\n    connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};\n    if (uri.indexOf('://') === -1) {\n      uri = 'https://' + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n\n  let wsConnectivityCheckUrl = options.wsConnectivityCheckUrl;\n  if (wsConnectivityCheckUrl && wsConnectivityCheckUrl.indexOf('://') === -1) {\n    wsConnectivityCheckUrl = 'wss://' + wsConnectivityCheckUrl;\n  }\n\n  return {\n    ...options,\n    realtimeHost,\n    restHost,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    wsConnectivityCheckUrl,\n    headers,\n  };\n}\n\nexport function normaliseChannelOptions(Crypto: IUntypedCryptoStatic | null, logger: Logger, options?: ChannelOptions) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\n    const cipher = Crypto.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if ('cipher' in channelOptions) {\n    /* Don't deactivate an existing cipher unless options\n     * has a 'cipher' key that's falsey */\n    channelOptions.cipher = undefined;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\n\nconst contentTypes = {\n  json: 'application/json',\n  xml: 'application/xml',\n  html: 'text/html',\n  msgpack: 'application/x-msgpack',\n  text: 'text/plain',\n};\n\nexport interface HeadersOptions {\n  format?: Utils.Format | 'xml' | 'html' | 'text';\n  protocolVersion?: number;\n}\n\nconst defaultHeadersOptions: Required<HeadersOptions> = {\n  format: Utils.Format.json,\n  protocolVersion: Defaults.protocolVersion,\n};\n\nexport function defaultGetHeaders(\n  options: NormalisedClientOptions,\n  {\n    format = defaultHeadersOptions.format,\n    protocolVersion = defaultHeadersOptions.protocolVersion,\n  }: HeadersOptions = {},\n): Record<string, string> {\n  const accept = contentTypes[format];\n  return {\n    accept: accept,\n    'X-Ably-Version': protocolVersion.toString(),\n    'Ably-Agent': getAgentString(options),\n  };\n}\n\nexport function defaultPostHeaders(\n  options: NormalisedClientOptions,\n  {\n    format = defaultHeadersOptions.format,\n    protocolVersion = defaultHeadersOptions.protocolVersion,\n  }: HeadersOptions = {},\n): Record<string, string> {\n  let contentType;\n  const accept = (contentType = contentTypes[format]);\n\n  return {\n    accept: accept,\n    'content-type': contentType,\n    'X-Ably-Version': protocolVersion.toString(),\n    'Ably-Agent': getAgentString(options),\n  };\n}\n\nexport default Defaults as CompleteDefaults;\n\nexport function getDefaults(platformDefaults: IDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n", "import { StandardCallback } from 'common/types/utils';\nimport ErrorInfo from 'common/lib/types/errorinfo';\nimport Logger from './logger';\n\nexport interface MulticasterInstance<T> extends Function {\n  (err?: ErrorInfo | null, result?: T): void;\n  push: (fn: StandardCallback<T>) => void;\n  /**\n   * Creates a promise that will be resolved or rejected when this instance is called.\n   */\n  createPromise: () => Promise<T>;\n  /**\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (null, result).\n   */\n  resolveAll(result: T): void;\n  /**\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (err).\n   */\n  rejectAll(err: ErrorInfo): void;\n}\n\nclass Multicaster<T> {\n  members: Array<StandardCallback<T>>;\n\n  // Private constructor; use static Multicaster.create instead\n  private constructor(\n    private readonly logger: Logger,\n    members?: Array<StandardCallback<T> | undefined>,\n  ) {\n    this.members = (members as Array<StandardCallback<T>>) || [];\n  }\n\n  private call(err?: ErrorInfo | null, result?: T): void {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_ERROR,\n            'Multicaster multiple callback handler',\n            'Unexpected exception: ' + e + '; stack = ' + (e as Error).stack,\n          );\n        }\n      }\n    }\n  }\n\n  push(...args: Array<StandardCallback<T>>): void {\n    this.members.push(...args);\n  }\n\n  createPromise(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result!);\n      });\n    });\n  }\n\n  resolveAll(result: T) {\n    this.call(null, result);\n  }\n\n  rejectAll(err: ErrorInfo) {\n    this.call(err);\n  }\n\n  static create<T>(logger: Logger, members?: Array<StandardCallback<T> | undefined>): MulticasterInstance<T> {\n    const instance = new Multicaster(logger, members);\n    return Object.assign((err?: ErrorInfo | null, result?: T) => instance.call(err, result), {\n      push: (fn: StandardCallback<T>) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result: T) => instance.resolveAll(result),\n      rejectAll: (err: ErrorInfo) => instance.rejectAll(err),\n    });\n  }\n}\n\nexport default Multicaster;\n", "enum HttpMethods {\n  Get = 'get',\n  Delete = 'delete',\n  Post = 'post',\n  Put = 'put',\n  Patch = 'patch',\n}\n\nexport default HttpMethods;\n", "enum HttpStatusCodes {\n  Success = 200,\n  NoContent = 204,\n  BadRequest = 400,\n  Unauthorized = 401,\n  Forbidden = 403,\n  RequestTimeout = 408,\n  InternalServerError = 500,\n}\n\nexport function isSuccessCode(statusCode: number) {\n  return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;\n}\n\nexport default HttpStatusCodes;\n", "import Logger from '../util/logger';\nimport * as Utils from '../util/utils';\nimport Multicaster, { MulticasterInstance } from '../util/multicaster';\nimport ErrorInfo, { IPartialErrorInfo } from '../types/errorinfo';\nimport { RequestResultError, RequestParams, RequestResult } from '../../types/http';\nimport * as API from '../../../../ably';\nimport BaseClient from './baseclient';\nimport BaseRealtime from './baserealtime';\nimport ClientOptions from '../../types/ClientOptions';\nimport HttpMethods from '../../constants/HttpMethods';\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\nimport Platform, { Bufferlike } from '../../platform';\nimport Defaults from '../util/defaults';\n\ntype BatchResult<T> = API.BatchResult<T>;\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\ntype TokenRevocationOptions = API.TokenRevocationOptions;\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\n\nconst MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);\n}\n\nfunction isRealtime(client: BaseClient): client is BaseRealtime {\n  return !!(client as BaseRealtime).connection;\n}\n\n/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */\nfunction normaliseAuthcallbackError(err: any) {\n  if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  /* network errors will not have an inherent error code */\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      /* normalise statusCode to 401 per RSA4e */\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\n\nlet hmac = (text: string, key: string): string => {\n  const bufferUtils = Platform.BufferUtils;\n\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n\n  return bufferUtils.base64Encode(digest);\n};\n\nfunction c14n(capability?: string | Record<string, Array<string>>) {\n  if (!capability) return '';\n\n  if (typeof capability == 'string') capability = JSON.parse(capability);\n\n  const c14nCapability: Record<string, Array<string>> = Object.create(null);\n  const keys = Utils.keysArray(capability as Record<string, Array<string>>, true);\n  if (!keys) return '';\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = (capability as Record<string, Array<string>>)[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\n\nfunction logAndValidateTokenAuthMethod(authOptions: AuthOptions, logger: Logger) {\n  if (authOptions.authCallback) {\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with authCallback');\n  } else if (authOptions.authUrl) {\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with authUrl');\n  } else if (authOptions.key) {\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');\n  } else if (authOptions.tokenDetails) {\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');\n  } else {\n    const msg = 'authOptions must include valid authentication parameters';\n    Logger.logAction(logger, Logger.LOG_ERROR, 'Auth()', msg);\n    throw new Error(msg);\n  }\n}\n\nfunction basicAuthForced(options: ClientOptions) {\n  return 'useTokenAuth' in options && !options.useTokenAuth;\n}\n\n/* RSA4 */\nexport function useTokenAuth(options: ClientOptions) {\n  return (\n    options.useTokenAuth ||\n    (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails))\n  );\n}\n\n/* RSA4a */\nfunction noWayToRenew(options: ClientOptions) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\n\nlet trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\n\n/**\n * Auth options used only for testing.\n */\ntype PrivateAuthOptions = {\n  requestHeaders?: Record<string, string>;\n  suppressMaxLengthCheck?: boolean;\n};\n\ntype AuthOptions = API.AuthOptions & PrivateAuthOptions;\n\nclass Auth {\n  client: BaseClient;\n  tokenParams: API.TokenParams;\n  currentTokenRequestId: number | null;\n  waitingForTokenRequest: MulticasterInstance<API.TokenDetails> | null;\n  // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n  authOptions: AuthOptions = {} as AuthOptions;\n  tokenDetails?: API.TokenDetails | null;\n  method?: string;\n  key?: string;\n  basicKey?: string;\n  clientId?: string | null;\n\n  constructor(client: BaseClient, options: ClientOptions) {\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    /* The id of the current token request if one is in progress, else null */\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n\n    if (useTokenAuth(options)) {\n      /* Token auth */\n      if (noWayToRenew(options)) {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_ERROR,\n          'Auth()',\n          'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams as API.TokenDetails, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      /* Basic auth */\n      if (!options.key) {\n        const msg =\n          'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth()', msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');\n      this._saveBasicOptions(options);\n    }\n  }\n\n  get logger(): Logger {\n    return this.client.logger;\n  }\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   */\n  async authorize(): Promise<API.TokenDetails>;\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   *\n   * - ttl:        (optional) the requested life of any new token in ms. If none\n   *               is specified a default of 1 hour is provided. The maximum lifetime\n   *               is 24hours; any request exceeding that lifetime will be rejected\n   *               with an error.\n   *\n   * - capability: (optional) the capability to associate with the access token.\n   *               If none is specified, a token will be requested with all of the\n   *               capabilities of the specified key.\n   *\n   * - clientId:   (optional) a client ID to associate with the token\n   *\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\n   *               the system will be queried for a time value to use.\n   */\n  async authorize(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   *\n   * - ttl:        (optional) the requested life of any new token in ms. If none\n   *               is specified a default of 1 hour is provided. The maximum lifetime\n   *               is 24hours; any request exceeding that lifetime will be rejected\n   *               with an error.\n   *\n   * - capability: (optional) the capability to associate with the access token.\n   *               If none is specified, a token will be requested with all of the\n   *               capabilities of the specified key.\n   *\n   * - clientId:   (optional) a client ID to associate with the token\n   *\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\n   *               the system will be queried for a time value to use.\n   *\n   * @param authOptions\n   * an object containing auth options relevant to token auth:\n   *\n   * - queryTime   (optional) boolean indicating that the Ably system should be\n   *               queried for the current time when none is specified explicitly.\n   *\n   * - tokenDetails: (optional) object: An authenticated TokenDetails object.\n   *\n   * - token:        (optional) string: the `token` property of a tokenDetails object\n   *\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\n   *                  authCallback should be a function of (tokenParams, callback) that calls\n   *                  the callback with (err, result), where result is any of:\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\n   *                  - a token string\n   *\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\n   *                  params, to obtain a signed token request.\n   *\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\n   *                  made to the authUrl.\n   *\n   * - authParams:    (optional) a set of application-specific query params to be added to any\n   *                  request made to the authUrl.\n   *\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   */\n  async authorize(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null): Promise<API.TokenDetails>;\n\n  async authorize(\n    tokenParams?: Record<string, any> | null,\n    authOptions?: AuthOptions | null,\n  ): Promise<API.TokenDetails> {\n    /* RSA10a: authorize() call implies token auth. If a key is passed it, we\n     * just check if it doesn't clash and assume we're generating a token from it */\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo('Unable to update auth options with incompatible key', 40102, 401);\n    }\n\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams ?? null, authOptions ?? null);\n\n      /* RTC8\n       * - When authorize called by an end user and have a realtime connection,\n       * don't call back till new token has taken effect.\n       * - Use this.client.connection as a proxy for (this.client instanceof BaseRealtime),\n       * which doesn't work in node as BaseRealtime isn't part of the vm context for Rest clients */\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          (this.client as BaseRealtime).connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err: unknown, tokenDetails?: API.TokenDetails) => (err ? reject(err) : resolve(tokenDetails!)),\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if ((this.client as BaseRealtime).connection && (err as ErrorInfo).statusCode === HttpStatusCodes.Forbidden) {\n        /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to\n         * stay connecticed by returning a 403, we actively disconnect the connection\n         * even though we may well still have time left in the old token. */\n        (this.client as BaseRealtime).connection.connectionManager.actOnErrorFromAuthorize(err as ErrorInfo);\n      }\n      throw err;\n    }\n  }\n\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(\n    tokenParams: API.TokenParams | null,\n    authOptions: AuthOptions | null,\n  ): Promise<API.TokenDetails> {\n    /* get rid of current token even if still valid */\n    this.tokenDetails = null;\n\n    /* _save normalises the tokenParams and authOptions and updates the auth\n     * object. All subsequent operations should use the values on `this`,\n     * not the passed in ones. */\n    this._saveTokenOptions(tokenParams, authOptions);\n\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      /* RSA10g */\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n\n  /**\n   * Request an access token\n   */\n  async requestToken(): Promise<API.TokenDetails>;\n\n  /**\n   * Request an access token\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async requestToken(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\n\n  /**\n   * Request an access token\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use.\n   *\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\n   *                  authCallback should be a function of (tokenParams, callback) that calls\n   *                  the callback with (err, result), where result is any of:\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\n   *                  - a token string\n   *\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\n   *                  params, to obtain a signed token request.\n   *\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\n   *                  made to the authUrl.\n   *\n   * - authParams:    (optional) a set of application-specific query params to be added to any\n   *                  request made to the authUrl.\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   */\n  async requestToken(tokenParams: API.TokenParams | null, authOptions: AuthOptions): Promise<API.TokenDetails>;\n\n  async requestToken(tokenParams?: API.TokenParams | null, authOptions?: AuthOptions): Promise<API.TokenDetails> {\n    /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || Utils.copy(this.tokenParams);\n\n    /* first set up whatever callback will be used to get signed\n     * token requests */\n    let tokenRequestCallback: (\n        data: API.TokenParams,\n        callback: (\n          error: API.ErrorInfo | RequestResultError | string | null,\n          tokenRequestOrDetails: API.TokenDetails | API.TokenRequest | string | null,\n          contentType?: string,\n        ) => void,\n      ) => void,\n      client = this.client;\n\n    if (resolvedAuthOptions.authCallback) {\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = Utils.mixin(\n          { accept: 'application/json, text/plain' },\n          resolvedAuthOptions.authHeaders,\n        ) as Record<string, string>;\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === 'post';\n        let providedQsParams;\n        /* Combine authParams with any qs params given in the authUrl */\n        const queryIdx = resolvedAuthOptions.authUrl!.indexOf('?');\n        if (queryIdx > -1) {\n          providedQsParams = Utils.parseQueryString(resolvedAuthOptions.authUrl!.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl!.slice(0, queryIdx);\n          if (!usePost) {\n            /* In case of conflict, authParams take precedence over qs params in the authUrl */\n            resolvedAuthOptions.authParams = Utils.mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams,\n            ) as typeof resolvedAuthOptions.authParams;\n          }\n        }\n        /* RSA8c2 */\n        const authParams = Utils.mixin({}, resolvedAuthOptions.authParams || {}, params) as RequestParams;\n        const authUrlRequestCallback = (result: RequestResult) => {\n          let body = (result.body ?? null) as string | Bufferlike | API.TokenDetails | API.TokenRequest | null;\n\n          let contentType: string | null = null;\n          if (result.error) {\n            Logger.logAction(\n              this.logger,\n              Logger.LOG_MICRO,\n              'Auth.requestToken().tokenRequestCallback',\n              'Received Error: ' + Utils.inspectError(result.error),\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = result.headers!['content-type'] ?? null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              // Combine multiple header values into a comma-separated list per https://datatracker.ietf.org/doc/html/rfc9110#section-5.2; see https://github.com/ably/ably-js/issues/1616 for doing this consistently across the codebase.\n              contentType = contentTypeHeaderOrHeaders.join(', ');\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            Logger.logAction(\n              this.logger,\n              Logger.LOG_MICRO,\n              'Auth.requestToken().tokenRequestCallback',\n              'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body),\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body as Exclude<typeof body, Bufferlike>);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body)) body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo('authUrl response is missing a content-type header', 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf('application/json') > -1,\n            text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                'authUrl responded with unacceptable content-type ' +\n                  contentType +\n                  ', should be either text/plain, application/jwt or application/json',\n                40170,\n                401,\n              ),\n              null,\n            );\n            return;\n          }\n          if (json) {\n            if ((body as string).length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo('authUrl response exceeded max permitted length', 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body as string);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  'Unexpected error processing authURL response; err = ' + (e as Error).message,\n                  40170,\n                  401,\n                ),\n                null,\n              );\n              return;\n            }\n          }\n          cb(null, body as Exclude<typeof body, Bufferlike>, contentType);\n        };\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MICRO,\n          'Auth.requestToken().tokenRequestCallback',\n          'Requesting token from ' +\n            resolvedAuthOptions.authUrl +\n            '; Params: ' +\n            JSON.stringify(authParams) +\n            '; method: ' +\n            (usePost ? 'POST' : 'GET'),\n        );\n        if (usePost) {\n          /* send body form-encoded */\n          const headers = authHeaders || {};\n          headers['content-type'] = 'application/x-www-form-urlencoded';\n          const body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */\n          Utils.whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods.Post,\n              resolvedAuthOptions.authUrl!,\n              headers,\n              body,\n              providedQsParams as Record<string, string>,\n            ),\n            (err: any, result) =>\n              err\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\n                : authUrlRequestCallback(result!),\n          );\n        } else {\n          Utils.whenPromiseSettles(\n            this.client.http.doUri(HttpMethods.Get, resolvedAuthOptions.authUrl!, authHeaders || {}, null, authParams),\n            (err: any, result) =>\n              err\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\n                : authUrlRequestCallback(result!),\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'Auth.requestToken()',\n        'using token auth with client-side signing',\n      );\n      tokenRequestCallback = (params, cb) => {\n        Utils.whenPromiseSettles(this.createTokenRequest(params, resolvedAuthOptions), (err, result) =>\n          cb(err as string | ErrorInfo | null, result ?? null),\n        );\n      };\n    } else {\n      const msg =\n        'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_ERROR,\n        'Auth()',\n        'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n\n    /* normalise token params */\n    if ('capability' in (resolvedTokenParams as Record<string, any>))\n      (resolvedTokenParams as Record<string, any>).capability = c14n(\n        (resolvedTokenParams as Record<string, any>).capability,\n      );\n\n    const tokenRequest = (\n      signedTokenParams: Record<string, any>,\n      tokenCb: (err: RequestResultError | null, tokenResponse?: API.TokenDetails | string, unpacked?: boolean) => void,\n    ) => {\n      const keyName = signedTokenParams.keyName,\n        path = '/keys/' + keyName + '/requestToken',\n        tokenUri = function (host: string) {\n          return client.baseUri(host) + path;\n        };\n\n      const requestHeaders = Defaults.defaultPostHeaders(this.client.options);\n      if (resolvedAuthOptions.requestHeaders) Utils.mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MICRO,\n        'Auth.requestToken().requestToken',\n        'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams),\n      );\n      Utils.whenPromiseSettles(\n        this.client.http.do(HttpMethods.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err: any, result) =>\n          err\n            ? tokenCb(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\n            : tokenCb(result!.error, result!.body as API.TokenDetails | string | undefined, result!.unpacked),\n      );\n    };\n\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false,\n        timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,\n        tokenRequestCallbackTimeout = setTimeout(() => {\n          tokenRequestCallbackTimeoutExpired = true;\n          const msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n        }, timeoutLength);\n\n      tokenRequestCallback!(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired) return;\n        clearTimeout(tokenRequestCallbackTimeout);\n\n        if (err) {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_ERROR,\n            'Auth.requestToken()',\n            'token request signing call returned error; err = ' + Utils.inspectError(err),\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        /* the response from the callback might be a token string, a signed request or a token details */\n        if (typeof tokenRequestOrDetails === 'string') {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo('Token string is empty', 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                'Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)',\n                40170,\n                401,\n              ),\n            );\n          } else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {\n            /* common failure mode with poorly-implemented authCallbacks */\n            reject(new ErrorInfo('Token string was literal null/undefined', 40170, 401));\n          } else if (\n            tokenRequestOrDetails[0] === '{' &&\n            !(contentType && contentType.indexOf('application/jwt') > -1)\n          ) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401,\n              ),\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails } as API.TokenDetails);\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== 'object' || tokenRequestOrDetails === null) {\n          const msg =\n            'Expected token request callback to call back with a token string or token request/details object, but got a ' +\n            typeof tokenRequestOrDetails;\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              'Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)',\n              40170,\n              401,\n            ),\n          );\n          return;\n        }\n        if ('issued' in tokenRequestOrDetails) {\n          /* a tokenDetails object */\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!('keyName' in tokenRequestOrDetails)) {\n          const msg =\n            'Expected token request callback to call back with a token string, token request object, or token details object';\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        /* it's a token request, so make the request */\n        tokenRequest(tokenRequestOrDetails, (err, tokenResponse, unpacked) => {\n          if (err) {\n            Logger.logAction(\n              this.logger,\n              Logger.LOG_ERROR,\n              'Auth.requestToken()',\n              'token request API call returned error; err = ' + Utils.inspectError(err),\n            );\n            reject(normaliseAuthcallbackError(err));\n            return;\n          }\n          if (!unpacked) tokenResponse = JSON.parse(tokenResponse as string);\n          Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getToken()', 'token received');\n          resolve(tokenResponse as API.TokenDetails);\n        });\n      });\n    });\n  }\n\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams: API.TokenParams | null, authOptions: any): Promise<API.TokenRequest> {\n    /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || Utils.copy<API.TokenParams>(this.tokenParams);\n\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo('No key specified', 40101, 403);\n    }\n    const keyParts = key.split(':'),\n      keyName = keyParts[0],\n      keySecret = keyParts[1];\n\n    if (!keySecret) {\n      throw new ErrorInfo('Invalid key specified', 40101, 403);\n    }\n\n    if (tokenParams.clientId === '') {\n      throw new ErrorInfo('clientId can\u2019t be an empty string', 40012, 400);\n    }\n\n    if ('capability' in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n\n    const request: Partial<API.TokenRequest> = Utils.mixin({ keyName: keyName }, tokenParams),\n      clientId = tokenParams.clientId || '',\n      ttl = tokenParams.ttl || '',\n      capability = tokenParams.capability || '';\n\n    if (!request.timestamp) {\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\n    }\n\n    /* nonce */\n    /* NOTE: there is no expectation that the client\n     * specifies the nonce; this is done by the library\n     * However, this can be overridden by the client\n     * simply for testing purposes. */\n    const nonce = request.nonce || (request.nonce = random()),\n      timestamp = request.timestamp;\n\n    const signText =\n      request.keyName + '\\n' + ttl + '\\n' + capability + '\\n' + clientId + '\\n' + timestamp + '\\n' + nonce + '\\n';\n\n    /* mac */\n    /* NOTE: there is no expectation that the client\n     * specifies the mac; this is done by the library\n     * However, this can be overridden by the client\n     * simply for testing purposes. */\n    request.mac = request.mac || hmac(signText, keySecret);\n\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');\n\n    return request as API.TokenRequest;\n  }\n\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams(): Promise<Record<string, string>> {\n    if (this.method == 'basic') return { key: this.key! };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders(): Promise<Record<string, string>> {\n    if (this.method == 'basic') {\n      return { authorization: 'Basic ' + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n      }\n      return { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) };\n    }\n  }\n\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime: boolean): Promise<number> {\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n      return this.client.time();\n    } else {\n      return this.getTimestampUsingOffset();\n    }\n  }\n\n  getTimestampUsingOffset() {\n    return Date.now() + (this.client.serverTimeOffset || 0);\n  }\n\n  isTimeOffsetSet() {\n    return this.client.serverTimeOffset !== null;\n  }\n\n  _saveBasicOptions(authOptions: AuthOptions) {\n    this.method = 'basic';\n    this.key = authOptions.key;\n    this.basicKey = Utils.toBase64(authOptions.key as string);\n    this.authOptions = authOptions || {};\n    if ('clientId' in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n\n  _saveTokenOptions(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null) {\n    this.method = 'token';\n\n    if (tokenParams) {\n      /* We temporarily persist tokenParams.timestamp in case a new token needs\n       * to be requested, then null it out in the callback of\n       * _ensureValidAuthCredentials for RSA10g compliance */\n      this.tokenParams = tokenParams;\n    }\n\n    if (authOptions) {\n      /* normalise */\n      if (authOptions.token) {\n        /* options.token may contain a token string or, for convenience, a TokenDetails */\n        authOptions.tokenDetails =\n          typeof authOptions.token === 'string'\n            ? ({ token: authOptions.token } as API.TokenDetails)\n            : authOptions.token;\n      }\n\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n\n      if ('clientId' in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n\n      this.authOptions = authOptions;\n    }\n  }\n\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede: boolean): Promise<API.TokenDetails> {\n    const token = this.tokenDetails;\n\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        /* 403 to trigger a permanently failed client - RSA15c */\n        throw new ErrorInfo(\n          'Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')',\n          40102,\n          403,\n        );\n      }\n      /* RSA4b1 -- if we have a server time offset set already, we can\n       * automatically remove expired tokens. Else just use the cached token. If it is\n       * expired Ably will tell us and we'll discard it then. */\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'Auth.getToken()',\n          'using cached token; expires = ' + token.expires,\n        );\n        return token;\n      }\n      /* expired, so remove and fallthrough to getting a new one */\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');\n      this.tokenDetails = null;\n    }\n\n    const promise = (\n      this.waitingForTokenRequest || (this.waitingForTokenRequest = Multicaster.create(this.logger))\n    ).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n\n    /* Request a new token */\n    const tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());\n\n    let tokenResponse: API.TokenDetails,\n      caughtError: ErrorInfo | null = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err as ErrorInfo;\n    }\n\n    if ((this.currentTokenRequestId as number) > tokenRequestId) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'Auth._ensureValidAuthCredentials()',\n        'Discarding token request response; overtaken by newer one',\n      );\n      return promise;\n    }\n\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster?.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster?.resolveAll((this.tokenDetails = tokenResponse!));\n\n    return promise;\n  }\n\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId: string | undefined) {\n    if (!(typeof clientId === 'string' || clientId === null)) {\n      throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\n    } else if (clientId === '*') {\n      throw new ErrorInfo(\n        'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400,\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err) throw err;\n    }\n  }\n\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId: string | undefined) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      /* Should never happen in normal circumstances as realtime should\n       * recognise mismatch and return an error */\n      const msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);\n      return err;\n    } else {\n      /* RSA7a4: if options.clientId is provided and is not\n       * null, it overrides defaultTokenParams.clientId */\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n\n  _tokenClientIdMismatch(tokenClientId?: string | null): boolean {\n    return !!(\n      this.clientId &&\n      this.clientId !== '*' &&\n      tokenClientId &&\n      tokenClientId !== '*' &&\n      this.clientId !== tokenClientId\n    );\n  }\n\n  static isTokenErr(error: IPartialErrorInfo) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n\n  revokeTokens(\n    specifiers: TokenRevocationTargetSpecifier[],\n    options?: TokenRevocationOptions,\n  ): Promise<TokenRevocationResult> {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n}\n\nexport default Auth;\n", "import Defaults from 'common/lib/util/defaults';\nimport Platform from 'common/platform';\nimport BaseRealtime from 'common/lib/client/baserealtime';\nimport HttpMethods from '../constants/HttpMethods';\nimport BaseClient from '../lib/client/baseclient';\nimport ErrorInfo, { IPartialErrorInfo } from '../lib/types/errorinfo';\nimport Logger from 'common/lib/util/logger';\nimport * as Utils from 'common/lib/util/utils';\n\nexport type PathParameter = string | ((host: string) => string);\nexport type ResponseHeaders = Partial<Record<string, string | string[]>>;\nexport type RequestResultError = ErrnoException | IPartialErrorInfo;\n\n/**\n * The `body`, `headers`, `unpacked`, and `statusCode` properties of a `RequestResult` may be populated even if its `error` property is non-null.\n */\nexport type RequestResult = {\n  error: RequestResultError | null;\n  body?: unknown;\n  headers?: ResponseHeaders;\n  unpacked?: boolean;\n  statusCode?: number;\n};\n\nexport type RequestParams = Record<string, string> | null;\nexport type RequestBody =\n  | Buffer // only on Node\n  | ArrayBuffer // only on web\n  | string;\n\nexport interface IPlatformHttpStatic {\n  new (client?: BaseClient): IPlatformHttp;\n  methods: Array<HttpMethods>;\n  methodsWithBody: Array<HttpMethods>;\n  methodsWithoutBody: Array<HttpMethods>;\n}\n\nexport interface IPlatformHttp {\n  supportsAuthHeaders: boolean;\n  supportsLinkHeaders: boolean;\n\n  /**\n   * This method should not throw any errors; rather, it should communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  doUri(\n    method: HttpMethods,\n    uri: string,\n    headers: Record<string, string> | null,\n    body: RequestBody | null,\n    params: RequestParams,\n  ): Promise<RequestResult>;\n\n  checkConnectivity?: () => Promise<boolean>;\n\n  /**\n   * @param error An error from the {@link RequestResult.error} property of a result returned by {@link doUri}.\n   */\n  shouldFallback(error: RequestResultError): boolean;\n}\n\nexport function paramString(params: Record<string, any> | null) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + '=' + params[needle]);\n    }\n  }\n  return paramPairs.join('&');\n}\n\nexport function appendingParams(uri: string, params: Record<string, any> | null) {\n  return uri + (params ? '?' : '') + paramString(params);\n}\n\nfunction logResult(\n  result: RequestResult,\n  method: HttpMethods,\n  uri: string,\n  params: Record<string, string> | null,\n  logger: Logger,\n) {\n  if (result.error) {\n    Logger.logActionNoStrip(\n      logger,\n      Logger.LOG_MICRO,\n      'Http.' + method + '()',\n      'Received Error; ' + appendingParams(uri, params) + '; Error: ' + Utils.inspectError(result.error),\n    );\n  } else {\n    Logger.logActionNoStrip(\n      logger,\n      Logger.LOG_MICRO,\n      'Http.' + method + '()',\n      'Received; ' +\n        appendingParams(uri, params) +\n        '; Headers: ' +\n        paramString(result.headers as Record<string, any>) +\n        '; StatusCode: ' +\n        result.statusCode +\n        '; Body' +\n        (Platform.BufferUtils.isBuffer(result.body)\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\n          : ': ' + result.body),\n    );\n  }\n}\n\nfunction logRequest(method: HttpMethods, uri: string, body: RequestBody | null, params: RequestParams, logger: Logger) {\n  if (logger.shouldLog(Logger.LOG_MICRO)) {\n    Logger.logActionNoStrip(\n      logger,\n      Logger.LOG_MICRO,\n      'Http.' + method + '()',\n      'Sending; ' +\n        appendingParams(uri, params) +\n        '; Body' +\n        (Platform.BufferUtils.isBuffer(body) ? ' (Base64): ' + Platform.BufferUtils.base64Encode(body) : ': ' + body),\n    );\n  }\n}\n\nexport class Http {\n  private readonly platformHttp: IPlatformHttp;\n  checkConnectivity?: () => Promise<boolean>;\n\n  constructor(private readonly client?: BaseClient) {\n    this.platformHttp = new Platform.Http(client);\n\n    this.checkConnectivity = this.platformHttp.checkConnectivity\n      ? () => this.platformHttp.checkConnectivity!()\n      : undefined;\n  }\n\n  get logger(): Logger {\n    return this.client?.logger ?? Logger.defaultLogger;\n  }\n\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n\n  _getHosts(client: BaseClient) {\n    /* If we're a connected realtime client, try the endpoint we're connected\n     * to first -- but still have fallbacks, being connected is not an absolute\n     * guarantee that a datacenter has free capacity to service REST requests. */\n    const connection = (client as BaseRealtime).connection,\n      connectionHost = connection && connection.connectionManager.host;\n\n    if (connectionHost) {\n      return [connectionHost].concat(Defaults.getFallbackHosts(client.options));\n    }\n\n    return Defaults.getHosts(client.options);\n  }\n\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(\n    method: HttpMethods,\n    path: PathParameter,\n    headers: Record<string, string> | null,\n    body: RequestBody | null,\n    params: RequestParams,\n  ): Promise<RequestResult> {\n    try {\n      /* Unlike for doUri, the presence of `this.client` here is mandatory, as it's used to generate the hosts */\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo('http.do called without client', 50000, 500) };\n      }\n\n      const uriFromHost =\n        typeof path === 'function'\n          ? path\n          : function (host: string) {\n              return client.baseUri(host) + path;\n            };\n\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          /* Use stored fallback */\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException)) {\n            /* unstore the fallback and start from the top with the default sequence */\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          /* Fallback expired; remove it and fallthrough to normal sequence */\n          client._currentFallback = null;\n        }\n      }\n\n      const hosts = this._getHosts(client);\n\n      /* see if we have one or more than one host */\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n\n      let tryAHostStartedAt: Date | null = null;\n      const tryAHost = async (candidateHosts: Array<string>, persistOnSuccess?: boolean): Promise<RequestResult> => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt ?? new Date();\n        const result = await this.doUri(method, uriFromHost(host as string), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException) && candidateHosts.length) {\n          // TO3l6\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500,\n              ),\n            };\n          }\n\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          /* RSC15f */\n          client._currentFallback = {\n            host: host as string,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout,\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${Utils.inspectError(err)}`, 500, 50000) };\n    }\n  }\n\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(\n    method: HttpMethods,\n    uri: string,\n    headers: Record<string, string> | null,\n    body: RequestBody | null,\n    params: RequestParams,\n  ): Promise<RequestResult> {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n\n      if (this.logger.shouldLog(Logger.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n\n      return result;\n    } catch (err) {\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${Utils.inspectError(err)}`, 500, 50000) };\n    }\n  }\n}\n\nexport interface ErrnoException extends Error {\n  errno?: number;\n  code?: string;\n  path?: string;\n  syscall?: string;\n  stack?: string;\n  statusCode: number;\n}\n", "import Logger, { LoggerOptions } from '../util/logger';\nimport Defaults from '../util/defaults';\nimport Auth from './auth';\nimport { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\nimport ErrorInfo from '../types/errorinfo';\nimport Stats from '../types/stats';\nimport { Http, RequestParams } from '../../types/http';\nimport ClientOptions, { NormalisedClientOptions } from '../../types/ClientOptions';\nimport * as API from '../../../../ably';\nimport * as Utils from '../util/utils';\n\nimport Platform from '../../platform';\nimport { Rest } from './rest';\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\nimport { throwMissingPluginError } from '../util/utils';\nimport { MsgPack } from 'common/types/msgpack';\nimport { HTTPRequestImplementations } from 'platform/web/lib/http/http';\nimport { FilteredSubscriptions } from './filteredsubscriptions';\nimport type { LocalDevice } from 'plugins/push/pushactivation';\n\ntype BatchResult<T> = API.BatchResult<T>;\ntype BatchPublishSpec = API.BatchPublishSpec;\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\n\n/**\n `BaseClient` acts as the base class for all of the client classes exported by the SDK. It is an implementation detail and this class is not advertised publicly.\n */\nclass BaseClient {\n  options: NormalisedClientOptions;\n  _currentFallback: null | {\n    host: string;\n    validUntil: number;\n  };\n  serverTimeOffset: number | null;\n  http: Http;\n  auth: Auth;\n\n  private readonly _rest: Rest | null;\n  readonly _Crypto: IUntypedCryptoStatic | null;\n  readonly _MsgPack: MsgPack | null;\n  // Extra HTTP request implementations available to this client, in addition to those in web\u2019s Http.bundledRequestImplementations\n  readonly _additionalHTTPRequestImplementations: HTTPRequestImplementations | null;\n  private readonly __FilteredSubscriptions: typeof FilteredSubscriptions | null;\n  readonly logger: Logger;\n  _device?: LocalDevice;\n\n  constructor(options: ClientOptions) {\n    this._additionalHTTPRequestImplementations = options.plugins ?? null;\n\n    this.logger = new Logger();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'BaseClient()',\n      'initialized with clientOptions ' + Platform.Config.inspect(options),\n    );\n\n    this._MsgPack = options.plugins?.MsgPack ?? null;\n    const normalOptions = (this.options = Defaults.normaliseOptions(options, this._MsgPack, this.logger));\n\n    /* process options */\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = 'invalid key parameter';\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'BaseClient()', msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n\n    if ('clientId' in normalOptions) {\n      if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))\n        throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\n      else if (normalOptions.clientId === '*')\n        throw new ErrorInfo(\n          'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400,\n        );\n    }\n\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'BaseClient()', 'started; version = ' + Defaults.version);\n\n    this._currentFallback = null;\n\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new Auth(this, normalOptions);\n\n    this._rest = options.plugins?.Rest ? new options.plugins.Rest(this) : null;\n    this._Crypto = options.plugins?.Crypto ?? null;\n    this.__FilteredSubscriptions = options.plugins?.MessageInteractions ?? null;\n  }\n\n  get rest(): Rest {\n    if (!this._rest) {\n      throwMissingPluginError('Rest');\n    }\n    return this._rest;\n  }\n\n  get _FilteredSubscriptions(): typeof FilteredSubscriptions {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError('MessageInteractions');\n    }\n    return this.__FilteredSubscriptions;\n  }\n\n  get channels() {\n    return this.rest.channels;\n  }\n\n  get push() {\n    return this.rest.push;\n  }\n\n  get device() {\n    if (!this.options.plugins?.Push || !this.push.LocalDevice) {\n      throwMissingPluginError('Push');\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n\n  baseUri(host: string) {\n    return Defaults.getHttpScheme(this.options) + host + ':' + Defaults.getPort(this.options, false);\n  }\n\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\n    return this.rest.stats(params);\n  }\n\n  async time(params?: RequestParams): Promise<number> {\n    return this.rest.time(params);\n  }\n\n  async request(\n    method: string,\n    path: string,\n    version: number,\n    params: RequestParams,\n    body: unknown,\n    customHeaders: Record<string, string>,\n  ): Promise<HttpPaginatedResponse<unknown>> {\n    return this.rest.request(method, path, version, params, body, customHeaders);\n  }\n\n  batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\n    specOrSpecs: T,\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n\n  batchPresence(channels: string[]): Promise<BatchPresenceResult> {\n    return this.rest.batchPresence(channels);\n  }\n\n  setLog(logOptions: LoggerOptions): void {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n\n  static Platform = Platform;\n\n  /**\n   * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n   */\n  Platform = Platform;\n  ErrorInfo = ErrorInfo;\n  Logger = Logger;\n  Defaults = Defaults;\n  Utils = Utils;\n}\n\nexport default BaseClient;\n", "import { MsgPack } from 'common/types/msgpack';\nimport type { LocalDevice } from 'plugins/push/pushactivation';\nimport * as Utils from '../util/utils';\nimport ErrorInfo, { IConvertibleToErrorInfo } from './errorinfo';\n\nexport enum DeviceFormFactor {\n  Phone = 'phone',\n  Tablet = 'tablet',\n  Desktop = 'desktop',\n  TV = 'tv',\n  Watch = 'watch',\n  Car = 'car',\n  Embedded = 'embedded',\n  Other = 'other',\n}\n\nexport enum DevicePlatform {\n  Android = 'android',\n  IOS = 'ios',\n  Browser = 'browser',\n}\n\ntype DevicePushState = 'ACTIVE' | 'FAILING' | 'FAILED';\n\ninterface WebPushEncryptionKey {\n  p256dh: string;\n  auth: string;\n}\n\ninterface WebPushRecipient {\n  transportType: 'web';\n  targetUrl: string;\n  encryptionKey: WebPushEncryptionKey;\n  publicVapidKey: string;\n}\n\ninterface PushChannelRecipient {\n  transportType: 'ablyChannel';\n  channel: string;\n  ablyKey: string;\n  ablyUrl: string;\n}\n\ntype PushRecipient = WebPushRecipient | PushChannelRecipient;\n\nexport type DevicePushDetails = {\n  error?: ErrorInfo;\n  recipient?: PushRecipient;\n  state?: DevicePushState;\n  metadata?: string;\n};\n\nclass DeviceDetails {\n  id?: string;\n  clientId?: string;\n  deviceSecret?: string;\n  formFactor?: DeviceFormFactor;\n  platform?: DevicePlatform;\n  push?: DevicePushDetails;\n  metadata?: string;\n  deviceIdentityToken?: string;\n\n  toJSON(): DeviceDetails {\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: this.push?.recipient,\n        state: this.push?.state,\n        error: this.push?.error,\n      },\n    } as DeviceDetails;\n  }\n\n  toString(): string {\n    let result = '[DeviceDetails';\n    if (this.id) result += '; id=' + this.id;\n    if (this.platform) result += '; platform=' + this.platform;\n    if (this.formFactor) result += '; formFactor=' + this.formFactor;\n    if (this.clientId) result += '; clientId=' + this.clientId;\n    if (this.metadata) result += '; metadata=' + this.metadata;\n    if (this.deviceIdentityToken) result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);\n    if (this.push?.recipient) result += '; push.recipient=' + JSON.stringify(this.push.recipient);\n    if (this.push?.state) result += '; push.state=' + this.push.state;\n    if (this.push?.error) result += '; push.error=' + JSON.stringify(this.push.error);\n    if (this.push?.metadata) result += '; push.metadata=' + this.push.metadata;\n    result += ']';\n    return result;\n  }\n\n  static toRequestBody(body: unknown, MsgPack: MsgPack | null, format?: Utils.Format) {\n    return Utils.encodeBody(body, MsgPack, format);\n  }\n\n  static fromResponseBody(\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\n    MsgPack: MsgPack | null,\n    format?: Utils.Format,\n  ): DeviceDetails | DeviceDetails[] {\n    if (format) {\n      body = Utils.decodeBody(body, MsgPack, format);\n    }\n\n    if (Array.isArray(body)) {\n      return DeviceDetails.fromValuesArray(body);\n    } else {\n      return DeviceDetails.fromValues(body);\n    }\n  }\n\n  static fromValues(values: Record<string, unknown>): DeviceDetails {\n    values.error = values.error && ErrorInfo.fromValues(values.error as IConvertibleToErrorInfo);\n    return Object.assign(new DeviceDetails(), values);\n  }\n\n  static fromLocalDevice(device: LocalDevice): DeviceDetails {\n    return Object.assign(new DeviceDetails(), device);\n  }\n\n  static fromValuesArray(values: Array<Record<string, unknown>>): DeviceDetails[] {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n}\n\nexport default DeviceDetails;\n", "import Platform from '../../platform';\nimport * as Utils from '../util/utils';\nimport Logger from '../util/logger';\nimport Auth from './auth';\nimport HttpMethods from '../../constants/HttpMethods';\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from '../types/errorinfo';\nimport BaseClient from './baseclient';\nimport { MsgPack } from 'common/types/msgpack';\nimport { RequestBody, ResponseHeaders, appendingParams as urlFromPathAndParams, paramString } from 'common/types/http';\nimport httpStatusCodes from '../../constants/HttpStatusCodes';\n\nasync function withAuthDetails<T>(\n  client: BaseClient,\n  headers: ResponseHeaders | undefined,\n  params: Record<string, any>,\n  opCallback: Function,\n): Promise<ResourceResult<T>> {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(Utils.mixin(authHeaders!, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, Utils.mixin(authParams!, params));\n  }\n}\n\nfunction unenvelope<T>(\n  result: ResourceResult<T>,\n  MsgPack: MsgPack | null,\n  format: Utils.Format | null,\n): ResourceResult<T> {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n\n  if (result.statusCode === httpStatusCodes.NoContent) {\n    return { ...result, body: [] as any, unpacked: true };\n  }\n\n  let body = result.body;\n\n  if (!result.unpacked) {\n    try {\n      body = Utils.decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (Utils.isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(Utils.inspectError(e), null) };\n      }\n    }\n  }\n\n  if (!body) {\n    return { err: new PartialErrorInfo('unenvelope(): Response body is missing', null) };\n  }\n\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body as Record<string, any>;\n\n  if (wrappedStatusCode === undefined) {\n    /* Envelope already unwrapped by the transport */\n    return { ...result, body, unpacked: true };\n  }\n\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    /* handle wrapped errors */\n    let wrappedErr = (response && response.error) || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error('Error in unenveloping ' + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\n\nfunction logResult<T>(\n  result: ResourceResult<T>,\n  method: HttpMethods,\n  path: string,\n  params: Record<string, string>,\n  logger: Logger,\n) {\n  if (result.err) {\n    Logger.logAction(\n      logger,\n      Logger.LOG_MICRO,\n      'Resource.' + method + '()',\n      'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(result.err),\n    );\n  } else {\n    Logger.logAction(\n      logger,\n      Logger.LOG_MICRO,\n      'Resource.' + method + '()',\n      'Received; ' +\n        urlFromPathAndParams(path, params) +\n        '; Headers: ' +\n        paramString(result.headers as Record<string, any>) +\n        '; StatusCode: ' +\n        result.statusCode +\n        '; Body: ' +\n        (Platform.BufferUtils.isBuffer(result.body)\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\n          : ': ' + Platform.Config.inspect(result.body)),\n    );\n  }\n}\n\nexport interface ResourceResponse<T> {\n  body?: T;\n  headers?: ResponseHeaders;\n  unpacked?: boolean;\n  statusCode?: number;\n}\n\nexport interface ResourceResult<T> extends ResourceResponse<T> {\n  /**\n   * Any error returned by the underlying HTTP client.\n   */\n  err: IPartialErrorInfo | null;\n}\n\nclass Resource {\n  /**\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\n   *\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\n   */\n  static async get<T = unknown>(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: true,\n  ): Promise<ResourceResponse<T>>;\n  static async get<T = unknown>(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: false,\n  ): Promise<ResourceResult<T>>;\n  static async get<T = unknown>(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: boolean,\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\n    return Resource.do(HttpMethods.Get, client, path, null, headers, params, envelope, throwError ?? false);\n  }\n\n  /**\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\n   *\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\n   */\n  static async delete<T = unknown>(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: true,\n  ): Promise<ResourceResponse<T>>;\n  static async delete<T = unknown>(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: false,\n  ): Promise<ResourceResult<T>>;\n  static async delete<T = unknown>(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: boolean,\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\n    return Resource.do(HttpMethods.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n\n  /**\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\n   *\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\n   */\n  static async post<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: true,\n  ): Promise<ResourceResponse<T>>;\n  static async post<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: false,\n  ): Promise<ResourceResult<T>>;\n  static async post<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: boolean,\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\n    return Resource.do(HttpMethods.Post, client, path, body, headers, params, envelope, throwError);\n  }\n\n  /**\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\n   *\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\n   */\n  static async patch<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: true,\n  ): Promise<ResourceResponse<T>>;\n  static async patch<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: false,\n  ): Promise<ResourceResult<T>>;\n  static async patch<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: boolean,\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\n    return Resource.do(HttpMethods.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n\n  /**\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\n   *\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\n   */\n  static async put<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: true,\n  ): Promise<ResourceResponse<T>>;\n  static async put<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: false,\n  ): Promise<ResourceResult<T>>;\n  static async put<T = unknown>(\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: boolean,\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\n    return Resource.do(HttpMethods.Put, client, path, body, headers, params, envelope, throwError);\n  }\n\n  static async do<T>(\n    method: HttpMethods,\n    client: BaseClient,\n    path: string,\n    body: RequestBody | null,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    throwError: boolean,\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\n    if (envelope) {\n      (params = params || {})['envelope'] = envelope;\n    }\n\n    const logger = client.logger;\n\n    async function doRequest(\n      this: any,\n      headers: Record<string, string>,\n      params: Record<string, any>,\n    ): Promise<ResourceResult<T>> {\n      if (logger.shouldLog(Logger.LOG_MICRO)) {\n        let decodedBody = body;\n        if (headers['content-type']?.indexOf('msgpack') > 0) {\n          try {\n            if (!client._MsgPack) {\n              Utils.throwMissingPluginError('MsgPack');\n            }\n            decodedBody = client._MsgPack.decode(body as Buffer);\n          } catch (decodeErr) {\n            Logger.logAction(\n              logger,\n              Logger.LOG_MICRO,\n              'Resource.' + method + '()',\n              'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr),\n            );\n          }\n        }\n        Logger.logAction(\n          logger,\n          Logger.LOG_MICRO,\n          'Resource.' + method + '()',\n          'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody,\n        );\n      }\n\n      const httpResult = await client.http.do(method, path, headers, body, params);\n\n      if (httpResult.error && Auth.isTokenErr(httpResult.error as ErrorInfo)) {\n        /* token has expired, so get a new one */\n        await client.auth.authorize(null, null);\n        /* retry ... */\n        return withAuthDetails(client, headers, params, doRequest);\n      }\n\n      return {\n        err: httpResult.error as ErrorInfo,\n        body: httpResult.body as T | undefined,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode,\n      };\n    }\n\n    let result = await withAuthDetails<T>(client, headers, params, doRequest);\n\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n\n    if (logger.shouldLog(Logger.LOG_MICRO)) {\n      logResult(result, method, path, params, logger);\n    }\n\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response: Omit<ResourceResult<T>, 'err'> & Pick<Partial<ResourceResult<T>>, 'err'> = { ...result };\n        delete response.err;\n        return response;\n      }\n    }\n\n    return result;\n  }\n}\n\nexport default Resource;\n", "import * as Utils from '../util/utils';\nimport Logger from '../util/logger';\nimport Resource, { ResourceResult } from './resource';\nimport { IPartialErrorInfo } from '../types/errorinfo';\nimport BaseClient from './baseclient';\nimport { RequestBody, ResponseHeaders } from 'common/types/http';\nimport HttpStatusCodes from '../../constants/HttpStatusCodes';\n\nexport type BodyHandler = (body: unknown, headers: ResponseHeaders, unpacked?: boolean) => Promise<any>;\n\nfunction getRelParams(linkUrl: string) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);\n}\n\nfunction parseRelLinks(linkHeader: string | Array<string>) {\n  if (typeof linkHeader == 'string') linkHeader = linkHeader.split(',');\n\n  const relParams: Record<string, Record<string, string>> = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params) relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\n\nfunction returnErrOnly(err: IPartialErrorInfo, body: unknown, useHPR?: boolean) {\n  /* If using httpPaginatedResponse, errors from Ably are returned as part of\n   * the HPR, only throw `err` for network errors etc. which don't\n   * return a body and/or have no ably-originated error code (non-numeric\n   * error codes originate from node) */\n  return !(useHPR && (body || typeof err.code === 'number'));\n}\n\nclass PaginatedResource {\n  client: BaseClient;\n  path: string;\n  headers: Record<string, string>;\n  envelope: Utils.Format | null;\n  bodyHandler: BodyHandler;\n  useHttpPaginatedResponse: boolean;\n\n  constructor(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    envelope: Utils.Format | undefined,\n    bodyHandler: BodyHandler,\n    useHttpPaginatedResponse?: boolean,\n  ) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope ?? null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n\n  get logger(): Logger {\n    return this.client.logger;\n  }\n\n  async get<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\n    const result = await Resource.get<T1>(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n\n  async delete<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\n    const result = await Resource.delete<T1>(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n\n  async post<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\n    const result = await Resource.post<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n\n  async put<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\n    const result = await Resource.put<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n\n  async patch<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\n    const result = await Resource.patch<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n\n  async handlePage<T>(result: ResourceResult<T>): Promise<PaginatedResult<T>> {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_ERROR,\n        'PaginatedResource.handlePage()',\n        'Unexpected error getting resource: err = ' + Utils.inspectError(result.err),\n      );\n      throw result.err;\n    }\n\n    let items, linkHeader, relParams;\n\n    try {\n      items =\n        result.statusCode == HttpStatusCodes.NoContent\n          ? []\n          : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      /* If we got an error, the failure to parse the body is almost certainly\n       * due to that, so throw that in preference over the parse error */\n      throw result.err || e;\n    }\n\n    if (result.headers && (linkHeader = result.headers['Link'] || result.headers['link'])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode as number,\n        relParams,\n        result.err,\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n}\n\nexport class PaginatedResult<T> {\n  resource: PaginatedResource;\n  items: T[];\n  first?: () => Promise<PaginatedResult<T>>;\n  next?: () => Promise<PaginatedResult<T> | null>;\n  current?: () => Promise<PaginatedResult<T>>;\n  hasNext?: () => boolean;\n  isLast?: () => boolean;\n\n  constructor(resource: PaginatedResource, items: T[], relParams?: Record<string, any>) {\n    this.resource = resource;\n    this.items = items;\n\n    const self = this;\n    if (relParams) {\n      if ('first' in relParams) {\n        this.first = async function () {\n          return self.get(relParams.first);\n        };\n      }\n      if ('current' in relParams) {\n        this.current = async function () {\n          return self.get(relParams.current);\n        };\n      }\n      this.next = async function () {\n        if ('next' in relParams) {\n          return self.get(relParams.next);\n        } else {\n          return null;\n        }\n      };\n\n      this.hasNext = function () {\n        return 'next' in relParams;\n      };\n      this.isLast = () => {\n        return !this.hasNext?.();\n      };\n    }\n  }\n\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params: any): Promise<PaginatedResult<T>> {\n    const res = this.resource;\n    const result = await Resource.get<T>(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n}\n\nexport class HttpPaginatedResponse<T> extends PaginatedResult<T> {\n  statusCode: number;\n  success: boolean;\n  headers: ResponseHeaders;\n  errorCode?: number | null;\n  errorMessage?: string | null;\n\n  constructor(\n    resource: PaginatedResource,\n    items: T[],\n    headers: ResponseHeaders,\n    statusCode: number,\n    relParams: any,\n    err: IPartialErrorInfo | null,\n  ) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage,\n    };\n  }\n}\n\nexport default PaginatedResource;\n", "import { MsgPack } from 'common/types/msgpack';\nimport * as Utils from '../util/utils';\n\ntype PushChannelSubscriptionObject = {\n  channel?: string;\n  deviceId?: string;\n  clientId?: string;\n};\n\nclass PushChannelSubscription {\n  channel?: string;\n  deviceId?: string;\n  clientId?: string;\n\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON(): PushChannelSubscriptionObject {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId,\n    };\n  }\n\n  toString(): string {\n    let result = '[PushChannelSubscription';\n    if (this.channel) result += '; channel=' + this.channel;\n    if (this.deviceId) result += '; deviceId=' + this.deviceId;\n    if (this.clientId) result += '; clientId=' + this.clientId;\n    result += ']';\n    return result;\n  }\n\n  static toRequestBody = Utils.encodeBody;\n\n  static fromResponseBody(\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\n    MsgPack: MsgPack | null,\n    format?: Utils.Format,\n  ): PushChannelSubscription | PushChannelSubscription[] {\n    if (format) {\n      body = Utils.decodeBody(body, MsgPack, format) as Record<string, unknown>;\n    }\n\n    if (Array.isArray(body)) {\n      return PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return PushChannelSubscription.fromValues(body);\n    }\n  }\n\n  static fromValues(values: Record<string, unknown>): PushChannelSubscription {\n    return Object.assign(new PushChannelSubscription(), values);\n  }\n\n  static fromValuesArray(values: Array<Record<string, unknown>>): PushChannelSubscription[] {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n}\n\nexport default PushChannelSubscription;\n", "import * as Utils from '../util/utils';\nimport DeviceDetails from '../types/devicedetails';\nimport Resource from './resource';\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\nimport ErrorInfo from '../types/errorinfo';\nimport PushChannelSubscription from '../types/pushchannelsubscription';\nimport BaseClient from './baseclient';\nimport Defaults from '../util/defaults';\nimport type {\n  ActivationStateMachine,\n  DeregisterCallback,\n  LocalDeviceFactory,\n  RegisterCallback,\n} from 'plugins/push/pushactivation';\nimport Platform from 'common/platform';\nimport type { ErrCallback } from 'common/types/utils';\n\nclass Push {\n  client: BaseClient;\n  admin: Admin;\n  stateMachine?: ActivationStateMachine;\n  LocalDevice?: LocalDeviceFactory;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && client.options.plugins?.Push) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(DeviceDetails);\n    }\n  }\n\n  async activate(registerCallback?: RegisterCallback, updateFailedCallback?: ErrCallback) {\n    await new Promise<void>((resolve, reject) => {\n      if (!this.client.options.plugins?.Push) {\n        reject(Utils.createMissingPluginError('Push'));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo('This platform is not supported as a target of push notifications', 40000, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo('Activation already in progress', 40000, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err: ErrorInfo) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback),\n      );\n    });\n  }\n\n  async deactivate(deregisterCallback: DeregisterCallback) {\n    await new Promise<void>((resolve, reject) => {\n      if (!this.client.options.plugins?.Push) {\n        reject(Utils.createMissingPluginError('Push'));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo('This platform is not supported as a target of push notifications', 40000, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo('Deactivation already in progress', 40000, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err: ErrorInfo) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback),\n      );\n    });\n  }\n}\n\nclass Admin {\n  client: BaseClient;\n  deviceRegistrations: DeviceRegistrations;\n  channelSubscriptions: ChannelSubscriptions;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n\n  async publish(recipient: any, payload: any): Promise<void> {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\n      params = {};\n    const body = Utils.mixin({ recipient: recipient }, payload);\n\n    Utils.mixin(headers, client.options.headers);\n\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\n    await Resource.post(client, '/push/publish', requestBody, headers, params, null, true);\n  }\n}\n\nclass DeviceRegistrations {\n  client: BaseClient;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n  }\n\n  async save(device: any): Promise<DeviceDetails> {\n    const client = this.client;\n    const body = DeviceDetails.fromValues(device);\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\n      params = {};\n\n    Utils.mixin(headers, client.options.headers);\n\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\n    const response = await Resource.put(\n      client,\n      '/push/deviceRegistrations/' + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true,\n    );\n\n    return DeviceDetails.fromResponseBody(\n      response.body as Record<string, unknown>,\n      client._MsgPack,\n      response.unpacked ? undefined : format,\n    ) as DeviceDetails;\n  }\n\n  async get(deviceIdOrDetails: any): Promise<DeviceDetails> {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n\n    if (typeof deviceId !== 'string' || !deviceId.length) {\n      throw new ErrorInfo(\n        'First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails',\n        40000,\n        400,\n      );\n    }\n\n    Utils.mixin(headers, client.options.headers);\n\n    const response = await Resource.get(\n      client,\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true,\n    );\n\n    return DeviceDetails.fromResponseBody(\n      response.body as Record<string, unknown>,\n      client._MsgPack,\n      response.unpacked ? undefined : format,\n    ) as DeviceDetails;\n  }\n\n  async list(params: any): Promise<PaginatedResult<unknown>> {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    return new PaginatedResource(client, '/push/deviceRegistrations', headers, envelope, async function (\n      body,\n      headers,\n      unpacked,\n    ) {\n      return DeviceDetails.fromResponseBody(\n        body as Record<string, unknown>[],\n        client._MsgPack,\n        unpacked ? undefined : format,\n      );\n    }).get(params);\n  }\n\n  async remove(deviceIdOrDetails: any): Promise<void> {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\n      params = {},\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n\n    if (typeof deviceId !== 'string' || !deviceId.length) {\n      throw new ErrorInfo(\n        'First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails',\n        40000,\n        400,\n      );\n    }\n\n    Utils.mixin(headers, client.options.headers);\n\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    await Resource['delete'](\n      client,\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true,\n    );\n  }\n\n  async removeWhere(params: any): Promise<void> {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    await Resource['delete'](client, '/push/deviceRegistrations', headers, params, null, true);\n  }\n}\n\nclass ChannelSubscriptions {\n  client: BaseClient;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n  }\n\n  async save(subscription: Record<string, unknown>): Promise<PushChannelSubscription> {\n    const client = this.client;\n    const body = PushChannelSubscription.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\n      params = {};\n\n    Utils.mixin(headers, client.options.headers);\n\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\n    const response = await Resource.post(\n      client,\n      '/push/channelSubscriptions',\n      requestBody,\n      headers,\n      params,\n      null,\n      true,\n    );\n\n    return PushChannelSubscription.fromResponseBody(\n      response.body as Record<string, any>,\n      client._MsgPack,\n      response.unpacked ? undefined : format,\n    ) as PushChannelSubscription;\n  }\n\n  async list(params: any): Promise<PaginatedResult<unknown>> {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    return new PaginatedResource(client, '/push/channelSubscriptions', headers, envelope, async function (\n      body,\n      headers,\n      unpacked,\n    ) {\n      return PushChannelSubscription.fromResponseBody(\n        body as Record<string, unknown>[],\n        client._MsgPack,\n        unpacked ? undefined : format,\n      );\n    }).get(params);\n  }\n\n  async removeWhere(params: any): Promise<void> {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    await Resource['delete'](client, '/push/channelSubscriptions', headers, params, null, true);\n  }\n\n  /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n  remove = ChannelSubscriptions.prototype.removeWhere;\n\n  async listChannels(params: any): Promise<PaginatedResult<unknown>> {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    return new PaginatedResource(client, '/push/channels', headers, envelope, async function (body, headers, unpacked) {\n      const parsedBody = (\n        !unpacked && format ? Utils.decodeBody(body, client._MsgPack, format) : body\n      ) as Array<string>;\n\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n}\n\nexport default Push;\n", "// constant definitions that can be imported by anyone without worrying about circular\n// deps\n\nexport const actions = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18,\n};\n\nexport const ActionName: string[] = [];\nObject.keys(actions).forEach(function (name) {\n  ActionName[(actions as { [key: string]: number })[name]] = name;\n});\n\nexport const flags: { [key: string]: number } = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19,\n};\n\nexport const flagNames = Object.keys(flags);\n\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\n\nexport const channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];\n", "import Platform from 'common/platform';\nimport Logger from '../util/logger';\nimport ErrorInfo from './errorinfo';\nimport * as Utils from '../util/utils';\nimport { Bufferlike as BrowserBufferlike } from '../../../platform/web/lib/util/bufferutils';\nimport * as API from '../../../../ably';\nimport { actions } from './protocolmessagecommon';\n\nimport type { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\nimport type { ChannelOptions } from '../../types/channel';\nimport type ProtocolMessage from './protocolmessage';\n\nexport type CipherOptions = {\n  channelCipher: {\n    encrypt: Function;\n    algorithm: 'aes';\n  };\n  cipher?: {\n    channelCipher: {\n      encrypt: Function;\n      algorithm: 'aes';\n    };\n  };\n};\n\nexport type EncodingDecodingContext = {\n  channelOptions: ChannelOptions;\n  plugins: {\n    vcdiff?: {\n      decode: (delta: Uint8Array, source: Uint8Array) => Uint8Array;\n    };\n  };\n  baseEncodedPreviousPayload?: Buffer | BrowserBufferlike;\n};\n\nfunction normaliseContext(context: CipherOptions | EncodingDecodingContext | ChannelOptions): EncodingDecodingContext {\n  if (!context || !(context as EncodingDecodingContext).channelOptions) {\n    return {\n      channelOptions: context as ChannelOptions,\n      plugins: {},\n      baseEncodedPreviousPayload: undefined,\n    };\n  }\n  return context as EncodingDecodingContext;\n}\n\nexport function normalizeCipherOptions(\n  Crypto: IUntypedCryptoStatic | null,\n  logger: Logger,\n  options: API.ChannelOptions | null,\n): ChannelOptions {\n  if (options && options.cipher) {\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\n    const cipher = Crypto.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher,\n    };\n  }\n  return options ?? {};\n}\n\nasync function encrypt<T extends BaseMessage>(msg: T, options: CipherOptions): Promise<T> {\n  let data = msg.data,\n    encoding = msg.encoding,\n    cipher = options.channelCipher;\n\n  encoding = encoding ? encoding + '/' : '';\n  if (!Platform.BufferUtils.isBuffer(data)) {\n    data = Platform.BufferUtils.utf8Encode(String(data));\n    encoding = encoding + 'utf-8/';\n  }\n  const ciphertext = await cipher.encrypt(data);\n  msg.data = ciphertext;\n  msg.encoding = encoding + 'cipher+' + cipher.algorithm;\n  return msg;\n}\n\nexport async function encode<T extends BaseMessage>(msg: T, options: CipherOptions): Promise<T> {\n  const data = msg.data;\n  const nativeDataType =\n    typeof data == 'string' || Platform.BufferUtils.isBuffer(data) || data === null || data === undefined;\n\n  if (!nativeDataType) {\n    if (Utils.isObject(data) || Array.isArray(data)) {\n      msg.data = JSON.stringify(data);\n      msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';\n    } else {\n      throw new ErrorInfo('Data type is unsupported', 40013, 400);\n    }\n  }\n\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\n\nexport async function decode<T extends BaseMessage>(\n  message: T,\n  inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\n): Promise<void> {\n  const context = normaliseContext(inputContext);\n\n  let lastPayload = message.data;\n  const encoding = message.encoding;\n  if (encoding) {\n    const xforms = encoding.split('/');\n    let lastProcessedEncodingIndex,\n      encodingsToProcess = xforms.length,\n      data = message.data;\n\n    let xform = '';\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        // eslint-disable-next-line security/detect-unsafe-regex\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match) break;\n        xform = match[1];\n        switch (xform) {\n          case 'base64':\n            data = Platform.BufferUtils.base64Decode(String(data));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = data;\n            }\n            continue;\n          case 'utf-8':\n            data = Platform.BufferUtils.utf8Decode(data);\n            continue;\n          case 'json':\n            data = JSON.parse(data);\n            continue;\n          case 'cipher':\n            if (\n              context.channelOptions != null &&\n              context.channelOptions.cipher &&\n              context.channelOptions.channelCipher\n            ) {\n              const xformAlgorithm = match[3],\n                cipher = context.channelOptions.channelCipher;\n              /* don't attempt to decrypt unless the cipher params are compatible */\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');\n              }\n              data = await cipher.decrypt(data);\n              continue;\n            } else {\n              throw new Error('Unable to decrypt message; not an encrypted channel');\n            }\n          case 'vcdiff':\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);\n            }\n            if (typeof Uint8Array === 'undefined') {\n              throw new ErrorInfo(\n                'Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)',\n                40020,\n                400,\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === 'string') {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n\n              // vcdiff expects Uint8Arrays, can't copy with ArrayBuffers.\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase as Buffer);\n              data = Platform.BufferUtils.toBuffer(data);\n\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\n              lastPayload = data;\n            } catch (e) {\n              throw new ErrorInfo('Vcdiff delta decode failed with ' + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error('Unknown encoding');\n        }\n      }\n    } catch (e) {\n      const err = e as ErrorInfo;\n      throw new ErrorInfo(\n        'Error processing the ' + xform + ' encoding, decoder returned \u2018' + err.message + '\u2019',\n        err.code || 40013,\n        400,\n      );\n    } finally {\n      message.encoding =\n        (lastProcessedEncodingIndex as number) <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');\n      message.data = data;\n    }\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n}\n\nexport function wireToJSON(this: BaseMessage, ...args: any[]): any {\n  /* encode data to base64 if present and we're returning real JSON;\n   * although msgpack calls toJSON(), we know it is a stringify()\n   * call if it has a non-empty arguments list */\n  let encoding = this.encoding;\n  let data = this.data;\n  if (data && Platform.BufferUtils.isBuffer(data)) {\n    if (args.length > 0) {\n      /* stringify call */\n      encoding = encoding ? encoding + '/base64' : 'base64';\n      data = Platform.BufferUtils.base64Encode(data);\n    } else {\n      /* Called by msgpack. toBuffer returns a datatype understandable by\n       * that platform's msgpack implementation (Buffer in node, Uint8Array\n       * in browsers) */\n      data = Platform.BufferUtils.toBuffer(data);\n    }\n  }\n  return Object.assign({}, this, { encoding, data });\n}\n\n// in-place, generally called on the protocol message before decoding\nexport function populateFieldsFromParent(parent: ProtocolMessage) {\n  let msgs: BaseMessage[];\n  switch (parent.action) {\n    case actions.MESSAGE:\n      msgs = parent.messages!;\n      break;\n    case actions.PRESENCE:\n    case actions.SYNC:\n      msgs = parent.presence!;\n      break;\n    default:\n      throw new ErrorInfo('Unexpected action ' + parent.action, 40000, 400);\n  }\n\n  const { id, connectionId, timestamp } = parent;\n  for (let i = 0; i < msgs.length; i++) {\n    const msg = msgs[i];\n    if (!msg.connectionId) msg.connectionId = connectionId;\n    if (!msg.timestamp) msg.timestamp = timestamp;\n    if (id && !msg.id) msg.id = id + ':' + i;\n  }\n}\n\nexport function strMsg(m: any, cls: string) {\n  let result = '[' + cls;\n  for (const attr in m) {\n    if (attr === 'data') {\n      if (typeof m.data == 'string') {\n        result += '; data=' + m.data;\n      } else if (Platform.BufferUtils.isBuffer(m.data)) {\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(m.data);\n      } else {\n        result += '; data (json)=' + JSON.stringify(m.data);\n      }\n    } else if (attr && (attr === 'extras' || attr === 'operation')) {\n      result += '; ' + attr + '=' + JSON.stringify(m[attr]);\n    } else if (m[attr] !== undefined) {\n      result += '; ' + attr + '=' + m[attr];\n    }\n  }\n  result += ']';\n  return result;\n}\n\nexport abstract class BaseMessage {\n  id?: string;\n  timestamp?: number;\n  clientId?: string;\n  connectionId?: string;\n  data?: any;\n  encoding?: string | null;\n  extras?: any;\n  size?: number;\n}\n", "import Logger from '../util/logger';\nimport { BaseMessage, encode, decode, wireToJSON, normalizeCipherOptions, CipherOptions, strMsg } from './basemessage';\nimport * as API from '../../../../ably';\nimport * as Utils from '../util/utils';\n\nimport type { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\nimport type { Properties } from '../util/utils';\nimport type RestChannel from '../client/restchannel';\nimport type RealtimeChannel from '../client/realtimechannel';\nimport type { ChannelOptions } from '../../types/channel';\ntype Channel = RestChannel | RealtimeChannel;\n\nconst actions = ['absent', 'present', 'enter', 'leave', 'update'];\n\nexport async function fromEncoded(\n  logger: Logger,\n  Crypto: IUntypedCryptoStatic | null,\n  encoded: WirePresenceMessage,\n  inputOptions?: API.ChannelOptions,\n): Promise<PresenceMessage> {\n  const options = normalizeCipherOptions(Crypto, logger, inputOptions ?? null);\n  const wpm = WirePresenceMessage.fromValues(encoded);\n  return wpm.decode(options, logger);\n}\n\nexport async function fromEncodedArray(\n  logger: Logger,\n  Crypto: IUntypedCryptoStatic | null,\n  encodedArray: WirePresenceMessage[],\n  options?: API.ChannelOptions,\n): Promise<PresenceMessage[]> {\n  return Promise.all(\n    encodedArray.map(function (encoded) {\n      return fromEncoded(logger, Crypto, encoded, options);\n    }),\n  );\n}\n\n// these forms of the functions are used internally when we have a channel instance\n// already, so don't need to normalise channel options\nexport async function _fromEncoded(\n  encoded: Properties<WirePresenceMessage>,\n  channel: Channel,\n): Promise<PresenceMessage> {\n  return WirePresenceMessage.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\n\nexport async function _fromEncodedArray(\n  encodedArray: Properties<WirePresenceMessage>[],\n  channel: Channel,\n): Promise<PresenceMessage[]> {\n  return Promise.all(\n    encodedArray.map(function (encoded) {\n      return _fromEncoded(encoded, channel);\n    }),\n  );\n}\n\nclass PresenceMessage extends BaseMessage {\n  action?: string;\n\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized(): boolean {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n\n  /* RTP2b2 */\n  parseId(): { connectionId: string; msgSerial: number; index: number } {\n    if (!this.id) throw new Error('parseId(): Presence message does not contain an id');\n    const parts = this.id.split(':');\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10),\n    };\n  }\n\n  async encode(options: CipherOptions): Promise<WirePresenceMessage> {\n    const res = Object.assign(new WirePresenceMessage(), this, {\n      action: actions.indexOf(this.action || 'present'),\n    });\n    return encode(res, options);\n  }\n\n  static fromValues(values: Properties<PresenceMessage>): PresenceMessage {\n    return Object.assign(new PresenceMessage(), values);\n  }\n\n  static fromValuesArray(values: Properties<PresenceMessage>[]): PresenceMessage[] {\n    return values.map(PresenceMessage.fromValues);\n  }\n\n  static fromData(data: any): PresenceMessage {\n    if (data instanceof PresenceMessage) {\n      return data;\n    }\n    return PresenceMessage.fromValues({\n      data,\n    });\n  }\n\n  toString() {\n    return strMsg(this, 'PresenceMessage');\n  }\n}\n\nexport class WirePresenceMessage extends BaseMessage {\n  action?: number;\n\n  toJSON(...args: any[]) {\n    return wireToJSON.call(this, ...args);\n  }\n\n  static fromValues(values: Properties<WirePresenceMessage>): WirePresenceMessage {\n    return Object.assign(new WirePresenceMessage(), values);\n  }\n\n  static fromValuesArray(values: Properties<WirePresenceMessage>[]): WirePresenceMessage[] {\n    return values.map(WirePresenceMessage.fromValues);\n  }\n\n  async decode(channelOptions: ChannelOptions, logger: Logger): Promise<PresenceMessage> {\n    const res = Object.assign(new PresenceMessage(), {\n      ...this,\n      action: actions[this.action!],\n    });\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      Logger.logAction(logger, Logger.LOG_ERROR, 'WirePresenceMessage.decode()', Utils.inspectError(e));\n    }\n    return res;\n  }\n\n  toString() {\n    return strMsg(this, 'WirePresenceMessage');\n  }\n}\n\nexport default PresenceMessage;\n", "import * as Utils from '../util/utils';\nimport Logger from '../util/logger';\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\nimport PresenceMessage, { WirePresenceMessage, _fromEncodedArray } from '../types/presencemessage';\nimport RestChannel from './restchannel';\nimport Defaults from '../util/defaults';\n\nclass RestPresence {\n  channel: RestChannel;\n\n  constructor(channel: RestChannel) {\n    this.channel = channel;\n  }\n\n  get logger(): Logger {\n    return this.channel.logger;\n  }\n\n  async get(params: any): Promise<PaginatedResult<PresenceMessage>> {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestPresence.get()', 'channel = ' + this.channel.name);\n    const client = this.channel.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.channel.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    return new PaginatedResource(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers, unpacked) => {\n        const decoded = (\n          unpacked ? body : Utils.decodeBody(body, client._MsgPack, format)\n        ) as Utils.Properties<WirePresenceMessage>[];\n\n        return _fromEncodedArray(decoded, this.channel);\n      },\n    ).get(params);\n  }\n\n  async history(params: any): Promise<PaginatedResult<PresenceMessage>> {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestPresence.history()', 'channel = ' + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n}\n\nexport default RestPresence;\n", "import Logger from '../util/logger';\nimport {\n  BaseMessage,\n  encode,\n  decode,\n  wireToJSON,\n  normalizeCipherOptions,\n  EncodingDecodingContext,\n  CipherOptions,\n  strMsg,\n} from './basemessage';\nimport * as Utils from '../util/utils';\nimport * as API from '../../../../ably';\n\nimport type { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\nimport type { ChannelOptions } from '../../types/channel';\nimport type { Properties } from '../util/utils';\nimport type RestChannel from '../client/restchannel';\nimport type RealtimeChannel from '../client/realtimechannel';\nimport type ErrorInfo from './errorinfo';\ntype Channel = RestChannel | RealtimeChannel;\n\nconst actions: API.MessageAction[] = [\n  'message.create',\n  'message.update',\n  'message.delete',\n  'meta.occupancy',\n  'message.summary',\n];\n\nfunction stringifyAction(action: number | undefined): string {\n  return actions[action || 0] || 'unknown';\n}\n\nfunction getMessageSize(msg: WireMessage) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += Utils.dataSizeBytes(msg.data);\n  }\n  return size;\n}\n\nexport async function fromEncoded(\n  logger: Logger,\n  Crypto: IUntypedCryptoStatic | null,\n  encoded: Properties<WireMessage>,\n  inputOptions?: API.ChannelOptions,\n): Promise<Message> {\n  const options = normalizeCipherOptions(Crypto, logger, inputOptions ?? null);\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(options, logger);\n}\n\nexport async function fromEncodedArray(\n  logger: Logger,\n  Crypto: IUntypedCryptoStatic | null,\n  encodedArray: Array<WireMessage>,\n  options?: API.ChannelOptions,\n): Promise<Message[]> {\n  return Promise.all(\n    encodedArray.map(function (encoded) {\n      return fromEncoded(logger, Crypto, encoded, options);\n    }),\n  );\n}\n\n// these forms of the functions are used internally when we have a channel instance\n// already, so don't need to normalise channel options\nexport async function _fromEncoded(encoded: Properties<WireMessage>, channel: Channel): Promise<Message> {\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(channel.channelOptions, channel.logger);\n}\n\nexport async function _fromEncodedArray(encodedArray: Properties<WireMessage>[], channel: Channel): Promise<Message[]> {\n  return Promise.all(\n    encodedArray.map(function (encoded) {\n      return _fromEncoded(encoded, channel);\n    }),\n  );\n}\n\nexport async function encodeArray(messages: Array<Message>, options: CipherOptions): Promise<Array<WireMessage>> {\n  return Promise.all(messages.map((message) => message.encode(options)));\n}\n\nexport const serialize = Utils.encodeBody;\n\n/* This should be called on encode()d (and encrypt()d) Messages (as it\n * assumes the data is a string or buffer) */\nexport function getMessagesSize(messages: WireMessage[]): number {\n  let msg,\n    total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\n\nclass Message extends BaseMessage {\n  name?: string;\n  connectionKey?: string;\n  action?: API.MessageAction;\n  serial?: string;\n  refSerial?: string;\n  refType?: string;\n  createdAt?: number;\n  version?: string;\n  operation?: API.Operation;\n\n  expandFields() {\n    if (this.action === 'message.create') {\n      // TM2k\n      if (this.version && !this.serial) {\n        this.serial = this.version;\n      }\n      // TM2o\n      if (this.timestamp && !this.createdAt) {\n        this.createdAt = this.timestamp;\n      }\n    }\n  }\n\n  async encode(options: CipherOptions): Promise<WireMessage> {\n    const res = Object.assign(new WireMessage(), this, {\n      action: actions.indexOf(this.action || 'message.create'),\n    });\n    return encode(res, options);\n  }\n\n  static fromValues(values: Properties<Message>): Message {\n    return Object.assign(new Message(), values);\n  }\n\n  static fromValuesArray(values: Properties<Message>[]): Message[] {\n    return values.map(Message.fromValues);\n  }\n\n  toString() {\n    return strMsg(this, 'Message');\n  }\n}\n\nexport class WireMessage extends BaseMessage {\n  name?: string;\n  connectionKey?: string;\n  action?: number;\n  serial?: string;\n  refSerial?: string;\n  refType?: string;\n  createdAt?: number;\n  version?: string;\n  operation?: API.Operation;\n\n  // Overload toJSON() to intercept JSON.stringify()\n  toJSON(...args: any[]) {\n    return wireToJSON.call(this, ...args);\n  }\n\n  static fromValues(values: Properties<WireMessage>): WireMessage {\n    return Object.assign(new WireMessage(), values);\n  }\n\n  static fromValuesArray(values: Properties<WireMessage>[]): WireMessage[] {\n    return values.map(WireMessage.fromValues);\n  }\n\n  // for contexts where some decoding errors need to be handled specially by the caller\n  async decodeWithErr(\n    inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\n    logger: Logger,\n  ): Promise<{ decoded: Message; err: ErrorInfo | undefined }> {\n    const res: Message = Object.assign(new Message(), {\n      ...this,\n      action: stringifyAction(this.action),\n    });\n    let err: ErrorInfo | undefined;\n    try {\n      await decode(res, inputContext);\n    } catch (e) {\n      Logger.logAction(logger, Logger.LOG_ERROR, 'WireMessage.decode()', Utils.inspectError(e));\n      err = e as ErrorInfo;\n    }\n    res.expandFields();\n    return { decoded: res, err: err };\n  }\n\n  async decode(\n    inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\n    logger: Logger,\n  ): Promise<Message> {\n    const { decoded } = await this.decodeWithErr(inputContext, logger);\n    return decoded;\n  }\n\n  toString() {\n    return strMsg(this, 'WireMessage');\n  }\n}\n\nexport default Message;\n", "import * as Utils from '../util/utils';\nimport Logger from '../util/logger';\nimport RestPresence from './restpresence';\nimport Message, {\n  serialize as serializeMessage,\n  getMessagesSize,\n  encodeArray as encodeMessagesArray,\n} from '../types/message';\nimport { CipherOptions } from '../types/basemessage';\nimport ErrorInfo from '../types/errorinfo';\nimport { PaginatedResult } from './paginatedresource';\nimport Resource from './resource';\nimport { ChannelOptions } from '../../types/channel';\nimport BaseRest from './baseclient';\nimport * as API from '../../../../ably';\nimport Defaults, { normaliseChannelOptions } from '../util/defaults';\nimport { RestHistoryParams } from './restchannelmixin';\nimport { RequestBody } from 'common/types/http';\nimport type { PushChannel } from 'plugins/push';\n\nconst MSG_ID_ENTROPY_BYTES = 9;\n\nfunction allEmptyIds(messages: Array<Message>) {\n  return messages.every(function (message: Message) {\n    return !message.id;\n  });\n}\n\nclass RestChannel {\n  client: BaseRest;\n  name: string;\n  presence: RestPresence;\n  channelOptions: ChannelOptions;\n  _push?: PushChannel;\n\n  constructor(client: BaseRest, name: string, channelOptions?: ChannelOptions) {\n    Logger.logAction(client.logger, Logger.LOG_MINOR, 'RestChannel()', 'started; name = ' + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new RestPresence(this);\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, this.logger, channelOptions);\n    if (client.options.plugins?.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n  }\n\n  get push() {\n    if (!this._push) {\n      Utils.throwMissingPluginError('Push');\n    }\n    return this._push;\n  }\n\n  get logger(): Logger {\n    return this.client.logger;\n  }\n\n  setOptions(options?: ChannelOptions): void {\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, this.logger, options);\n  }\n\n  async history(params: RestHistoryParams | null): Promise<PaginatedResult<Message>> {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestChannel.history()', 'channel = ' + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n\n  async publish(...args: any[]): Promise<void> {\n    const first = args[0],\n      second = args[1];\n    let messages: Array<Message>;\n    let params: any;\n\n    if (typeof first === 'string' || first === null) {\n      /* (name, data, ...) */\n      messages = [Message.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (Utils.isObject(first)) {\n      messages = [Message.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = Message.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        'The single-argument form of publish() expects a message object or an array of message objects',\n        40013,\n        400,\n      );\n    }\n\n    if (!params) {\n      /* No params supplied */\n      params = {};\n    }\n\n    const client = this.client,\n      options = client.options,\n      format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      idempotentRestPublishing = client.options.idempotentRestPublishing,\n      headers = Defaults.defaultPostHeaders(client.options, { format });\n\n    Utils.mixin(headers, options.headers);\n\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await Utils.randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function (message, index) {\n        message.id = msgIdBase + ':' + index.toString();\n      });\n    }\n\n    const wireMessages = await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\n\n    /* RSL1i */\n    const size = getMessagesSize(wireMessages),\n      maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        'Maximum size of messages that can be published at once exceeded ( was ' +\n          size +\n          ' bytes; limit is ' +\n          maxMessageSize +\n          ' bytes)',\n        40009,\n        400,\n      );\n    }\n\n    await this._publish(serializeMessage(wireMessages, client._MsgPack, format), headers, params);\n  }\n\n  async _publish(requestBody: RequestBody | null, headers: Record<string, string>, params: any): Promise<void> {\n    await Resource.post(\n      this.client,\n      this.client.rest.channelMixin.basePath(this) + '/messages',\n      requestBody,\n      headers,\n      params,\n      null,\n      true,\n    );\n  }\n\n  async status(): Promise<API.ChannelDetails> {\n    return this.client.rest.channelMixin.status(this);\n  }\n}\n\nexport default RestChannel;\n", "type StatsValues = {\n  entries?: Partial<Record<string, number>>;\n  schema?: string;\n  appId?: string;\n  inProgress?: never;\n  unit?: never;\n  intervalId?: never;\n};\n\nclass Stats {\n  entries?: Partial<Record<string, number>>;\n  schema?: string;\n  appId?: string;\n  inProgress?: never;\n  unit?: never;\n  intervalId?: never;\n\n  constructor(values?: StatsValues) {\n    this.entries = (values && values.entries) || undefined;\n    this.schema = (values && values.schema) || undefined;\n    this.appId = (values && values.appId) || undefined;\n    this.inProgress = (values && values.inProgress) || undefined;\n    this.unit = (values && values.unit) || undefined;\n    this.intervalId = (values && values.intervalId) || undefined;\n  }\n\n  static fromValues(values: StatsValues): Stats {\n    return new Stats(values);\n  }\n}\n\nexport default Stats;\n", "import * as API from '../../../../ably';\nimport RestChannel from './restchannel';\nimport RealtimeChannel from './realtimechannel';\nimport * as Utils from '../util/utils';\nimport Message, { WireMessage, _fromEncodedArray } from '../types/message';\nimport Defaults from '../util/defaults';\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\nimport Resource from './resource';\n\nexport interface RestHistoryParams {\n  start?: number;\n  end?: number;\n  direction?: string;\n  limit?: number;\n}\n\nexport class RestChannelMixin {\n  static basePath(channel: RestChannel | RealtimeChannel) {\n    return '/channels/' + encodeURIComponent(channel.name);\n  }\n\n  static history(\n    channel: RestChannel | RealtimeChannel,\n    params: RestHistoryParams | null,\n  ): Promise<PaginatedResult<Message>> {\n    const client = channel.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = channel.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    return new PaginatedResource(client, this.basePath(channel) + '/messages', headers, envelope, async function (\n      body,\n      headers,\n      unpacked,\n    ) {\n      const decoded = (\n        unpacked ? body : Utils.decodeBody(body, client._MsgPack, format)\n      ) as Utils.Properties<WireMessage>[];\n\n      return _fromEncodedArray(decoded, channel);\n    }).get(params as Record<string, unknown>);\n  }\n\n  static async status(channel: RestChannel | RealtimeChannel): Promise<API.ChannelDetails> {\n    const format = channel.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\n    const headers = Defaults.defaultPostHeaders(channel.client.options, { format });\n\n    const response = await Resource.get<API.ChannelDetails>(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true,\n    );\n\n    return response.body!;\n  }\n}\n", "import RestPresence from './restpresence';\nimport RealtimePresence from './realtimepresence';\nimport * as Utils from '../util/utils';\nimport Defaults from '../util/defaults';\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\nimport PresenceMessage, { WirePresenceMessage, _fromEncodedArray } from '../types/presencemessage';\nimport { RestChannelMixin } from './restchannelmixin';\n\nexport class RestPresenceMixin {\n  static basePath(presence: RestPresence | RealtimePresence) {\n    return RestChannelMixin.basePath(presence.channel) + '/presence';\n  }\n\n  static async history(\n    presence: RestPresence | RealtimePresence,\n    params: any,\n  ): Promise<PaginatedResult<PresenceMessage>> {\n    const client = presence.channel.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = presence.channel.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    return new PaginatedResource(\n      client,\n      this.basePath(presence) + '/history',\n      headers,\n      envelope,\n      async (body, headers, unpacked) => {\n        const decoded = (\n          unpacked ? body : Utils.decodeBody(body, client._MsgPack, format)\n        ) as Utils.Properties<WirePresenceMessage>[];\n\n        return _fromEncodedArray(decoded, presence.channel);\n      },\n    ).get(params);\n  }\n}\n", "import * as Utils from '../util/utils';\nimport Defaults from '../util/defaults';\nimport Push from './push';\nimport PaginatedResource, { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\nimport RestChannel from './restchannel';\nimport ErrorInfo from '../types/errorinfo';\nimport Stats from '../types/stats';\nimport HttpMethods from '../../constants/HttpMethods';\nimport { ChannelOptions } from '../../types/channel';\nimport { RequestBody, RequestParams } from '../../types/http';\nimport * as API from '../../../../ably';\nimport Resource from './resource';\n\nimport Platform from '../../platform';\nimport BaseClient from './baseclient';\nimport { useTokenAuth } from './auth';\nimport { RestChannelMixin } from './restchannelmixin';\nimport { RestPresenceMixin } from './restpresencemixin';\nimport DeviceDetails from '../types/devicedetails';\n\ntype BatchResult<T> = API.BatchResult<T>;\n\ntype BatchPublishSpec = API.BatchPublishSpec;\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\n\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\ntype TokenRevocationOptions = API.TokenRevocationOptions;\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\n\nexport class Rest {\n  private readonly client: BaseClient;\n  readonly channels: Channels;\n  readonly push: Push;\n\n  readonly channelMixin = RestChannelMixin;\n  readonly presenceMixin = RestPresenceMixin;\n\n  // exposed for plugins but shouldn't be bundled with minimal realtime\n  Resource = Resource;\n  DeviceDetails = DeviceDetails;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new Push(this.client);\n  }\n\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\n    const headers = Defaults.defaultGetHeaders(this.client.options),\n      format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format;\n\n    Utils.mixin(headers, this.client.options.headers);\n\n    return new PaginatedResource(this.client, '/stats', headers, envelope, function (body, headers, unpacked) {\n      const statsValues = unpacked ? body : JSON.parse(body as string);\n      for (let i = 0; i < statsValues.length; i++) statsValues[i] = Stats.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params as Record<string, string>);\n  }\n\n  async time(params?: RequestParams): Promise<number> {\n    const headers = Defaults.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\n    const timeUri = (host: string) => {\n      return this.client.baseUri(host) + '/time';\n    };\n\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods.Get,\n      timeUri,\n      headers,\n      null,\n      params as RequestParams,\n    );\n\n    if (error) {\n      throw error;\n    }\n    if (!unpacked) body = JSON.parse(body as string);\n    const time = (body as number[])[0];\n    if (!time) {\n      throw new ErrorInfo('Internal error (unexpected result type from GET /time)', 50000, 500);\n    }\n    /* calculate time offset only once for this device by adding to the prototype */\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n\n  async request(\n    method: string,\n    path: string,\n    version: number,\n    params: RequestParams,\n    body: unknown,\n    customHeaders: Record<string, string>,\n  ): Promise<HttpPaginatedResponse<unknown>> {\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          Utils.throwMissingPluginError('MsgPack');\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, Utils.Format.msgpack];\n      } else {\n        return [JSON.stringify, JSON.parse, Utils.Format.json];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? undefined : format;\n    params = params || {};\n    const _method = method.toLowerCase() as HttpMethods;\n    const headers =\n      _method == 'get'\n        ? Defaults.defaultGetHeaders(this.client.options, { format, protocolVersion: version })\n        : Defaults.defaultPostHeaders(this.client.options, { format, protocolVersion: version });\n\n    if (typeof body !== 'string') {\n      body = encoder(body) ?? null;\n    }\n    Utils.mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      Utils.mixin(headers, customHeaders);\n    }\n    const paginatedResource = new PaginatedResource(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function (resbody, headers, unpacked) {\n        return Utils.ensureArray(unpacked ? resbody : decoder(resbody as string & Buffer));\n      },\n      /* useHttpPaginatedResponse: */ true,\n    );\n\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo('Unsupported method ' + _method, 40500, 405);\n    }\n\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method as HttpMethods.Post](params, body as RequestBody) as Promise<\n        HttpPaginatedResponse<unknown>\n      >;\n    } else {\n      return paginatedResource[_method as HttpMethods.Get | HttpMethods.Delete](params) as Promise<\n        HttpPaginatedResponse<unknown>\n      >;\n    }\n  }\n\n  async batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\n    specOrSpecs: T,\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\n    let requestBodyDTO: BatchPublishSpec[];\n    let singleSpecMode: boolean;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\n\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\n\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\n\n    const response = await Resource.post(this.client, '/messages', requestBody, headers, {}, null, true);\n\n    const batchResults = (\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\n    ) as BatchPublishResult[];\n\n    // I don't love the below type assertions but not sure how to avoid them\n    if (singleSpecMode) {\n      return batchResults[0] as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\n    } else {\n      return batchResults as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\n    }\n  }\n\n  async batchPresence(channels: string[]): Promise<BatchPresenceResult> {\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\n\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\n\n    const channelsParam = channels.join(',');\n\n    const response = await Resource.get(this.client, '/presence', headers, { channels: channelsParam }, null, true);\n\n    return (\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\n    ) as BatchPresenceResult;\n  }\n\n  async revokeTokens(\n    specifiers: TokenRevocationTargetSpecifier[],\n    options?: TokenRevocationOptions,\n  ): Promise<TokenRevocationResult> {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo('Cannot revoke tokens when using token auth', 40162, 401);\n    }\n\n    const keyName = this.client.options.keyName!;\n\n    let resolvedOptions = options ?? {};\n\n    const requestBodyDTO = {\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`),\n      ...resolvedOptions,\n    };\n\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\n\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\n\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\n\n    const response = await Resource.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true,\n    );\n\n    return (\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\n    ) as TokenRevocationResult;\n  }\n}\n\nclass Channels {\n  client: BaseClient;\n  all: Record<string, RestChannel>;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n    this.all = Object.create(null);\n  }\n\n  get(name: string, channelOptions?: ChannelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new RestChannel(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n\n    return channel;\n  }\n\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name: string) {\n    delete this.all[String(name)];\n  }\n}\n", "import BaseClient from './baseclient';\nimport ClientOptions from '../../types/ClientOptions';\nimport { Rest } from './rest';\nimport Defaults from '../util/defaults';\nimport Logger from '../util/logger';\n\n/**\n `BaseRest` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRest` class exported by the non tree-shakable version.\n\n It always includes the `Rest` plugin.\n */\nexport class BaseRest extends BaseClient {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options?: ClientOptions | string) {\n    super(Defaults.objectifyOptions(options, false, 'BaseRest', Logger.defaultLogger, { Rest }));\n  }\n}\n", "import { Rest } from './rest';\nimport { IUntypedCryptoStatic } from '../../types/ICryptoStatic';\nimport { MsgPack } from 'common/types/msgpack';\nimport RealtimePresence from './realtimepresence';\nimport XHRRequest from 'platform/web/lib/http/request/xhrrequest';\nimport fetchRequest from 'platform/web/lib/http/request/fetchrequest';\nimport { FilteredSubscriptions } from './filteredsubscriptions';\nimport PresenceMessage, { WirePresenceMessage } from '../types/presencemessage';\nimport { TransportCtor } from '../transport/transport';\nimport * as PushPlugin from 'plugins/push';\n\nexport interface PresenceMessagePlugin {\n  PresenceMessage: typeof PresenceMessage;\n  WirePresenceMessage: typeof WirePresenceMessage;\n}\n\nexport type RealtimePresencePlugin = PresenceMessagePlugin & {\n  RealtimePresence: typeof RealtimePresence;\n};\n\nexport interface ModularPlugins {\n  Rest?: typeof Rest;\n  Crypto?: IUntypedCryptoStatic;\n  MsgPack?: MsgPack;\n  RealtimePresence?: RealtimePresencePlugin;\n  WebSocketTransport?: TransportCtor;\n  XHRPolling?: TransportCtor;\n  XHRRequest?: typeof XHRRequest;\n  FetchRequest?: typeof fetchRequest;\n  MessageInteractions?: typeof FilteredSubscriptions;\n  Push?: typeof PushPlugin;\n}\n\nexport const allCommonModularPlugins: ModularPlugins = { Rest };\n", "import Message, { WireMessage, fromEncoded, fromEncodedArray } from './message';\nimport * as API from '../../../../ably';\nimport Platform from 'common/platform';\nimport Logger from '../util/logger';\nimport type { Properties } from '../util/utils';\n\n/**\n `DefaultMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `Message` static property. It introduces the static methods described in the `MessageStatic` interface of the public API of the non tree-shakable version of the library.\n */\nexport class DefaultMessage extends Message {\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<Message> {\n    return fromEncoded(Logger.defaultLogger, Platform.Crypto, encoded as WireMessage, inputOptions);\n  }\n\n  static async fromEncodedArray(encodedArray: Array<unknown>, options?: API.ChannelOptions): Promise<Message[]> {\n    return fromEncodedArray(Logger.defaultLogger, Platform.Crypto, encodedArray as WireMessage[], options);\n  }\n\n  static fromValues(values: Properties<Message>): Message {\n    return Message.fromValues(values);\n  }\n}\n", "import * as API from '../../../../ably';\nimport Logger from '../util/logger';\nimport PresenceMessage, { fromEncoded, fromEncodedArray, WirePresenceMessage } from './presencemessage';\nimport Platform from 'common/platform';\nimport type { Properties } from '../util/utils';\n\n/**\n `DefaultPresenceMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `PresenceMessage` static property. It introduces the static methods described in the `PresenceMessageStatic` interface of the public API of the non tree-shakable version of the library.\n */\nexport class DefaultPresenceMessage extends PresenceMessage {\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<PresenceMessage> {\n    return fromEncoded(Logger.defaultLogger, Platform.Crypto, encoded as WirePresenceMessage, inputOptions);\n  }\n\n  static async fromEncodedArray(\n    encodedArray: Array<unknown>,\n    options?: API.ChannelOptions,\n  ): Promise<PresenceMessage[]> {\n    return fromEncodedArray(Logger.defaultLogger, Platform.Crypto, encodedArray as WirePresenceMessage[], options);\n  }\n\n  static fromValues(values: Properties<PresenceMessage>): PresenceMessage {\n    return PresenceMessage.fromValues(values);\n  }\n}\n", "import { BaseRest } from './baserest';\nimport ClientOptions from '../../types/ClientOptions';\nimport { allCommonModularPlugins } from './modularplugins';\nimport Platform from 'common/platform';\nimport { DefaultMessage } from '../types/defaultmessage';\nimport { MsgPack } from 'common/types/msgpack';\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\nimport { Http } from 'common/types/http';\nimport Defaults from '../util/defaults';\nimport Logger from '../util/logger';\n\n/**\n `DefaultRest` is the class that the non tree-shakable version of the SDK exports as `Rest`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\n */\nexport class DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options?: ClientOptions | string) {\n    const MsgPack = DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error('Expected DefaultRest._MsgPack to have been set');\n    }\n\n    super(\n      Defaults.objectifyOptions(options, true, 'Rest', Logger.defaultLogger, {\n        ...allCommonModularPlugins,\n        Crypto: DefaultRest.Crypto ?? undefined,\n        MsgPack: DefaultRest._MsgPack ?? undefined,\n      }),\n    );\n  }\n\n  private static _Crypto: typeof Platform.Crypto = null;\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\n    }\n\n    return this._Crypto;\n  }\n  static set Crypto(newValue: typeof Platform.Crypto) {\n    this._Crypto = newValue;\n  }\n\n  static Message = DefaultMessage;\n  static PresenceMessage = DefaultPresenceMessage;\n\n  static _MsgPack: MsgPack | null = null;\n\n  // Used by tests\n  static _Http = Http;\n}\n", "import * as Utils from './utils';\nimport Logger from './logger';\nimport Platform from 'common/platform';\n\n/* Call the listener, catch any exceptions and log, but continue operation*/\nfunction callListener(logger: Logger, eventThis: { event: string }, listener: Function, args: unknown[]) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    Logger.logAction(\n      logger,\n      Logger.LOG_ERROR,\n      'EventEmitter.emit()',\n      'Unexpected listener exception: ' + e + '; stack = ' + (e && (e as Error).stack),\n    );\n  }\n}\n\n/**\n * Remove listeners that match listener\n * @param targetListeners is an array of listener arrays or event objects with arrays of listeners\n * @param listener the listener callback to remove\n * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event\n */\nfunction removeListener(targetListeners: any, listener: Function, eventFilter?: string) {\n  let listeners: Record<string, unknown>;\n  let index;\n  let eventName;\n\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter] as Record<string, unknown>;\n    }\n\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      /* If events object has an event name key with no listeners then\n\t\t\t\t\tremove the key to stop the list growing indefinitely */\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (Utils.isObject(listeners)) {\n      /* events */\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\n\nclass EventEmitter {\n  any: Array<Function>;\n  events: Record<string, Array<Function>>;\n  anyOnce: Array<Function>;\n  eventsOnce: Record<string, Array<Function>>;\n\n  constructor(readonly logger: Logger) {\n    this.any = [];\n    this.events = Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = Object.create(null);\n  }\n\n  /**\n   * Add an event listener\n   * @param listener the listener to be called\n   */\n  on(listener: Function): void;\n\n  /**\n   * Add an event listener\n   * @param event (optional) the name of the event to listen to\n   * @param listener the listener to be called\n   */\n  on(event: null | string | string[], listener: Function): void;\n\n  on(...args: unknown[]) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === 'function') {\n        this.any.push(listener);\n      } else {\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== 'function') {\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\n      }\n      if (Utils.isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== 'string') {\n          throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n\n  /**\n   * Remove one or more event listeners\n   * @param listener (optional) the listener to remove. If not\n   *        supplied, all listeners are removed.\n   */\n  off(listener?: Function): void;\n\n  /**\n   * Remove one or more event listeners\n   * @param event (optional) the name of the event whose listener\n   *        is to be removed. If not supplied, the listener is\n   *        treated as an 'any' listener\n   * @param listener (optional) the listener to remove. If not\n   *        supplied, all listeners are removed.\n   */\n  off(event: string | string[] | null, listener?: Function | null): void;\n\n  off(...args: unknown[]) {\n    if (args.length == 0 || (Utils.isNil(args[0]) && Utils.isNil(args[1]))) {\n      this.any = [];\n      this.events = Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener: Function | null = null;\n    let event: unknown = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === 'function') {\n        /* we take this to be the listener and treat the event as \"any\" .. */\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n      /* ... or we take event to be the actual event name and listener to be all */\n    } else {\n      if (typeof secondArg !== 'function') {\n        throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n\n    if (listener && Utils.isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n\n    /* \"normal\" case where event is an actual event */\n    if (typeof event !== 'string') {\n      throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event: string) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event]) Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event: string, ...args: unknown[] /* , args... */) {\n    const eventThis = { event };\n    const listeners: Function[] = [];\n\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n\n  /**\n   * Listen for a single occurrence of an event\n   * @param event the name of the event to listen to\n   */\n  once(event: string): Promise<void>;\n\n  /**\n   * Listen for a single occurrence of any event\n   * @param listener the listener to be called\n   */\n  once(listener: Function): void;\n\n  /**\n   * Listen for a single occurrence of an event\n   * @param event the name of the event to listen to\n   * @param listener the listener to be called\n   */\n  once(event?: string | string[] | null, listener?: Function): void;\n\n  once(...args: unknown[]): void | Promise<void> {\n    const argCount = args.length;\n    if (argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event as string | string[] | null, resolve);\n      });\n    }\n\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === 'function') {\n      this.anyOnce.push(firstArg);\n    } else if (Utils.isNil(firstArg)) {\n      if (typeof secondArg !== 'function') {\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self = this;\n      const listenerWrapper = function (this: any) {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function (eventName) {\n          self.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== 'function') {\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function (eventName) {\n        self.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== 'string') {\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== 'function') {\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState: string, currentState: string) {\n    if (typeof targetState !== 'string' || typeof currentState !== 'string') {\n      throw new Error('whenState requires a valid state String argument');\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n}\n\nexport default EventEmitter;\n", "import { MsgPack } from 'common/types/msgpack';\nimport * as API from '../../../../ably';\nimport { PresenceMessagePlugin } from '../client/modularplugins';\nimport * as Utils from '../util/utils';\nimport ErrorInfo from './errorinfo';\nimport { WireMessage } from './message';\nimport PresenceMessage, { WirePresenceMessage } from './presencemessage';\nimport { flags, flagNames, channelModes, ActionName } from './protocolmessagecommon';\nimport type { Properties } from '../util/utils';\n\nexport const serialize = Utils.encodeBody;\n\nfunction toStringArray(array?: any[]): string {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return '[ ' + result.join(', ') + ' ]';\n}\n\nexport function deserialize(\n  serialized: unknown,\n  MsgPack: MsgPack | null,\n  presenceMessagePlugin: PresenceMessagePlugin | null,\n  format?: Utils.Format,\n): ProtocolMessage {\n  const deserialized = Utils.decodeBody<Record<string, unknown>>(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin);\n}\n\nexport function fromDeserialized(\n  deserialized: Record<string, unknown>,\n  presenceMessagePlugin: PresenceMessagePlugin | null,\n): ProtocolMessage {\n  let error: ErrorInfo | undefined;\n  if (deserialized.error) {\n    error = ErrorInfo.fromValues(deserialized.error as ErrorInfo);\n  }\n\n  let messages: WireMessage[] | undefined;\n  if (deserialized.messages) {\n    messages = WireMessage.fromValuesArray(deserialized.messages as Array<Properties<WireMessage>>);\n  }\n\n  let presence: WirePresenceMessage[] | undefined;\n  if (presenceMessagePlugin && deserialized.presence) {\n    presence = presenceMessagePlugin.WirePresenceMessage.fromValuesArray(\n      deserialized.presence as Array<Properties<WirePresenceMessage>>,\n    );\n  }\n\n  return Object.assign(new ProtocolMessage(), { ...deserialized, presence, messages, error });\n}\n\n/**\n * Used by the tests.\n */\nexport function fromDeserializedIncludingDependencies(deserialized: Record<string, unknown>): ProtocolMessage {\n  return fromDeserialized(deserialized, { PresenceMessage, WirePresenceMessage });\n}\n\nexport function fromValues(values: unknown): ProtocolMessage {\n  return Object.assign(new ProtocolMessage(), values);\n}\n\nexport function stringify(msg: any, presenceMessagePlugin: PresenceMessagePlugin | null): string {\n  let result = '[ProtocolMessage';\n  if (msg.action !== undefined) result += '; action=' + ActionName[msg.action] || msg.action;\n\n  const simpleAttributes = ['id', 'channel', 'channelSerial', 'connectionId', 'count', 'msgSerial', 'timestamp'];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== undefined) result += '; ' + attribute + '=' + msg[attribute];\n  }\n\n  if (msg.messages) result += '; messages=' + toStringArray(WireMessage.fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += '; presence=' + toStringArray(presenceMessagePlugin.WirePresenceMessage.fromValuesArray(msg.presence));\n  if (msg.error) result += '; error=' + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken) result += '; token=' + msg.auth.accessToken;\n  if (msg.flags) result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');\n  if (msg.params) {\n    let stringifiedParams = '';\n    Utils.forInOwnNonNullProperties(msg.params, function (prop: string) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += '; ';\n      }\n      stringifiedParams += prop + '=' + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += '; params=[' + stringifiedParams + ']';\n    }\n  }\n  result += ']';\n  return result;\n}\n\nclass ProtocolMessage {\n  action?: number;\n  flags?: number;\n  id?: string;\n  timestamp?: number;\n  count?: number;\n  error?: ErrorInfo;\n  connectionId?: string;\n  channel?: string;\n  channelSerial?: string | null;\n  msgSerial?: number;\n  messages?: WireMessage[];\n  // This will be undefined if we skipped decoding this property due to user not requesting presence functionality \u2014 see `fromDeserialized`\n  presence?: WirePresenceMessage[];\n  auth?: unknown;\n  connectionDetails?: Record<string, unknown>;\n\n  hasFlag = (flag: string): boolean => {\n    return ((this.flags as number) & flags[flag]) > 0;\n  };\n\n  setFlag(flag: keyof typeof flags): number {\n    return (this.flags = (this.flags as number) | flags[flag]);\n  }\n\n  getMode(): number | undefined {\n    return this.flags && this.flags & flags.MODE_ALL;\n  }\n\n  encodeModesToFlags(modes: API.ChannelMode[]): void {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n\n  decodeModesFromFlags(): string[] | undefined {\n    const modes: string[] = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : undefined;\n  }\n}\n\nexport default ProtocolMessage;\n", "import ErrorInfo from '../types/errorinfo';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport { PendingMessage } from './protocol';\n\nclass MessageQueue extends EventEmitter {\n  messages: Array<PendingMessage>;\n\n  constructor(logger: Logger) {\n    super(logger);\n    this.messages = [];\n  }\n\n  count(): number {\n    return this.messages.length;\n  }\n\n  push(message: PendingMessage): void {\n    this.messages.push(message);\n  }\n\n  shift(): PendingMessage | undefined {\n    return this.messages.shift();\n  }\n\n  last(): PendingMessage {\n    return this.messages[this.messages.length - 1];\n  }\n\n  copyAll(): PendingMessage[] {\n    return this.messages.slice();\n  }\n\n  append(messages: Array<PendingMessage>): void {\n    this.messages.push.apply(this.messages, messages);\n  }\n\n  prepend(messages: Array<PendingMessage>): void {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n\n  completeMessages(serial: number, count: number, err?: ErrorInfo | null): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'MessageQueue.completeMessages()',\n      'serial = ' + serial + '; count = ' + count,\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');\n    }\n    const first = messages[0];\n    if (first) {\n      const startSerial = first.message.msgSerial as number;\n      const endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */\n      if (endSerial > startSerial) {\n        const completeMessages = messages.splice(0, endSerial - startSerial);\n        for (const message of completeMessages) {\n          (message.callback as Function)(err);\n        }\n      }\n      if (messages.length == 0) this.emit('idle');\n    }\n  }\n\n  completeAllMessages(err: ErrorInfo): void {\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n  }\n\n  resetSendAttempted(): void {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n\n  clear(): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'MessageQueue.clear()',\n      'clearing ' + this.messages.length + ' messages',\n    );\n    this.messages = [];\n    this.emit('idle');\n  }\n}\n\nexport default MessageQueue;\n", "import { actions } from '../types/protocolmessagecommon';\nimport ProtocolMessage, { stringify as stringifyProtocolMessage } from '../types/protocolmessage';\nimport * as Utils from '../util/utils';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport MessageQueue from './messagequeue';\nimport ErrorInfo from '../types/errorinfo';\nimport Transport from './transport';\nimport { ErrCallback } from '../../types/utils';\n\nexport class PendingMessage {\n  message: ProtocolMessage;\n  callback?: ErrCallback;\n  merged: boolean;\n  sendAttempted: boolean;\n  ackRequired: boolean;\n\n  constructor(message: ProtocolMessage, callback?: ErrCallback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;\n  }\n}\n\nclass Protocol extends EventEmitter {\n  transport: Transport;\n  messageQueue: MessageQueue;\n\n  constructor(transport: Transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new MessageQueue(this.logger);\n    transport.on('ack', (serial: number, count: number) => {\n      this.onAck(serial, count);\n    });\n    transport.on('nack', (serial: number, count: number, err: ErrorInfo) => {\n      this.onNack(serial, count, err);\n    });\n  }\n\n  onAck(serial: number, count: number): void {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);\n    this.messageQueue.completeMessages(serial, count);\n  }\n\n  onNack(serial: number, count: number, err: ErrorInfo): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_ERROR,\n      'Protocol.onNack()',\n      'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err),\n    );\n    if (!err) {\n      err = new ErrorInfo('Unable to send message; channel not responding', 50001, 500);\n    }\n    this.messageQueue.completeMessages(serial, count, err);\n  }\n\n  onceIdle(listener: ErrCallback): void {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once('idle', listener);\n  }\n\n  send(pendingMessage: PendingMessage): void {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\n      Logger.logActionNoStrip(\n        this.logger,\n        Logger.LOG_MICRO,\n        'Protocol.send()',\n        'sending msg; ' +\n          stringifyProtocolMessage(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence),\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n\n  getTransport(): Transport {\n    return this.transport;\n  }\n\n  getPendingMessages(): PendingMessage[] {\n    return this.messageQueue.copyAll();\n  }\n\n  clearPendingMessages(): void {\n    return this.messageQueue.clear();\n  }\n\n  finish(): void {\n    const transport = this.transport;\n    this.onceIdle(function () {\n      transport.disconnect();\n    });\n  }\n}\n\nexport default Protocol;\n", "import { IPartialErrorInfo } from '../types/errorinfo';\n\nclass ConnectionStateChange {\n  previous?: string;\n  current?: string;\n  retryIn?: number;\n  reason?: IPartialErrorInfo;\n\n  constructor(previous?: string, current?: string, retryIn?: number | null, reason?: IPartialErrorInfo) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn) this.retryIn = retryIn;\n    if (reason) this.reason = reason;\n  }\n}\n\nexport default ConnectionStateChange;\n", "import ErrorInfo from '../types/errorinfo';\n\nconst ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 80000,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001,\n};\n\nconst ConnectionErrors = {\n  disconnected: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.DISCONNECTED,\n      message: 'Connection to server temporarily unavailable',\n    }),\n  suspended: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.SUSPENDED,\n      message: 'Connection to server unavailable',\n    }),\n  failed: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.FAILED,\n      message: 'Connection failed or disconnected by server',\n    }),\n  closing: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSING,\n      message: 'Connection closing',\n    }),\n  closed: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSED,\n      message: 'Connection closed',\n    }),\n  unknownConnectionErr: () =>\n    ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: 'Internal connection error',\n    }),\n  unknownChannelErr: () =>\n    ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: 'Internal channel error',\n    }),\n};\n\nexport function isRetriable(err: ErrorInfo) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\n\nexport default ConnectionErrors;\n", "import { actions } from '../types/protocolmessagecommon';\nimport ProtocolMessage, {\n  fromValues as protocolMessageFromValues,\n  stringify as stringifyProtocolMessage,\n} from '../types/protocolmessage';\nimport * as Utils from '../util/utils';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport ConnectionErrors from './connectionerrors';\nimport ErrorInfo from '../types/errorinfo';\nimport Auth from '../client/auth';\nimport * as API from '../../../../ably';\nimport ConnectionManager, { TransportParams } from './connectionmanager';\nimport Platform from 'common/platform';\nimport TransportName from 'common/constants/TransportName';\n\nexport type TryConnectCallback = (\n  wrappedErr: { error: ErrorInfo; event: string } | null,\n  transport?: Transport,\n) => void;\n\nexport interface TransportCtor {\n  new (\n    connectionManager: ConnectionManager,\n    auth: Auth,\n    params: TransportParams,\n    forceJsonProtocol?: boolean,\n  ): Transport;\n\n  isAvailable(): boolean;\n}\n\nconst closeMessage = protocolMessageFromValues({ action: actions.CLOSE });\nconst disconnectMessage = protocolMessageFromValues({ action: actions.DISCONNECT });\n\n/*\n * Transport instances inherit from EventEmitter and emit the following events:\n *\n * event name       data\n * closed           error\n * failed           error\n * disposed\n * connected        null error, connectionSerial, connectionId, connectionDetails\n * event            channel message object\n */\n\nabstract class Transport extends EventEmitter {\n  connectionManager: ConnectionManager;\n  auth: Auth;\n  params: TransportParams;\n  timeouts: Record<string, number>;\n  format?: Utils.Format;\n  isConnected: boolean;\n  isFinished: boolean;\n  isDisposed: boolean;\n  maxIdleInterval: number | null;\n  idleTimer: NodeJS.Timeout | number | null;\n  lastActivity: number | null;\n\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams, forceJsonProtocol?: boolean) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = undefined;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n\n  abstract shortName: TransportName;\n  abstract send(message: ProtocolMessage): void;\n\n  connect(): void {}\n\n  close(): void {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish('closed', ConnectionErrors.closed());\n  }\n\n  disconnect(err?: Error | ErrorInfo): void {\n    /* Used for network/transport issues that need to result in the transport\n     * being disconnected, but should not transition the connection to 'failed' */\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish('disconnected', err || ConnectionErrors.disconnected());\n  }\n\n  fail(err: ErrorInfo): void {\n    /* Used for client-side-detected fatal connection issues */\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish('failed', err || ConnectionErrors.failed());\n  }\n\n  finish(event: string, err?: Error | ErrorInfo): void {\n    if (this.isFinished) {\n      return;\n    }\n\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout(this.idleTimer ?? undefined);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n\n  onProtocolMessage(message: ProtocolMessage): void {\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\n      Logger.logActionNoStrip(\n        this.logger,\n        Logger.LOG_MICRO,\n        'Transport.onProtocolMessage()',\n        'received on ' +\n          this.shortName +\n          ': ' +\n          stringifyProtocolMessage(message, this.connectionManager.realtime._RealtimePresence) +\n          '; connectionId = ' +\n          this.connectionManager.connectionId,\n      );\n    }\n    this.onActivity();\n\n    switch (message.action) {\n      case actions.HEARTBEAT:\n        Logger.logActionNoStrip(\n          this.logger,\n          Logger.LOG_MICRO,\n          'Transport.onProtocolMessage()',\n          this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId,\n        );\n        this.emit('heartbeat', message.id);\n        break;\n      case actions.CONNECTED:\n        this.onConnect(message);\n        this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions.CLOSED:\n        this.onClose(message);\n        break;\n      case actions.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions.ACK:\n        this.emit('ack', message.msgSerial, message.count);\n        break;\n      case actions.NACK:\n        this.emit('nack', message.msgSerial, message.count, message.error);\n        break;\n      case actions.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions.ACTIVATE:\n        // Ignored.\n        break;\n      case actions.AUTH:\n        Utils.whenPromiseSettles(this.auth.authorize(), (err: ErrorInfo | null) => {\n          if (err) {\n            Logger.logAction(\n              this.logger,\n              Logger.LOG_ERROR,\n              'Transport.onProtocolMessage()',\n              'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err),\n            );\n          }\n        });\n        break;\n      case actions.ERROR:\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'Transport.onProtocolMessage()',\n          'received error action; connectionId = ' +\n            this.connectionManager.connectionId +\n            '; err = ' +\n            Platform.Config.inspect(message.error) +\n            (message.channel ? ', channel: ' + message.channel : ''),\n        );\n        if (message.channel === undefined) {\n          this.onFatalError(message);\n          break;\n        }\n        /* otherwise it's a channel-specific error, so handle it in the channel */\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        /* all other actions are channel-specific */\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n\n  onConnect(message: ProtocolMessage): void {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval as number;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n    /* else Realtime declines to guarantee any maximum idle interval - CD2h */\n  }\n\n  onDisconnect(message: ProtocolMessage): void {\n    /* Used for when the server has disconnected the client (usually with a\n     * DISCONNECTED action) */\n    const err = message && message.error;\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));\n    this.finish('disconnected', err);\n  }\n\n  onFatalError(message: ProtocolMessage): void {\n    /* On receipt of a fatal connection error, we can assume that the server\n     * will close the connection and the transport, and do not need to request\n     * a disconnection - RTN15i */\n    const err = message && message.error;\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));\n    this.finish('failed', err);\n  }\n\n  onClose(message: ProtocolMessage): void {\n    const err = message && message.error;\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));\n    this.finish('closed', err);\n  }\n\n  requestClose(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.requestClose()', '');\n    this.send(closeMessage);\n  }\n\n  requestDisconnect(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.requestDisconnect()', '');\n    this.send(disconnectMessage);\n  }\n\n  ping(id: string): void {\n    const msg: Record<string, number | string> = { action: actions.HEARTBEAT };\n    if (id) msg.id = id;\n    this.send(protocolMessageFromValues(msg));\n  }\n\n  dispose(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.dispose()', '');\n    this.isDisposed = true;\n    this.off();\n  }\n\n  onActivity(): void {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n\n  setIdleTimer(timeout: number): void {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n\n  onIdleTimerExpire(): void {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n\n  static tryConnect(\n    transportCtor: TransportCtor,\n    connectionManager: ConnectionManager,\n    auth: Auth,\n    transportParams: TransportParams,\n    callback: TryConnectCallback,\n  ): Transport {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n\n    let transportAttemptTimer: NodeJS.Timeout | number;\n\n    const errorCb = function (this: { event: string }, err: ErrorInfo) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off(['preconnect', 'disconnected', 'failed']);\n      transport.dispose();\n      errorCb.call(\n        { event: 'disconnected' },\n        new ErrorInfo('Timeout waiting for transport to indicate itself viable', 50000, 500),\n      );\n    }, realtimeRequestTimeout);\n\n    transport.on(['failed', 'disconnected'], errorCb);\n    transport.on('preconnect', function () {\n      Logger.logAction(\n        connectionManager.logger,\n        Logger.LOG_MINOR,\n        'Transport.tryConnect()',\n        'viable transport ' + transport,\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off(['failed', 'disconnected'], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n\n  onAuthUpdated?: (tokenDetails: API.TokenDetails) => void;\n\n  static isAvailable(): boolean {\n    throw new ErrorInfo('isAvailable not implemented for transport', 50000, 500);\n  }\n}\n\nexport default Transport;\n", "export namespace TransportNames {\n  export const WebSocket = 'web_socket' as const;\n  export const Comet = 'comet' as const;\n  export const XhrPolling = 'xhr_polling' as const;\n}\n\ntype TransportName = typeof TransportNames.WebSocket | typeof TransportNames.Comet | typeof TransportNames.XhrPolling;\n\nexport default TransportName;\n", "import { actions } from '../types/protocolmessagecommon';\nimport ProtocolMessage, {\n  stringify as stringifyProtocolMessage,\n  fromValues as protocolMessageFromValues,\n} from 'common/lib/types/protocolmessage';\nimport * as Utils from 'common/lib/util/utils';\nimport Protocol, { PendingMessage } from './protocol';\nimport Defaults, { getAgentString } from 'common/lib/util/defaults';\nimport Platform, { TransportImplementations } from 'common/platform';\nimport EventEmitter from '../util/eventemitter';\nimport MessageQueue from './messagequeue';\nimport Logger from '../util/logger';\nimport ConnectionStateChange from 'common/lib/client/connectionstatechange';\nimport ConnectionErrors, { isRetriable } from './connectionerrors';\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport Auth from 'common/lib/client/auth';\nimport Message, { getMessagesSize } from 'common/lib/types/message';\nimport Multicaster, { MulticasterInstance } from 'common/lib/util/multicaster';\nimport Transport, { TransportCtor } from './transport';\nimport * as API from '../../../../ably';\nimport { ErrCallback } from 'common/types/utils';\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\nimport BaseRealtime from '../client/baserealtime';\nimport { NormalisedClientOptions } from 'common/types/ClientOptions';\nimport TransportName, { TransportNames } from 'common/constants/TransportName';\n\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\n\nconst haveWebStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.localSupported;\nconst haveSessionStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.sessionSupported;\nconst noop = function () {};\nconst transportPreferenceName = 'ably-transport-preference';\n\nfunction bundleWith(dest: ProtocolMessage, src: ProtocolMessage, maxSize: number) {\n  let action;\n  if (dest.channel !== src.channel) {\n    /* RTL6d3 */\n    return false;\n  }\n  if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\n    /* RTL6d - can only bundle messages or presence */\n    return false;\n  }\n  if (action !== src.action) {\n    /* RTL6d4 */\n    return false;\n  }\n  const kind = action === actions.PRESENCE ? 'presence' : 'messages',\n    proposed = (dest as Record<string, any>)[kind].concat((src as Record<string, any>)[kind]),\n    size = getMessagesSize(proposed);\n  if (size > maxSize) {\n    /* RTL6d1 */\n    return false;\n  }\n  if (!Utils.allSame(proposed, 'clientId')) {\n    /* RTL6d2 */\n    return false;\n  }\n  if (\n    !proposed.every(function (msg: Message) {\n      return !msg.id;\n    })\n  ) {\n    /* RTL6d7 */\n    return false;\n  }\n  /* we're good to go! */\n  (dest as Record<string, any>)[kind] = proposed;\n  return true;\n}\n\ntype RecoveryContext = {\n  connectionKey: string;\n  msgSerial: number;\n  channelSerials: { [name: string]: string };\n};\n\nfunction decodeRecoveryKey(recoveryKey: NormalisedClientOptions['recover']): RecoveryContext | null {\n  try {\n    return JSON.parse(recoveryKey as string);\n  } catch (e) {\n    return null;\n  }\n}\n\nexport class TransportParams {\n  options: NormalisedClientOptions;\n  host: string | null;\n  mode: string;\n  format?: Utils.Format;\n  connectionKey?: string;\n  stream?: any;\n  heartbeats?: boolean;\n\n  constructor(options: NormalisedClientOptions, host: string | null, mode: string, connectionKey?: string) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\n  }\n\n  getConnectParams(authParams: Record<string, unknown>): Record<string, string> {\n    const params = authParams ? Utils.copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case 'resume':\n        params.resume = this.connectionKey as string;\n        break;\n      case 'recover': {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== undefined) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = 'false';\n    }\n    if (this.format !== undefined) {\n      params.format = this.format;\n    }\n    if (this.stream !== undefined) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== undefined) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = Defaults.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== undefined) {\n      Utils.mixin(params, options.transportParams);\n    }\n    return params as Record<string, string>;\n  }\n\n  toString(): string {\n    let result = '[mode=' + this.mode;\n    if (this.host) {\n      result += ',host=' + this.host;\n    }\n    if (this.connectionKey) {\n      result += ',connectionKey=' + this.connectionKey;\n    }\n    if (this.format) {\n      result += ',format=' + this.format;\n    }\n    result += ']';\n\n    return result;\n  }\n}\n\ntype ConnectionState = {\n  state: string;\n  terminal?: boolean;\n  queueEvents?: boolean;\n  sendEvents?: boolean;\n  failState?: string;\n  retryDelay?: number;\n  retryImmediately?: boolean;\n  error?: IPartialErrorInfo;\n};\n\nclass ConnectionManager extends EventEmitter {\n  supportedTransports: Partial<Record<TransportName, TransportCtor>> = {};\n  realtime: BaseRealtime;\n  options: NormalisedClientOptions;\n  states: Record<string, ConnectionState>;\n  state: ConnectionState;\n  errorReason: IPartialErrorInfo | null;\n  queuedMessages: MessageQueue;\n  msgSerial: number;\n  connectionDetails?: Record<string, any>;\n  connectionId?: string;\n  connectionKey?: string;\n  connectionStateTtl: number;\n  maxIdleInterval: number | null;\n  transports: TransportName[];\n  baseTransport?: TransportName;\n  webSocketTransportAvailable?: true;\n  transportPreference: string | null;\n  httpHosts: string[];\n  wsHosts: string[];\n  activeProtocol: null | Protocol;\n  pendingTransport?: Transport;\n  proposedTransport?: Transport;\n  host: string | null;\n  lastAutoReconnectAttempt: number | null;\n  lastActivity: number | null;\n  forceFallbackHost: boolean;\n  transitionTimer?: number | NodeJS.Timeout | null;\n  suspendTimer?: number | NodeJS.Timeout | null;\n  retryTimer?: number | NodeJS.Timeout | null;\n  disconnectedRetryCount: number = 0;\n  pendingChannelMessagesState: {\n    // Whether a message is currently being processed\n    isProcessing: boolean;\n    // The messages remaining to be processed (excluding any message currently being processed)\n    queue: { message: ProtocolMessage; transport: Transport }[];\n  } = { isProcessing: false, queue: [] };\n  webSocketSlowTimer: NodeJS.Timeout | null;\n  wsCheckResult: boolean | null;\n  webSocketGiveUpTimer: NodeJS.Timeout | null;\n  abandonedWebSocket: boolean;\n  connectCounter: number;\n\n  constructor(realtime: BaseRealtime, options: NormalisedClientOptions) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    /* connectingTimeout: leave webSocketConnectTimeout (~6s) to try the\n     * websocket transport, then realtimeRequestTimeout (~10s) to establish\n     * the base transport in case that fails */\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: 'initialized',\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: 'disconnected',\n      },\n      connecting: {\n        state: 'connecting',\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: 'disconnected',\n      },\n      connected: {\n        state: 'connected',\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: 'disconnected',\n      },\n      disconnected: {\n        state: 'disconnected',\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: 'disconnected',\n      },\n      suspended: {\n        state: 'suspended',\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: 'suspended',\n      },\n      closing: {\n        state: 'closing',\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: 'closed',\n      },\n      closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },\n      failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n\n    this.queuedMessages = new MessageQueue(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = undefined;\n    this.connectionId = undefined;\n    this.connectionKey = undefined;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n\n    this.transports = Utils.intersect(options.transports || Defaults.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n\n    this.httpHosts = Defaults.getHosts(options);\n    this.wsHosts = Defaults.getHosts(options, true);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'Realtime.ConnectionManager()',\n      'requested transports = [' + (options.transports || Defaults.defaultTransports) + ']',\n    );\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'Realtime.ConnectionManager()',\n      'available transports = [' + this.transports + ']',\n    );\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'Realtime.ConnectionManager()',\n      'http hosts = [' + this.httpHosts + ']',\n    );\n\n    if (!this.transports.length) {\n      const msg = 'no requested transports available';\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'realtime.ConnectionManager()', msg);\n      throw new Error(msg);\n    }\n\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      /* intercept close event in browser to persist connection id if requested */\n      if (haveSessionStorage() && typeof options.recover === 'function') {\n        addEventListener('beforeunload', this.persistConnection.bind(this));\n      }\n\n      if (options.closeOnUnload === true) {\n        addEventListener('beforeunload', () => {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MAJOR,\n            'Realtime.ConnectionManager()',\n            'beforeunload event has triggered the connection to close as closeOnUnload is true',\n          );\n          this.requestState({ state: 'closing' });\n        });\n      }\n\n      /* Listen for online and offline events */\n      addEventListener('online', () => {\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MINOR,\n            'ConnectionManager caught browser \u2018online\u2019 event',\n            'reattempting connection',\n          );\n          this.requestState({ state: 'connecting' });\n        } else if (this.state == this.states.connecting) {\n          // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry\n          this.pendingTransport?.off();\n          this.disconnectAllTransports();\n\n          this.startConnect();\n        }\n      });\n\n      addEventListener('offline', () => {\n        if (this.state == this.states.connected) {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MINOR,\n            'ConnectionManager caught browser \u2018offline\u2019 event',\n            'disconnecting active transport',\n          );\n          // Not sufficient to just go to the 'disconnected' state, want to\n          // force all transports to reattempt the connection. Will immediately\n          // retry.\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n\n  /*********************\n   * transport management\n   *********************/\n\n  // Used by tests\n  static supportedTransports(additionalImplementations: TransportImplementations) {\n    const storage: TransportStorage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n\n  private static initTransports(additionalImplementations: TransportImplementations, storage: TransportStorage) {\n    const implementations = { ...Platform.Transports.bundledImplementations, ...additionalImplementations };\n\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n\n  initTransports() {\n    ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n\n  createTransportParams(host: string | null, mode: string): TransportParams {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n\n  getTransportParams(callback: Function): void {\n    const decideMode = (modeCb: Function) => {\n      if (this.connectionKey) {\n        modeCb('resume');\n        return;\n      }\n\n      if (typeof this.options.recover === 'string') {\n        modeCb('recover');\n        return;\n      }\n\n      const recoverFn = this.options.recover,\n        lastSessionData = this.getSessionRecoverData(),\n        sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === 'function') {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'ConnectionManager.getTransportParams()',\n          'Calling clientOptions-provided recover function with last session data (recovery scope: ' +\n            sessionRecoveryName +\n            ')',\n        );\n        recoverFn(lastSessionData, (shouldRecover?: boolean) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb('recover');\n          } else {\n            modeCb('clean');\n          }\n        });\n        return;\n      }\n      modeCb('clean');\n    };\n\n    decideMode((mode: string) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === 'recover') {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'ConnectionManager.getTransportParams()',\n          'Transport recovery mode = recover; recoveryKey = ' + this.options.recover,\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'ConnectionManager.getTransportParams()',\n          'Transport params = ' + transportParams.toString(),\n        );\n      }\n      callback(transportParams);\n    });\n  }\n\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams: TransportParams, candidate: TransportName, callback: Function): void {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);\n\n    this.proposedTransport = Transport.tryConnect(\n      this.supportedTransports[candidate]!,\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr: { error: ErrorInfo; event: string } | null, transport?: Transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            Logger.logAction(\n              this.logger,\n              Logger.LOG_MINOR,\n              'ConnectionManager.tryATransport()',\n              'connection ' + state.state + ' while we were attempting the transport; closing ' + transport,\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n\n        if (wrappedErr) {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MINOR,\n            'ConnectionManager.tryATransport()',\n            'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString(),\n          );\n\n          /* Comet transport onconnect token errors can be dealt with here.\n           * Websocket ones only happen after the transport claims to be viable,\n           * so are dealt with as non-onconnect token errors */\n          if (\n            Auth.isTokenErr(wrappedErr.error) &&\n            !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))\n          ) {\n            this.errorReason = wrappedErr.error;\n            /* re-get a token and try again */\n            Utils.whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err: ErrorInfo | null) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === 'failed') {\n            /* Error that's fatal to the connection */\n            this.notifyState({ state: 'failed', error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === 'disconnected') {\n            if (!isRetriable(wrappedErr.error)) {\n              /* Error received from the server that does not call for trying a fallback host, eg a rate limit */\n              this.notifyState({ state: this.states.connecting.failState as string, error: wrappedErr.error });\n              callback(true);\n            } else {\n              /* Error with that transport only; continue trying other fallback hosts */\n              callback(false);\n            }\n          }\n          return;\n        }\n\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MICRO,\n          'ConnectionManager.tryATransport()',\n          'viable transport ' + candidate + '; setting pending',\n        );\n        this.setTransportPending(transport as Transport, transportParams);\n        callback(null, transport);\n      },\n    );\n  }\n\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport: Transport, transportParams: TransportParams): void {\n    const mode = transportParams.mode;\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.setTransportPending()',\n      'transport = ' + transport + '; mode = ' + mode,\n    );\n\n    this.pendingTransport = transport;\n\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n\n    transport.once('connected', (error: ErrorInfo, connectionId: string, connectionDetails: Record<string, any>) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n\n      if (mode === 'recover' && this.options.recover) {\n        /* After a successful recovery, we unpersist, as a recovery key cannot\n         * be used more than once */\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n\n    const self = this;\n    transport.on(['disconnected', 'closed', 'failed'], function (this: { event: string }, error: ErrorInfo) {\n      self.deactivateTransport(transport, this.event, error);\n    });\n\n    this.emit('transport.pending', transport);\n  }\n\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(\n    error: ErrorInfo,\n    transport: Transport,\n    connectionId: string,\n    connectionDetails: Record<string, any>,\n  ): boolean {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.activateTransport()',\n      'transport = ' + transport,\n    );\n    if (error) {\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);\n    }\n    if (connectionId) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MICRO,\n        'ConnectionManager.activateTransport()',\n        'connectionId =  ' + connectionId,\n      );\n    }\n    if (connectionDetails) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MICRO,\n        'ConnectionManager.activateTransport()',\n        'connectionDetails =  ' + JSON.stringify(connectionDetails),\n      );\n    }\n\n    this.persistTransportPreference(transport);\n\n    /* if the connectionmanager moved to the closing/closed state before this\n     * connection event, then we won't activate this transport */\n    const existingState = this.state,\n      connectedState = this.states.connected.state;\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.activateTransport()',\n      'current state = ' + existingState.state,\n    );\n    if (\n      existingState.state == this.states.closing.state ||\n      existingState.state == this.states.closed.state ||\n      existingState.state == this.states.failed.state\n    ) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'ConnectionManager.activateTransport()',\n        'Disconnecting transport and abandoning',\n      );\n      transport.disconnect();\n      return false;\n    }\n\n    delete this.pendingTransport;\n\n    /* if the transport is not connected then don't activate it */\n    if (!transport.isConnected) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'ConnectionManager.activateTransport()',\n        'Declining to activate transport ' + transport + ' since it appears to no longer be connected',\n      );\n      return false;\n    }\n\n    /* the given transport is connected; this will immediately\n     * take over as the active transport */\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new Protocol(transport);\n    this.host = transport.params.host;\n\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n\n    /* Rebroadcast any new connectionDetails from the active transport, which\n     * can come at any time (eg following a reauth), and emit an RTN24 UPDATE\n     * event. (Listener added on nextTick because we're in a transport.on('connected')\n     * callback at the moment; if we add it now we'll be adding it to the end\n     * of the listeners array and it'll be called immediately) */\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        'connected',\n        (connectedErr: ErrorInfo, _connectionId: string, connectionDetails: Record<string, any>) => {\n          this.onConnectionDetailsUpdate(connectionDetails, transport);\n          this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, connectedErr));\n        },\n      );\n    });\n\n    /* If previously not connected, notify the state change (including any\n     * error). */\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: 'connected', error: error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n\n    /* Send after the connection state update, as Channels hooks into this to\n     * resend attaches on a new transport if necessary */\n    this.emit('transport.active', transport);\n\n    /* Gracefully terminate existing protocol */\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        /* We could just requeue pending messages on the new transport, but\n         * actually this should never happen: transports should only take over\n         * from other active transports when upgrading, and upgrading waits for\n         * the old transport to be idle. So log an error. */\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_ERROR,\n          'ConnectionManager.activateTransport()',\n          'Previous active protocol (for transport ' +\n            existingActiveProtocol.transport.shortName +\n            ', new one is ' +\n            transport.shortName +\n            ') finishing with ' +\n            existingActiveProtocol.messageQueue.count() +\n            ' messages still pending',\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg =\n          'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +\n          transport.shortName +\n          '; stack = ' +\n          new Error().stack;\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport: Transport, state: string, error: ErrorInfo): void {\n    const currentProtocol = this.activeProtocol,\n      wasActive = currentProtocol && currentProtocol.getTransport() === transport,\n      wasPending = transport === this.pendingTransport,\n      noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.deactivateTransport()',\n      'transport = ' + transport,\n    );\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.deactivateTransport()',\n      'state = ' +\n        state +\n        (wasActive ? '; was active' : wasPending ? '; was pending' : '') +\n        (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'),\n    );\n    if (error && error.message)\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MICRO,\n        'ConnectionManager.deactivateTransport()',\n        'reason =  ' + error.message,\n      );\n\n    if (wasActive) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MICRO,\n        'ConnectionManager.deactivateTransport()',\n        'Getting, clearing, and requeuing ' +\n          (this.activeProtocol as Protocol).messageQueue.count() +\n          ' pending messages',\n      );\n      this.queuePendingMessages((currentProtocol as Protocol).getPendingMessages());\n      /* Clear any messages we requeue to allow the protocol to become idle.*/\n      (currentProtocol as Protocol).clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n\n    this.emit('transport.inactive', transport);\n\n    /* this transport state change is a state change for the connectionmanager if\n     * - the transport was the active transport and there are no transports\n     *   which are connected and scheduled for activation, just waiting for the\n     *   active transport to finish what its doing; or\n     * - the transport was the active transport and the error was fatal (so\n     *   unhealable by another transport); or\n     * - there is no active transport, and this is the last remaining\n     *   pending transport (so we were in the connecting state)\n     */\n    if (\n      (wasActive && noTransportsScheduledForActivation) ||\n      (wasActive && state === 'failed') ||\n      state === 'closed' ||\n      (currentProtocol === null && wasPending)\n    ) {\n      /* If we're disconnected with a 5xx we need to try fallback hosts\n       * (RTN14d), but (a) due to how the upgrade sequence works, the\n       * host/transport selection sequence only cares about getting to\n       * `preconnect` (eg establishing a websocket) getting a `disconnected`\n       * protocol message afterwards is too late; and (b) host retry only\n       * applies to connectBase unless the stored preference transport doesn't\n       * work. We solve this by unpersisting the transport preference and\n       * setting an instance variable to force fallback hosts to be used (if\n       * any) here. Bit of a kludge, but no real better alternatives without\n       * rewriting the entire thing */\n      if (state === 'disconnected' && error && (error.statusCode as number) > 500 && this.httpHosts.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */\n        this.notifyState({ state: state, error: error, retryImmediately: true });\n        return;\n      }\n\n      /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */\n      const newConnectionState = state === 'failed' && Auth.isTokenErr(error) ? 'disconnected' : state;\n      this.notifyState({ state: newConnectionState, error: error });\n      return;\n    }\n  }\n\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation(): boolean {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n\n  setConnection(connectionId: string, connectionDetails: Record<string, any>, hasConnectionError?: boolean): void {\n    /* if connectionKey changes but connectionId stays the same, then just a\n     * transport change on the same connection. If connectionId changes, we're\n     * on a new connection, with implications for msgSerial and channel state */\n    /* If no previous connectionId, don't reset the msgSerial as it may have\n     * been set by recover data (unless the recover failed) */\n    const prevConnId = this.connectionId,\n      connIdChanged = prevConnId && prevConnId !== connectionId,\n      recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');\n      this.msgSerial = 0;\n      // RTN19a2: In the event of a new connectionId, previous msgSerials are\n      // meaningless.\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'ConnectionManager.setConnection()',\n        'New connectionId; reattaching any attached channels',\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n\n  clearConnection(): void {\n    this.realtime.connection.id = this.connectionId = undefined;\n    this.realtime.connection.key = this.connectionKey = undefined;\n    this.msgSerial = 0;\n    this.unpersistConnection();\n  }\n\n  createRecoveryKey(): string | null {\n    // RTN16g2.\n    if (!this.connectionKey) {\n      return null;\n    }\n\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials(),\n    });\n  }\n\n  checkConnectionStateFreshness(): void {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + (this.maxIdleInterval as number)) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'ConnectionManager.checkConnectionStateFreshness()',\n        'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state',\n      );\n      this.clearConnection();\n      this.states.connecting.failState = 'suspended';\n    }\n  }\n\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection(): void {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey: recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject.location,\n          clientId: this.realtime.auth.clientId,\n        });\n      }\n    }\n  }\n\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection(): void {\n    this.clearSessionRecoverData();\n  }\n\n  /*********************\n   * state management\n   *********************/\n\n  getError(): IPartialErrorInfo | string {\n    if (this.errorReason) {\n      // create new PartialErrorInfo so it has the correct stack trace\n      // which points to the place which caused us to return this error.\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n\n    return this.getStateError();\n  }\n\n  getStateError(): ErrorInfo {\n    return (ConnectionErrors as Record<string, () => ErrorInfo>)[this.state.state]?.();\n  }\n\n  activeState(): boolean | void {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n\n  enactStateChange(stateChange: ConnectionStateChange): void {\n    const action = 'Connection state';\n    const message = stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : '');\n    if (stateChange.current === 'failed') {\n      Logger.logAction(this.logger, Logger.LOG_ERROR, action, message);\n    } else {\n      Logger.logAction(this.logger, Logger.LOG_MAJOR, action, message);\n    }\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.enactStateChange',\n      'setting new state: ' +\n        stateChange.current +\n        '; reason = ' +\n        (stateChange.reason && (stateChange.reason as ErrorInfo).message),\n    );\n    const newState = (this.state = this.states[stateChange.current as string]);\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\n      this.realtime.connection.errorReason = stateChange.reason as ErrorInfo;\n    }\n    if (newState.terminal || newState.state === 'suspended') {\n      /* suspended is nonterminal, but once in the suspended state, realtime\n       * will have discarded our connection state, so futher connection\n       * attempts should start from scratch */\n      this.clearConnection();\n    }\n    this.emit('connectionstate', stateChange);\n  }\n\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n\n  startTransitionTimer(transitionState: ConnectionState): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.startTransitionTimer()',\n      'transitionState: ' + transitionState.state,\n    );\n\n    if (this.transitionTimer) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'ConnectionManager.startTransitionTimer()',\n        'clearing already-running timer',\n      );\n      clearTimeout(this.transitionTimer as number);\n    }\n\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'ConnectionManager ' + transitionState.state + ' timer expired',\n          'requesting new state: ' + transitionState.failState,\n        );\n        this.notifyState({ state: transitionState.failState as string });\n      }\n    }, transitionState.retryDelay);\n  }\n\n  cancelTransitionTimer(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer as number);\n      this.transitionTimer = null;\n    }\n  }\n\n  startSuspendTimer(): void {\n    if (this.suspendTimer) return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'ConnectionManager suspend timer expired',\n          'requesting new state: suspended',\n        );\n        this.states.connecting.failState = 'suspended';\n        this.notifyState({ state: 'suspended' });\n      }\n    }, this.connectionStateTtl);\n  }\n\n  checkSuspendTimer(state: string): void {\n    if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting') this.cancelSuspendTimer();\n  }\n\n  cancelSuspendTimer(): void {\n    this.states.connecting.failState = 'disconnected';\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer as number);\n      this.suspendTimer = null;\n    }\n  }\n\n  startRetryTimer(interval: number): void {\n    this.retryTimer = setTimeout(() => {\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');\n      this.retryTimer = null;\n      this.requestState({ state: 'connecting' });\n    }, interval);\n  }\n\n  cancelRetryTimer(): void {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\n      this.retryTimer = null;\n    }\n  }\n\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'ConnectionManager WebSocket slow timer',\n        'checking connectivity',\n      );\n      this.checkWsConnectivity()\n        .then(() => {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MINOR,\n            'ConnectionManager WebSocket slow timer',\n            'ws connectivity check succeeded',\n          );\n          this.wsCheckResult = true;\n        })\n        .catch(() => {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MAJOR,\n            'ConnectionManager WebSocket slow timer',\n            'ws connectivity check failed',\n          );\n          this.wsCheckResult = false;\n        });\n      if (this.realtime.http.checkConnectivity) {\n        Utils.whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            Logger.logAction(\n              this.logger,\n              Logger.LOG_MAJOR,\n              'ConnectionManager WebSocket slow timer',\n              'http connectivity check failed',\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: 'disconnected',\n              error: new ErrorInfo('Unable to connect (network unreachable)', 80003, 404),\n            });\n          } else {\n            Logger.logAction(\n              this.logger,\n              Logger.LOG_MINOR,\n              'ConnectionManager WebSocket slow timer',\n              'http connectivity check succeeded',\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n\n  startWebSocketGiveUpTimer(transportParams: TransportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      if (!this.wsCheckResult) {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'ConnectionManager WebSocket give up timer',\n          'websocket connection took more than 10s; ' + (this.baseTransport ? 'trying base transport' : ''),\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          this.proposedTransport?.dispose();\n          this.pendingTransport?.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          // if we don't have a base transport to fallback to, just let the websocket connection attempt time out\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MAJOR,\n            'ConnectionManager WebSocket give up timer',\n            'websocket connectivity appears to be unavailable but no other transports to try',\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n\n  notifyState(indicated: ConnectionState): void {\n    const state = indicated.state;\n\n    /* We retry immediately if:\n     * - something disconnects us while we're connected, or\n     * - a viable (but not yet active) transport fails due to a token error (so\n     *   this.errorReason will be set, and startConnect will do a forced\n     *   authorize). If this.errorReason is already set (to a token error),\n     *   then there has been at least one previous attempt to connect that also\n     *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait\n     *   before trying again */\n    const retryImmediately =\n      state === 'disconnected' &&\n      (this.state === this.states.connected ||\n        indicated.retryImmediately ||\n        (this.state === this.states.connecting &&\n          indicated.error &&\n          Auth.isTokenErr(indicated.error) &&\n          !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))));\n\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.notifyState()',\n      'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''),\n    );\n    /* do nothing if we're already in the indicated state */\n    if (state == this.state.state) return;\n\n    /* kill timers (possibly excepting suspend timer depending on the notified\n     * state), as these are superseded by this notification */\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n\n    if (state === 'suspended' || state === 'connected') {\n      this.disconnectedRetryCount = 0;\n    }\n\n    /* do nothing if we're unable to move from the current state */\n    if (this.state.terminal) return;\n\n    /* process new state */\n    const newState = this.states[indicated.state];\n\n    let retryDelay = newState.retryDelay;\n    if (newState.state === 'disconnected') {\n      this.disconnectedRetryCount++;\n      retryDelay = Utils.getRetryTime(newState.retryDelay as number, this.disconnectedRetryCount);\n    }\n\n    const change = new ConnectionStateChange(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\n    );\n\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: 'connecting' });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1000) {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MICRO,\n          'ConnectionManager.notifyState()',\n          'Last reconnect attempt was only ' +\n            sinceLast +\n            'ms ago, waiting another ' +\n            (1000 - sinceLast) +\n            'ms before trying again',\n        );\n        setTimeout(autoReconnect, 1000 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === 'disconnected' || state === 'suspended') {\n      this.startRetryTimer(retryDelay as number);\n    }\n\n    /* If going into disconnect/suspended (and not retrying immediately), or a\n     * terminal state, ensure there are no orphaned transports hanging around. */\n    if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {\n      /* Wait till the next tick so the connection state change is enacted,\n       * so aborting transports doesn't trigger redundant state changes */\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n\n    if (state == 'connected' && !this.activeProtocol) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_ERROR,\n        'ConnectionManager.notifyState()',\n        'Broken invariant: attempted to go into connected state, but there is no active protocol',\n      );\n    }\n\n    /* implement the change and notify */\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason as ErrorInfo); // RTN7c\n    }\n  }\n\n  requestState(request: any): void {\n    const state = request.state;\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'ConnectionManager.requestState()',\n      'requested state: ' + state + '; current state: ' + this.state.state,\n    );\n    if (state == this.state.state) return; /* silently do nothing */\n\n    /* kill running timers, as this request supersedes them */\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    /* for suspend timer check rather than cancel -- eg requesting a connecting\n     * state should not reset the suspend timer */\n    this.checkSuspendTimer(state);\n\n    if (state == 'connecting' && this.state.state == 'connected') return;\n    if (state == 'closing' && this.state.state == 'closed') return;\n\n    const newState = this.states[state],\n      change = new ConnectionStateChange(\n        this.state.state,\n        newState.state,\n        null,\n        request.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\n      );\n\n    this.enactStateChange(change);\n\n    if (state == 'connecting') {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == 'closing') {\n      this.closeImpl();\n    }\n  }\n\n  startConnect(): void {\n    if (this.state !== this.states.connecting) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'ConnectionManager.startConnect()',\n        'Must be in connecting state to connect, but was ' + this.state.state,\n      );\n      return;\n    }\n\n    const auth = this.realtime.auth;\n\n    /* The point of the connectCounter mechanism is to ensure that the\n     * connection procedure can be cancelled. We want disconnectAllTransports\n     * to be able to stop any in-progress connection, even before it gets to\n     * the stage of having a pending (or even a proposed) transport that it can\n     * dispose() of. So we check that it's still current after any async stage,\n     * up until the stage that is synchronous with instantiating a transport */\n    const connectCount = ++this.connectCounter;\n\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams: TransportParams) => {\n        if (transportParams.mode === 'recover' && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n\n    if (auth.method === 'basic') {\n      connect();\n    } else {\n      const authCb = (err: ErrorInfo | null) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo)) {\n        /* Force a refetch of a new token */\n        Utils.whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        Utils.whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams: TransportParams, connectCount: number): void {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      /* Only keep trying as long as in the 'connecting' state (or 'connected'\n       * for upgrading). Any operation can put us into 'disconnected' to cancel\n       * connection attempts and wait before retrying, or 'failed' to fail. */\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MINOR,\n        'ConnectionManager.connectImpl()',\n        'Must be in connecting state to connect, but was ' + state,\n      );\n      return;\n    }\n\n    const transportPreference = this.getTransportPreference();\n\n    // If transport preference is for a non-ws transport but websocket is now available, unpersist the preference for next time\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity()\n        .then(() => {\n          this.unpersistTransportPreference();\n          if (this.state === this.states.connecting) {\n            Logger.logAction(\n              this.logger,\n\n              Logger.LOG_MINOR,\n              'ConnectionManager.connectImpl():',\n              'web socket connectivity available, cancelling connection attempt with ' + this.baseTransport,\n            );\n            this.disconnectAllTransports();\n            this.connectWs(transportParams, ++this.connectCounter);\n          }\n        })\n        .catch(noop);\n    }\n\n    if (\n      (transportPreference && transportPreference === this.baseTransport) ||\n      (this.baseTransport && !this.webSocketTransportAvailable)\n    ) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams: TransportParams, connectCount: number) {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.connectWs()');\n    this.wsCheckResult = null;\n    this.abandonedWebSocket = false;\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n\n    this.tryTransportWithFallbacks('web_socket', transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n\n  connectBase(transportParams: TransportParams, connectCount: number) {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.connectBase()');\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: 'disconnected',\n        error: new ErrorInfo('No transports left to try', 80000, 404),\n      });\n    }\n  }\n\n  tryTransportWithFallbacks(\n    transportName: TransportName,\n    transportParams: TransportParams,\n    ws: boolean,\n    connectCount: number,\n    shouldContinue: () => boolean,\n  ): void {\n    Logger.logAction(\n      this.logger,\n\n      Logger.LOG_MICRO,\n      'ConnectionManager.tryTransportWithFallbacks()',\n      transportName,\n    );\n    const giveUp = (err: IPartialErrorInfo) => {\n      this.notifyState({ state: this.states.connecting.failState as string, error: err });\n    };\n\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\n\n    const hostAttemptCb = (fatal: boolean, transport: Transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n\n    /* first try to establish a connection with the priority host with http transport */\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo('Unable to connect (no available host)', 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n\n    /* this is what we'll be doing if the attempt for the main host fails */\n    const tryFallbackHosts = () => {\n      /* if there aren't any fallback hosts, fail */\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo('Unable to connect (and no more fallback hosts to try)', 80003, 404));\n        return;\n      }\n      /* before trying any fallback (or any remaining fallback) we decide if\n       * there is a problem with the ably host, or there is a general connectivity\n       * problem */\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));\n        return;\n      }\n      Utils.whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err?: ErrorInfo | null, connectivity?: boolean) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          /* we know err won't happen but handle it here anyway */\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            /* the internet isn't reachable, so don't try the fallback hosts */\n            giveUp(new ErrorInfo('Unable to connect (network unreachable)', 80003, 404));\n            return;\n          }\n          /* the network is there, so there's a problem with the main host, or\n           * its dns. Try the fallback hosts. We could try them simultaneously but\n           * that would potentially cause a huge spike in load on the load balancer */\n          transportParams.host = Utils.arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        },\n      );\n    };\n\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n\n  closeImpl(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n\n    if (this.pendingTransport) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MICRO,\n        'ConnectionManager.closeImpl()',\n        'Closing pending transport: ' + this.pendingTransport,\n      );\n      this.pendingTransport.close();\n    }\n\n    if (this.activeProtocol) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MICRO,\n        'ConnectionManager.closeImpl()',\n        'Closing active transport: ' + this.activeProtocol.getTransport(),\n      );\n      this.activeProtocol.getTransport().close();\n    }\n\n    /* If there was an active transport, this will probably be\n     * preempted by the notifyState call in deactivateTransport */\n    this.notifyState({ state: 'closed' });\n  }\n\n  onAuthUpdated(tokenDetails: API.TokenDetails, callback: Function): void {\n    switch (this.state.state) {\n      case 'connected': {\n        Logger.logAction(\n          this.logger,\n\n          Logger.LOG_MICRO,\n          'ConnectionManager.onAuthUpdated()',\n          'Sending AUTH message on active transport',\n        );\n\n        /* Do any transport-specific new-token action */\n        const activeTransport = this.activeProtocol?.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n\n        const authMsg = protocolMessageFromValues({\n          action: actions.AUTH,\n          auth: {\n            accessToken: tokenDetails.token,\n          },\n        });\n        this.send(authMsg);\n\n        /* The answer will come back as either a connectiondetails event\n         * (realtime sends a CONNECTED to acknowledge the reauth) or a\n         * statechange to failed */\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange: ConnectionStateChange) => {\n          if (stateChange.current === 'failed') {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once('connectiondetails', successListener);\n        this.on('connectionstate', failureListener);\n        break;\n      }\n\n      case 'connecting':\n        Logger.logAction(\n          this.logger,\n\n          Logger.LOG_MICRO,\n          'ConnectionManager.onAuthUpdated()',\n          'Aborting current connection attempts in order to start again with the new auth details',\n        );\n        this.disconnectAllTransports();\n      /* fallthrough to add statechange listener */\n\n      default: {\n        Logger.logAction(\n          this.logger,\n\n          Logger.LOG_MICRO,\n          'ConnectionManager.onAuthUpdated()',\n          'Connection state is ' + this.state.state + '; waiting until either connected or failed',\n        );\n        const listener = (stateChange: ConnectionStateChange) => {\n          switch (stateChange.current) {\n            case 'connected':\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case 'failed':\n            case 'closed':\n            case 'suspended':\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              /* ignore till we get either connected or failed */\n              break;\n          }\n        };\n        this.on('connectionstate', listener);\n        if (this.state.state === 'connecting') {\n          /* can happen if in the connecting state but no transport was pending\n           * yet, so disconnectAllTransports did not trigger a disconnected state */\n          this.startConnect();\n        } else {\n          this.requestState({ state: 'connecting' });\n        }\n      }\n    }\n  }\n\n  disconnectAllTransports(): void {\n    Logger.logAction(\n      this.logger,\n\n      Logger.LOG_MINOR,\n      'ConnectionManager.disconnectAllTransports()',\n      'Disconnecting all transports',\n    );\n\n    /* This will prevent any connection procedure in an async part of one of its early stages from continuing */\n    this.connectCounter++;\n\n    if (this.pendingTransport) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MICRO,\n        'ConnectionManager.disconnectAllTransports()',\n        'Disconnecting pending transport: ' + this.pendingTransport,\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n\n    if (this.proposedTransport) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MICRO,\n        'ConnectionManager.disconnectAllTransports()',\n        'Disconnecting proposed transport: ' + this.pendingTransport,\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n\n    if (this.activeProtocol) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MICRO,\n        'ConnectionManager.disconnectAllTransports()',\n        'Disconnecting active transport: ' + this.activeProtocol.getTransport(),\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n    /* No need to notify state disconnected; disconnecting the active transport\n     * will have that effect */\n  }\n\n  /******************\n   * event queueing\n   ******************/\n\n  send(msg: ProtocolMessage, queueEvent?: boolean, callback?: ErrCallback): void {\n    callback = callback || noop;\n    const state = this.state;\n\n    if (state.sendEvents) {\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.send()', 'sending event');\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.send()', err);\n      callback(this.errorReason || new ErrorInfo(err, 90000, 400));\n      return;\n    }\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MICRO,\n        'ConnectionManager.send()',\n        'queueing msg; ' + stringifyProtocolMessage(msg, this.realtime._RealtimePresence),\n      );\n    }\n    this.queue(msg, callback);\n  }\n\n  sendImpl(pendingMessage: PendingMessage): void {\n    const msg = pendingMessage.message;\n    /* If have already attempted to send this, resend with the same msgSerial,\n     * so Ably can dedup if the previous send succeeded */\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      (this.activeProtocol as Protocol).send(pendingMessage);\n    } catch (e) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_ERROR,\n        'ConnectionManager.sendImpl()',\n        'Unexpected exception in transport.send(): ' + (e as Error).stack,\n      );\n    }\n  }\n\n  queue(msg: ProtocolMessage, callback: ErrCallback): void {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');\n    const lastQueued = this.queuedMessages.last();\n    const maxSize = this.options.maxMessageSize;\n    /* If have already attempted to send a message, don't merge more messages\n     * into it, as if the previous send actually succeeded and realtime ignores\n     * the dup, they'll be lost */\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\n      if (!lastQueued.merged) {\n        lastQueued.callback = Multicaster.create(this.logger, [lastQueued.callback]);\n        lastQueued.merged = true;\n      }\n      (lastQueued.callback as MulticasterInstance<void>).push(callback);\n    } else {\n      this.queuedMessages.push(new PendingMessage(msg, callback));\n    }\n  }\n\n  sendQueuedMessages(): void {\n    Logger.logAction(\n      this.logger,\n\n      Logger.LOG_MICRO,\n      'ConnectionManager.sendQueuedMessages()',\n      'sending ' + this.queuedMessages.count() + ' queued messages',\n    );\n    let pendingMessage;\n    while ((pendingMessage = this.queuedMessages.shift())) this.sendImpl(pendingMessage);\n  }\n\n  queuePendingMessages(pendingMessages: Array<PendingMessage>): void {\n    if (pendingMessages && pendingMessages.length) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_MICRO,\n        'ConnectionManager.queuePendingMessages()',\n        'queueing ' + pendingMessages.length + ' pending messages',\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n\n  failQueuedMessages(err: ErrorInfo): void {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      Logger.logAction(\n        this.logger,\n\n        Logger.LOG_ERROR,\n        'ConnectionManager.failQueuedMessages()',\n        'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err),\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n\n  onChannelMessage(message: ProtocolMessage, transport: Transport): void {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n\n  private processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift()!;\n      this.processChannelMessage(pendingChannelMessage.message)\n        .catch((err) => {\n          Logger.logAction(\n            this.logger,\n\n            Logger.LOG_ERROR,\n            'ConnectionManager.processNextPendingChannelMessage() received error ',\n            err,\n          );\n        })\n        .finally(() => {\n          this.pendingChannelMessagesState.isProcessing = false;\n          this.processNextPendingChannelMessage();\n        });\n    }\n  }\n\n  private async processChannelMessage(message: ProtocolMessage) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n\n  async ping(): Promise<number> {\n    if (this.state.state !== 'connected') {\n      throw new ErrorInfo('Unable to ping service; not connected', 40000, 400);\n    }\n\n    const transport = this.activeProtocol?.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);\n\n    const pingStart = Date.now();\n    const id = Utils.cheapRandStr();\n\n    return Utils.withTimeoutAsync<number>(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId: string) => {\n          if (responseId === id) {\n            transport.off('heartbeat', onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on('heartbeat', onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      'Timeout waiting for heartbeat response',\n    );\n  }\n\n  abort(error: ErrorInfo): void {\n    (this.activeProtocol as Protocol).getTransport().fail(error);\n  }\n\n  getTransportPreference(): TransportName {\n    return this.transportPreference || (haveWebStorage() && Platform.WebStorage?.get?.(transportPreferenceName));\n  }\n\n  persistTransportPreference(transport: Transport): void {\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      Platform.WebStorage?.set?.(transportPreferenceName, transport.shortName);\n    }\n  }\n\n  unpersistTransportPreference(): void {\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      Platform.WebStorage?.remove?.(transportPreferenceName);\n    }\n  }\n\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err: ErrorInfo): void {\n    if (err.code === 40171) {\n      /* No way to reauth */\n      this.notifyState({ state: 'failed', error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: 'failed', error: err });\n    } else if (err.statusCode === HttpStatusCodes.Forbidden) {\n      const msg = 'Client configured authentication provider returned 403; failing the connection';\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);\n      this.notifyState({ state: 'failed', error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = 'Client configured authentication provider request failed';\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);\n      this.notifyState({ state: this.state.failState as string, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n\n  onConnectionDetailsUpdate(connectionDetails: Record<string, any>, transport: Transport): void {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);\n        /* Errors setting the clientId are fatal to the connection */\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit('connectiondetails', connectionDetails);\n  }\n\n  checkWsConnectivity() {\n    const wsConnectivityCheckUrl = this.options.wsConnectivityCheckUrl || Defaults.wsConnectivityCheckUrl;\n    const ws = new Platform.Config.WebSocket(wsConnectivityCheckUrl);\n    return new Promise<void>((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || 'ably-connection-recovery';\n  }\n\n  getSessionRecoverData() {\n    return haveSessionStorage() && Platform.WebStorage?.getSession?.(this.sessionRecoveryName());\n  }\n  setSessionRecoverData(value: any) {\n    return haveSessionStorage() && Platform.WebStorage?.setSession?.(this.sessionRecoveryName(), value);\n  }\n  clearSessionRecoverData() {\n    return haveSessionStorage() && Platform.WebStorage?.removeSession?.(this.sessionRecoveryName());\n  }\n}\n\nexport default ConnectionManager;\n\nexport interface TransportStorage {\n  supportedTransports: Partial<Record<TransportName, TransportCtor>>;\n}\n", "import EventEmitter from '../util/eventemitter';\nimport ConnectionManager from '../transport/connectionmanager';\nimport Logger from '../util/logger';\nimport ConnectionStateChange from './connectionstatechange';\nimport ErrorInfo from '../types/errorinfo';\nimport { NormalisedClientOptions } from '../../types/ClientOptions';\nimport BaseRealtime from './baserealtime';\nimport Platform from 'common/platform';\n\nclass Connection extends EventEmitter {\n  ably: BaseRealtime;\n  connectionManager: ConnectionManager;\n  state: string;\n  key?: string;\n  id?: string;\n  errorReason: ErrorInfo | null;\n\n  constructor(ably: BaseRealtime, options: NormalisedClientOptions) {\n    super(ably.logger);\n    this.ably = ably;\n    this.connectionManager = new ConnectionManager(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = undefined;\n    this.id = undefined;\n    this.errorReason = null;\n\n    this.connectionManager.on('connectionstate', (stateChange: ConnectionStateChange) => {\n      const state = (this.state = stateChange.current as string);\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on('update', (stateChange: ConnectionStateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit('update', stateChange);\n      });\n    });\n  }\n\n  whenState = ((state: string) => {\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\n  }) as any;\n\n  connect(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.connect()', '');\n    this.connectionManager.requestState({ state: 'connecting' });\n  }\n\n  async ping(): Promise<number> {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.ping()', '');\n    return this.connectionManager.ping();\n  }\n\n  close(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);\n    this.connectionManager.requestState({ state: 'closing' });\n  }\n\n  get recoveryKey(): string | null {\n    this.logger.deprecationWarning(\n      'The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.',\n    );\n    return this.createRecoveryKey();\n  }\n\n  createRecoveryKey(): string | null {\n    return this.connectionManager.createRecoveryKey();\n  }\n}\n\nexport default Connection;\n", "import ErrorInfo from '../types/errorinfo';\n\nclass ChannelStateChange {\n  previous: string;\n  current: string;\n  resumed?: boolean;\n  reason?: string | Error | ErrorInfo;\n  hasBacklog?: boolean;\n\n  constructor(\n    previous: string,\n    current: string,\n    resumed?: boolean,\n    hasBacklog?: boolean,\n    reason?: string | Error | ErrorInfo | null,\n  ) {\n    this.previous = previous;\n    this.current = current;\n    if (current === 'attached') {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason) this.reason = reason;\n  }\n}\n\nexport default ChannelStateChange;\n", "import { actions, channelModes } from '../types/protocolmessagecommon';\nimport ProtocolMessage, { fromValues as protocolMessageFromValues } from '../types/protocolmessage';\nimport EventEmitter from '../util/eventemitter';\nimport * as Utils from '../util/utils';\nimport Logger from '../util/logger';\nimport RealtimePresence from './realtimepresence';\nimport { EncodingDecodingContext, CipherOptions, populateFieldsFromParent } from '../types/basemessage';\nimport Message, { WireMessage, getMessagesSize, encodeArray as encodeMessagesArray } from '../types/message';\nimport ChannelStateChange from './channelstatechange';\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\nimport ConnectionErrors from '../transport/connectionerrors';\nimport * as API from '../../../../ably';\nimport ConnectionManager from '../transport/connectionmanager';\nimport ConnectionStateChange from './connectionstatechange';\nimport { ErrCallback, StandardCallback } from '../../types/utils';\nimport BaseRealtime from './baserealtime';\nimport { ChannelOptions } from '../../types/channel';\nimport { normaliseChannelOptions } from '../util/defaults';\nimport { PaginatedResult } from './paginatedresource';\nimport type { PushChannel } from 'plugins/push';\nimport type { WirePresenceMessage } from '../types/presencemessage';\n\ninterface RealtimeHistoryParams {\n  start?: number;\n  end?: number;\n  direction?: string;\n  limit?: number;\n  untilAttach?: boolean;\n  from_serial?: string;\n}\n\nconst noop = function () {};\n\nfunction validateChannelOptions(options?: API.ChannelOptions) {\n  if (options && 'params' in options && !Utils.isObject(options.params)) {\n    return new ErrorInfo('options.params must be an object', 40000, 400);\n  }\n  if (options && 'modes' in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo('options.modes must be an array', 40000, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (\n        !currentMode ||\n        typeof currentMode !== 'string' ||\n        !channelModes.includes(String.prototype.toUpperCase.call(currentMode))\n      ) {\n        return new ErrorInfo('Invalid channel mode: ' + currentMode, 40000, 400);\n      }\n    }\n  }\n}\n\nclass RealtimeChannel extends EventEmitter {\n  name: string;\n  channelOptions: ChannelOptions;\n  client: BaseRealtime;\n  private _presence: RealtimePresence | null;\n  get presence(): RealtimePresence {\n    if (!this._presence) {\n      Utils.throwMissingPluginError('RealtimePresence');\n    }\n    return this._presence;\n  }\n  connectionManager: ConnectionManager;\n  state: API.ChannelState;\n  subscriptions: EventEmitter;\n  filteredSubscriptions?: Map<API.messageCallback<Message>, Map<API.MessageFilter, API.messageCallback<Message>[]>>;\n  syncChannelSerial?: string | null;\n  properties: {\n    attachSerial: string | null | undefined;\n    channelSerial: string | null | undefined;\n  };\n  errorReason: ErrorInfo | string | null;\n  _mode?: null | number;\n  _attachResume: boolean;\n  _decodingContext: EncodingDecodingContext;\n  _lastPayload: {\n    messageId?: string | null;\n    protocolMessageChannelSerial?: string | null;\n    decodeFailureRecoveryInProgress: null | boolean;\n  };\n  _allChannelChanges: EventEmitter;\n  params?: Record<string, any>;\n  modes: string[] | undefined;\n  stateTimer?: number | NodeJS.Timeout | null;\n  retryTimer?: number | NodeJS.Timeout | null;\n  retryCount: number = 0;\n  _push?: PushChannel;\n\n  constructor(client: BaseRealtime, name: string, options?: API.ChannelOptions) {\n    super(client.logger);\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    this.connectionManager = client.connection.connectionManager;\n    this.state = 'initialized';\n    this.subscriptions = new EventEmitter(this.logger);\n    this.syncChannelSerial = undefined;\n    this.properties = {\n      attachSerial: undefined,\n      channelSerial: undefined,\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._mode = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: undefined,\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null,\n    };\n    /* Only differences between this and the public event emitter is that this emits an\n     * update event for all ATTACHEDs, whether resumed or not */\n    this._allChannelChanges = new EventEmitter(this.logger);\n\n    if (client.options.plugins?.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n  }\n\n  get push() {\n    if (!this._push) {\n      Utils.throwMissingPluginError('Push');\n    }\n    return this._push;\n  }\n\n  invalidStateError(): ErrorInfo {\n    return new ErrorInfo(\n      'Channel operation failed as channel state is ' + this.state,\n      90001,\n      400,\n      this.errorReason || undefined,\n    );\n  }\n\n  static processListenerArgs(args: unknown[]): any[] {\n    /* [event], listener */\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === 'function') {\n      args.unshift(null);\n    }\n    return args;\n  }\n\n  async setOptions(options?: API.ChannelOptions): Promise<void> {\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, this.logger, options);\n    if (this._decodingContext) this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      /* This does not just do _attach(true, null, callback) because that would put us\n       * into the 'attaching' state until we receive the new attached, which is\n       * conceptually incorrect: we are still attached, we just have a pending request to\n       * change some channel params. Per RTL17 going into the attaching state would mean\n       * rejecting messages until we have confirmation that the options have changed,\n       * which would unnecessarily lose message continuity. */\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        // Ignore 'attaching' -- could be just due to to a resume & reattach, should not\n        // call back setOptions until we're definitely attached with the new options (or\n        // else in a terminal state)\n        this._allChannelChanges.once(\n          ['attached', 'update', 'detached', 'failed'],\n          function (this: { event: string }, stateChange: ConnectionStateChange) {\n            switch (this.event) {\n              case 'update':\n              case 'attached':\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          },\n        );\n      });\n    }\n  }\n\n  _shouldReattachToSetOptions(options: API.ChannelOptions | undefined, prevOptions: API.ChannelOptions) {\n    if (!(this.state === 'attached' || this.state === 'attaching')) {\n      return false;\n    }\n    if (options?.params) {\n      // Don't check against the `agent` param - it isn't returned in the ATTACHED message\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n\n      if (!Utils.shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options?.modes) {\n      if (!prevOptions.modes || !Utils.arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async publish(...args: any[]): Promise<void> {\n    let messages: Message[];\n    let argCount = args.length;\n\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (argCount == 1) {\n      if (Utils.isObject(args[0])) {\n        messages = [Message.fromValues(args[0])];\n      } else if (Array.isArray(args[0])) {\n        messages = Message.fromValuesArray(args[0]);\n      } else {\n        throw new ErrorInfo(\n          'The single-argument form of publish() expects a message object or an array of message objects',\n          40013,\n          400,\n        );\n      }\n    } else {\n      messages = [Message.fromValues({ name: args[0], data: args[1] })];\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    // TODO get rid of CipherOptions type assertion, indicates channeloptions types are broken\n    const wireMessages = await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\n    /* RSL1i */\n    const size = getMessagesSize(wireMessages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        'Maximum size of messages that can be published at once exceeded ( was ' +\n          size +\n          ' bytes; limit is ' +\n          maxMessageSize +\n          ' bytes)',\n        40009,\n        400,\n      );\n    }\n    return new Promise((resolve, reject) => {\n      this._publish(wireMessages, (err) => (err ? reject(err) : resolve()));\n    });\n  }\n\n  _publish(messages: Array<WireMessage>, callback: ErrCallback) {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);\n    const state = this.state;\n    switch (state) {\n      case 'failed':\n      case 'suspended':\n        callback(ErrorInfo.fromValues(this.invalidStateError()));\n        break;\n      default: {\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MICRO,\n          'RealtimeChannel.publish()',\n          'sending message; channel state is ' + state,\n        );\n        const msg = new ProtocolMessage();\n        msg.action = actions.MESSAGE;\n        msg.channel = this.name;\n        msg.messages = messages;\n        this.sendMessage(msg, callback);\n        break;\n      }\n    }\n  }\n\n  onEvent(messages: Array<any>): void {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n\n  async attach(): Promise<ChannelStateChange | null> {\n    if (this.state === 'attached') {\n      return null;\n    }\n\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => (err ? reject(err) : resolve(result!)));\n    });\n  }\n\n  _attach(\n    forceReattach: boolean,\n    attachReason: ErrorInfo | null,\n    callback?: StandardCallback<ChannelStateChange>,\n  ): void {\n    if (!callback) {\n      callback = (err?: ErrorInfo | null) => {\n        if (err) {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_ERROR,\n            'RealtimeChannel._attach()',\n            'Channel attach failed: ' + err.toString(),\n          );\n        }\n      };\n    }\n\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n\n    if (this.state !== 'attaching' || forceReattach) {\n      this.requestState('attaching', attachReason);\n    }\n\n    this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\n      switch (this.event) {\n        case 'attached':\n          callback?.(null, stateChange);\n          break;\n        case 'detached':\n        case 'suspended':\n        case 'failed':\n          callback?.(\n            stateChange.reason ||\n              connectionManager.getError() ||\n              new ErrorInfo('Unable to attach; reason unknown; state = ' + this.event, 90000, 500),\n          );\n          break;\n        case 'detaching':\n          callback?.(new ErrorInfo('Attach request superseded by a subsequent detach request', 90000, 409));\n          break;\n      }\n    });\n  }\n\n  attachImpl(): void {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');\n    const attachMsg = protocolMessageFromValues({\n      action: actions.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial,\n    });\n    if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes) as API.ChannelMode[]);\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag('ATTACH_RESUME');\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg, noop);\n  }\n\n  async detach(): Promise<void> {\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    switch (this.state) {\n      case 'suspended':\n        this.notifyState('detached');\n        return;\n      case 'detached':\n        return;\n      case 'failed':\n        throw new ErrorInfo('Unable to detach; channel state = failed', 90001, 400);\n      default:\n        this.requestState('detaching');\n      // eslint-disable-next-line no-fallthrough\n      case 'detaching':\n        return new Promise((resolve, reject) => {\n          this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\n            switch (this.event) {\n              case 'detached':\n                resolve();\n                break;\n              case 'attached':\n              case 'suspended':\n              case 'failed':\n                reject(\n                  stateChange.reason ||\n                    connectionManager.getError() ||\n                    new ErrorInfo('Unable to detach; reason unknown; state = ' + this.event, 90000, 500),\n                );\n                break;\n              case 'attaching':\n                reject(new ErrorInfo('Detach request superseded by a subsequent attach request', 90000, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n\n  detachImpl(callback?: ErrCallback): void {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');\n    const msg = protocolMessageFromValues({ action: actions.DETACH, channel: this.name });\n    this.sendMessage(msg, callback || noop);\n  }\n\n  async subscribe(...args: unknown[] /* [event], listener */): Promise<ChannelStateChange | null> {\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\n\n    if (this.state === 'failed') {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n\n    // Filtered\n    if (event && typeof event === 'object' && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n\n    return this.attach();\n  }\n\n  unsubscribe(...args: unknown[] /* [event], listener */): void {\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\n\n    // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)\n    if ((typeof event === 'object' && !listener) || this.filteredSubscriptions?.has(listener)) {\n      this.client._FilteredSubscriptions\n        .getAndDeleteFilteredSubscriptions(this, event, listener)\n        .forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n\n    this.subscriptions.off(event, listener);\n  }\n\n  sync(): void {\n    /* check preconditions */\n    switch (this.state) {\n      case 'initialized':\n      case 'detaching':\n      case 'detached':\n        throw new PartialErrorInfo('Unable to sync to channel; not attached', 40000);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n\n    /* send sync request */\n    const syncMessage = protocolMessageFromValues({ action: actions.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n\n  sendMessage(msg: ProtocolMessage, callback?: ErrCallback): void {\n    this.connectionManager.send(msg, this.client.options.queueMessages, callback);\n  }\n\n  sendPresence(presence: WirePresenceMessage[], callback?: ErrCallback): void {\n    const msg = protocolMessageFromValues({\n      action: actions.PRESENCE,\n      channel: this.name,\n      presence: presence,\n    });\n    this.sendMessage(msg, callback);\n  }\n\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message: ProtocolMessage): Promise<void> {\n    if (\n      message.action === actions.ATTACHED ||\n      message.action === actions.MESSAGE ||\n      message.action === actions.PRESENCE\n    ) {\n      // RTL15b\n      this.setChannelSerial(message.channelSerial);\n    }\n\n    let syncChannelSerial,\n      isSync = false;\n    switch (message.action) {\n      case actions.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = (message as any).params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;\n        const resumed = message.hasFlag('RESUMED');\n        const hasPresence = message.hasFlag('HAS_PRESENCE');\n        const hasBacklog = message.hasFlag('HAS_BACKLOG');\n        if (this.state === 'attached') {\n          if (!resumed) {\n            /* On a loss of continuity, the presence set needs to be re-synced */\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n          }\n          const change = new ChannelStateChange(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit('update', change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit('update', change);\n          }\n        } else if (this.state === 'detaching') {\n          /* RTL5i: re-send DETACH and remain in the 'detaching' state */\n          this.checkPendingState();\n        } else {\n          this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);\n        }\n        break;\n      }\n\n      case actions.DETACHED: {\n        const detachErr = message.error\n          ? ErrorInfo.fromValues(message.error)\n          : new ErrorInfo('Channel detached', 90001, 404);\n        if (this.state === 'detaching') {\n          this.notifyState('detached', detachErr);\n        } else if (this.state === 'attaching') {\n          /* Only retry immediately if we were previously attached. If we were\n           * attaching, go into suspended, fail messages, and wait a few seconds\n           * before retrying */\n          this.notifyState('suspended', detachErr);\n        } else if (this.state === 'attached' || this.state === 'suspended') {\n          // RTL13a\n          this.requestState('attaching', detachErr);\n        }\n        // else no action (detached in initialized, detached, or failed state is a noop)\n        break;\n      }\n\n      case actions.SYNC:\n        /* syncs can have channelSerials, but might not if the sync is one page long */\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        /* syncs can happen on channels with no presence data as part of connection\n         * resuming, in which case protocol message has no presence property */\n        if (!message.presence) break;\n      // eslint-disable-next-line no-fallthrough\n      case actions.PRESENCE: {\n        if (!message.presence) {\n          break;\n        }\n\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._presence) {\n          const presenceMessages = await Promise.all(\n            message.presence.map((wpm) => {\n              return wpm.decode(options, this.logger);\n            }),\n          );\n\n          this._presence.setPresence(presenceMessages, isSync, syncChannelSerial as any);\n        }\n        break;\n      }\n      case actions.MESSAGE: {\n        //RTL17\n        if (this.state !== 'attached') {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_MAJOR,\n            'RealtimeChannel.processMessage()',\n            'Message \"' +\n              message.id +\n              '\" skipped as this channel \"' +\n              this.name +\n              '\" state is not \"attached\" (state is \"' +\n              this.state +\n              '\").',\n          );\n          return;\n        }\n\n        populateFieldsFromParent(message);\n\n        const encoded = message.messages!,\n          firstMessage = encoded[0],\n          lastMessage = encoded[encoded.length - 1],\n          channelSerial = message.channelSerial;\n\n        if (\n          firstMessage.extras &&\n          firstMessage.extras.delta &&\n          firstMessage.extras.delta.from !== this._lastPayload.messageId\n        ) {\n          const msg =\n            'Delta message decode failure - previous message not available for message \"' +\n            message.id +\n            '\" on this channel \"' +\n            this.name +\n            '\".';\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n\n        let messages: Message[] = [];\n        for (let i = 0; i < encoded.length; i++) {\n          const { decoded, err } = await encoded[i].decodeWithErr(this._decodingContext, this.logger);\n          messages[i] = decoded;\n\n          if (err) {\n            switch (err.code) {\n              case 40018:\n                /* decode failure */\n                this._startDecodeFailureRecovery(err);\n                return;\n\n              case 40019: /* No vcdiff plugin passed in - no point recovering, give up */\n              case 40021:\n                /* Browser does not support deltas, similarly no point recovering */\n                this.notifyState('failed', err);\n                return;\n\n              default:\n              // do nothing, continue decoding\n            }\n          }\n        }\n\n        for (let i = 0; i < messages.length; i++) {\n          const msg = messages[i];\n          if (channelSerial && !msg.version) {\n            msg.version = channelSerial + ':' + i.toString().padStart(3, '0');\n          }\n        }\n\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n\n      case actions.ERROR: {\n        /* there was a channel-specific error */\n        const err = message.error as ErrorInfo;\n        if (err && err.code == 80016) {\n          /* attach/detach operation attempted on superseded transport handle */\n          this.checkPendingState();\n        } else {\n          this.notifyState('failed', ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n\n      default:\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_ERROR,\n          'RealtimeChannel.processMessage()',\n          'Fatal protocol error: unrecognised action (' + message.action + ')',\n        );\n        this.connectionManager.abort(ConnectionErrors.unknownChannelErr());\n    }\n  }\n\n  _startDecodeFailureRecovery(reason: ErrorInfo): void {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MAJOR,\n        'RealtimeChannel.processMessage()',\n        'Starting decode failure recovery process.',\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n\n  onAttached(): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'RealtimeChannel.onAttached',\n      'activating channel; name = ' + this.name,\n    );\n  }\n\n  notifyState(\n    state: API.ChannelState,\n    reason?: ErrorInfo | null,\n    resumed?: boolean,\n    hasPresence?: boolean,\n    hasBacklog?: boolean,\n  ): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'RealtimeChannel.notifyState',\n      'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state,\n    );\n    this.clearStateTimer();\n\n    // RTP5a1\n    if (['detached', 'suspended', 'failed'].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (state === 'suspended' && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new ChannelStateChange(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? '; reason: ' + reason : '');\n    if (state === 'failed') {\n      Logger.logAction(this.logger, Logger.LOG_ERROR, action, message);\n    } else {\n      Logger.logAction(this.logger, Logger.LOG_MAJOR, action, message);\n    }\n\n    if (state !== 'attaching' && state !== 'suspended') {\n      this.retryCount = 0;\n    }\n\n    /* Note: we don't set inProgress for pending states until the request is actually in progress */\n    if (state === 'attached') {\n      this.onAttached();\n    }\n\n    if (state === 'attached') {\n      this._attachResume = true;\n    } else if (state === 'detaching' || state === 'failed') {\n      this._attachResume = false;\n    }\n\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n\n  requestState(state: API.ChannelState, reason?: ErrorInfo | null): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'RealtimeChannel.requestState',\n      'name = ' + this.name + ', state = ' + state,\n    );\n    this.notifyState(state, reason);\n    /* send the event and await response */\n    this.checkPendingState();\n  }\n\n  checkPendingState(): void {\n    /* if can't send events, do nothing */\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'RealtimeChannel.checkPendingState',\n        'sendEvents is false; state is ' + this.connectionManager.state.state,\n      );\n      return;\n    }\n\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'RealtimeChannel.checkPendingState',\n      'name = ' + this.name + ', state = ' + this.state,\n    );\n    /* Only start the state timer running when actually sending the event */\n    switch (this.state) {\n      case 'attaching':\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case 'detaching':\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case 'attached':\n        /* resume any sync operation that was in progress */\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n\n  timeoutPendingState(): void {\n    switch (this.state) {\n      case 'attaching': {\n        const err = new ErrorInfo('Channel attach timed out', 90007, 408);\n        this.notifyState('suspended', err);\n        break;\n      }\n      case 'detaching': {\n        const err = new ErrorInfo('Channel detach timed out', 90007, 408);\n        this.notifyState('attached', err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n\n  startStateTimerIfNotRunning(): void {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        Logger.logAction(this.logger, Logger.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n\n  clearStateTimer(): void {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n\n  startRetryTimer(): void {\n    if (this.retryTimer) return;\n\n    this.retryCount++;\n    const retryDelay = Utils.getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n\n    this.retryTimer = setTimeout(() => {\n      /* If connection is not connected, just leave in suspended, a reattach\n       * will be triggered once it connects again */\n      if (this.state === 'suspended' && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_MINOR,\n          'RealtimeChannel retry timer expired',\n          'attempting a new attach',\n        );\n        this.requestState('attaching');\n      }\n    }, retryDelay);\n  }\n\n  cancelRetryTimer(): void {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\n      this.retryTimer = null;\n    }\n  }\n\n  history = async function (\n    this: RealtimeChannel,\n    params: RealtimeHistoryParams | null,\n  ): Promise<PaginatedResult<Message>> {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);\n\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\n    const restMixin = this.client.rest.channelMixin;\n\n    if (params && params.untilAttach) {\n      if (this.state !== 'attached') {\n        throw new ErrorInfo('option untilAttach requires the channel to be attached', 40000, 400);\n      }\n      if (!this.properties.attachSerial) {\n        throw new ErrorInfo(\n          'untilAttach was specified and channel is attached, but attachSerial is not defined',\n          40000,\n          400,\n        );\n      }\n      delete params.untilAttach;\n      params.from_serial = this.properties.attachSerial;\n    }\n\n    return restMixin.history(this, params);\n  } as any;\n\n  whenState = ((state: string) => {\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\n  }) as any;\n\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr(): ErrorInfo | null {\n    const s = this.state;\n    if (s === 'initialized' || s === 'detached' || s === 'failed') {\n      return null;\n    }\n    return new ErrorInfo(\n      'Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +\n        s,\n      90001,\n      400,\n    );\n  }\n\n  setChannelSerial(channelSerial?: string | null): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'RealtimeChannel.setChannelSerial()',\n      'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial,\n    );\n\n    // RTP17h: Only update the channel serial if its present (it won't always\n    // be set).\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n\n  async status(): Promise<API.ChannelDetails> {\n    return this.client.rest.channelMixin.status(this);\n  }\n}\n\nfunction omitAgent(channelParams?: API.ChannelParams) {\n  const { agent: _, ...paramsWithoutAgent } = channelParams || {};\n  return paramsWithoutAgent;\n}\n\nexport default RealtimeChannel;\n", "import * as Utils from '../util/utils';\nimport BaseClient from './baseclient';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport Connection from './connection';\nimport RealtimeChannel from './realtimechannel';\nimport ErrorInfo from '../types/errorinfo';\nimport ProtocolMessage from '../types/protocolmessage';\nimport { ChannelOptions } from '../../types/channel';\nimport ClientOptions from '../../types/ClientOptions';\nimport * as API from '../../../../ably';\nimport { ModularPlugins, RealtimePresencePlugin } from './modularplugins';\nimport { TransportNames } from 'common/constants/TransportName';\nimport { TransportImplementations } from 'common/platform';\nimport Defaults from '../util/defaults';\n\n/**\n `BaseRealtime` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRealtime` class exported by the non tree-shakable version.\n */\nclass BaseRealtime extends BaseClient {\n  readonly _RealtimePresence: RealtimePresencePlugin | null;\n  // Extra transport implementations available to this client, in addition to those in Platform.Transports.bundledImplementations\n  readonly _additionalTransportImplementations: TransportImplementations;\n  _channels: any;\n  connection: Connection;\n\n  // internal API to make EventEmitter usable in other SDKs\n  static readonly EventEmitter = EventEmitter;\n\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options?: ClientOptions | string) {\n    super(Defaults.objectifyOptions(options, false, 'BaseRealtime', Logger.defaultLogger));\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime()', '');\n\n    // currently we cannot support using Ably.Realtime instances in Vercel Edge runtime.\n    // this error can be removed after fixing https://github.com/ably/ably-js/issues/1731,\n    // and https://github.com/ably/ably-js/issues/1732\n    // @ts-ignore\n    if (typeof EdgeRuntime === 'string') {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime.` +\n          ` If you are running Vercel Edge functions, please replace your` +\n          ` \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API` +\n          ` instead of the Realtime API. If you are server-rendering your application` +\n          ` in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\"` +\n          ` to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        40000,\n        400,\n      );\n    }\n\n    this._additionalTransportImplementations = BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = this.options.plugins?.RealtimePresence ?? null;\n    this.connection = new Connection(this, this.options);\n    this._channels = new Channels(this);\n    if (this.options.autoConnect !== false) this.connect();\n  }\n\n  private static transportImplementationsFromPlugins(plugins?: ModularPlugins) {\n    const transports: TransportImplementations = {};\n\n    if (plugins?.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins?.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n\n    return transports;\n  }\n\n  get channels() {\n    return this._channels;\n  }\n\n  connect(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.connect()', '');\n    this.connection.connect();\n  }\n\n  close(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.close()', '');\n    this.connection.close();\n  }\n}\n\nclass Channels extends EventEmitter {\n  realtime: BaseRealtime;\n  all: Record<string, RealtimeChannel>;\n\n  constructor(realtime: BaseRealtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = Object.create(null);\n    realtime.connection.connectionManager.on('transport.active', () => {\n      this.onTransportActive();\n    });\n  }\n\n  channelSerials(): { [name: string]: string } {\n    let serials: { [name: string]: string } = {};\n    for (const name of Utils.keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials: { [name: string]: string }) {\n    for (const name of Utils.keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg: ProtocolMessage) {\n    const channelName = msg.channel;\n    if (channelName === undefined) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_ERROR,\n        'Channels.processChannelMessage()',\n        'received event unspecified channel, action = ' + msg.action,\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_ERROR,\n        'Channels.processChannelMessage()',\n        'received event for non-existent channel: ' + channelName,\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === 'attaching' || channel.state === 'detaching') {\n        channel.checkPendingState();\n      } else if (channel.state === 'suspended') {\n        channel._attach(false, null);\n      } else if (channel.state === 'attached') {\n        // Note explicity request the state, channel.attach() would do nothing\n        // as its already attached.\n        channel.requestState('attaching');\n      }\n    }\n  }\n\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState: string, reason: ErrorInfo) {\n    const connectionStateToChannelState: Record<string, API.ChannelState> = {\n      closing: 'detached',\n      closed: 'detached',\n      failed: 'failed',\n      suspended: 'suspended',\n    };\n    const fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];\n    const toChannelState = connectionStateToChannelState[connectionState];\n\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n\n  get(name: string, channelOptions?: ChannelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new RealtimeChannel(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          'Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.',\n          40000,\n          400,\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n\n  getDerived(name: string, deriveOptions: API.DeriveOptions, channelOptions?: ChannelOptions) {\n    if (deriveOptions.filter) {\n      const filter = Utils.toBase64(deriveOptions.filter);\n      const match = Utils.matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name: string) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n}\n\nexport default BaseRealtime;\n", "import * as Utils from '../util/utils';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport PresenceMessage from '../types/presencemessage';\n\nimport type RealtimePresence from './realtimepresence';\n\ntype compFn = (item: PresenceMessage, existing: PresenceMessage) => boolean;\n\nexport interface RealtimePresenceParams {\n  waitForSync?: boolean;\n  clientId?: string;\n  connectionId?: string;\n}\n\nfunction newerThan(item: PresenceMessage, existing: PresenceMessage): boolean {\n  /* RTP2b1: if either is synthesised, compare by timestamp */\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    // RTP2b1a: if equal, prefer the newly-arrived one\n    return (item.timestamp as number) >= (existing.timestamp as number);\n  }\n\n  /* RTP2b2 */\n  const itemOrderings = item.parseId(),\n    existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\n\nexport class PresenceMap extends EventEmitter {\n  map: Record<string, PresenceMessage>;\n  residualMembers: Record<string, PresenceMessage> | null;\n  syncInProgress: boolean;\n  presence: RealtimePresence;\n  memberKey: (item: PresenceMessage) => string;\n  newerThan: compFn;\n\n  constructor(presence: RealtimePresence, memberKey: (item: PresenceMessage) => string, newer: compFn = newerThan) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n    this.newerThan = newer;\n  }\n\n  get(key: string) {\n    return this.map[key];\n  }\n\n  getClient(clientId: string) {\n    const map = this.map,\n      result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != 'absent') result.push(item);\n    }\n    return result;\n  }\n\n  list(params: RealtimePresenceParams) {\n    const map = this.map,\n      clientId = params && params.clientId,\n      connectionId = params && params.connectionId,\n      result = [];\n\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === 'absent') continue;\n      if (clientId && clientId != item.clientId) continue;\n      if (connectionId && connectionId != item.connectionId) continue;\n      result.push(item);\n    }\n    return result;\n  }\n\n  put(item: PresenceMessage) {\n    if (item.action === 'enter' || item.action === 'update') {\n      item = PresenceMessage.fromValues(item);\n      item.action = 'present';\n    }\n    const map = this.map,\n      key = this.memberKey(item);\n    /* we've seen this member, so do not remove it at the end of sync */\n    if (this.residualMembers) delete this.residualMembers[key];\n\n    /* compare the timestamp of the new item with any existing member (or ABSENT witness) */\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n\n  values() {\n    const map = this.map,\n      result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != 'absent') result.push(item);\n    }\n    return result;\n  }\n\n  remove(item: PresenceMessage) {\n    const map = this.map,\n      key = this.memberKey(item);\n    const existingItem = map[key];\n\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n\n    /* RTP2f */\n    if (this.syncInProgress) {\n      item = PresenceMessage.fromValues(item);\n      item.action = 'absent';\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n\n    return !!existingItem;\n  }\n\n  startSync() {\n    const map = this.map,\n      syncInProgress = this.syncInProgress;\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'PresenceMap.startSync()',\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\n    );\n    /* we might be called multiple times while a sync is in progress */\n    if (!this.syncInProgress) {\n      this.residualMembers = Utils.copy(map);\n      this.setInProgress(true);\n    }\n  }\n\n  endSync() {\n    const map = this.map,\n      syncInProgress = this.syncInProgress;\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'PresenceMap.endSync()',\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\n    );\n    if (syncInProgress) {\n      /* we can now strip out the ABSENT members, as we have\n       * received all of the out-of-order sync messages */\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === 'absent') {\n          delete map[memberKey];\n        }\n      }\n      /* any members that were present at the start of the sync,\n       * and have not been seen in sync, can be removed, and leave events emitted */\n      this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers as Record<string, PresenceMessage>));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n\n      /* finish, notifying any waiters */\n      this.setInProgress(false);\n    }\n    this.emit('sync');\n  }\n\n  waitSync(callback: () => void) {\n    const syncInProgress = this.syncInProgress;\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'PresenceMap.waitSync()',\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\n    );\n    if (!syncInProgress) {\n      callback();\n      return;\n    }\n    this.once('sync', callback);\n  }\n\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n\n  setInProgress(inProgress: boolean) {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n}\n", "import * as Utils from '../util/utils';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport PresenceMessage, { WirePresenceMessage } from '../types/presencemessage';\nimport type { CipherOptions } from '../types/basemessage';\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\nimport RealtimeChannel from './realtimechannel';\nimport Multicaster from '../util/multicaster';\nimport ChannelStateChange from './channelstatechange';\nimport { ErrCallback } from '../../types/utils';\nimport { PaginatedResult } from './paginatedresource';\nimport { PresenceMap, RealtimePresenceParams } from './presencemap';\n\ninterface RealtimeHistoryParams {\n  start?: number;\n  end?: number;\n  direction?: string;\n  limit?: number;\n  untilAttach?: boolean;\n  from_serial?: string | null;\n}\n\nfunction getClientId(realtimePresence: RealtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\n\nfunction isAnonymousOrWildcard(realtimePresence: RealtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  /* If not currently connected, we can't assume that we're an anonymous\n   * client, as realtime may inform us of our clientId in the CONNECTED\n   * message. So assume we're not anonymous and leave it to realtime to\n   * return an error if we are */\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === '*') && realtime.connection.state === 'connected';\n}\n\n/* Callback is called only in the event of an error */\nfunction waitAttached(channel: RealtimeChannel, callback: ErrCallback, action: () => void) {\n  switch (channel.state) {\n    case 'attached':\n    case 'suspended':\n      action();\n      break;\n    case 'initialized':\n    case 'detached':\n    case 'detaching':\n    case 'attaching':\n      Utils.whenPromiseSettles(channel.attach(), function (err: Error | null) {\n        if (err) callback(err);\n        else action();\n      });\n      break;\n    default:\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\n  }\n}\n\nclass RealtimePresence extends EventEmitter {\n  channel: RealtimeChannel;\n  pendingPresence: { presence: WirePresenceMessage; callback: ErrCallback }[];\n  syncComplete: boolean;\n  members: PresenceMap;\n  _myMembers: PresenceMap;\n  subscriptions: EventEmitter;\n  name?: string;\n\n  constructor(channel: RealtimeChannel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + ':' + item.connectionId);\n    // RTP17h: Store own members by clientId only.\n    this._myMembers = new PresenceMap(this, (item) => item.clientId!);\n    this.subscriptions = new EventEmitter(this.logger);\n    this.pendingPresence = [];\n  }\n\n  async enter(data: unknown): Promise<void> {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo('clientId must be specified to enter a presence channel', 40012, 400);\n    }\n    return this._enterOrUpdateClient(undefined, undefined, data, 'enter');\n  }\n\n  async update(data: unknown): Promise<void> {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo('clientId must be specified to update presence data', 40012, 400);\n    }\n    return this._enterOrUpdateClient(undefined, undefined, data, 'update');\n  }\n\n  async enterClient(clientId: string, data: unknown): Promise<void> {\n    return this._enterOrUpdateClient(undefined, clientId, data, 'enter');\n  }\n\n  async updateClient(clientId: string, data: unknown): Promise<void> {\n    return this._enterOrUpdateClient(undefined, clientId, data, 'update');\n  }\n\n  async _enterOrUpdateClient(\n    id: string | undefined,\n    clientId: string | undefined,\n    data: unknown,\n    action: string,\n  ): Promise<void> {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'RealtimePresence.' + action + 'Client()',\n      'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)),\n    );\n\n    const presence = PresenceMessage.fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions as CipherOptions);\n\n    switch (channel.state) {\n      case 'attached':\n        return new Promise((resolve, reject) => {\n          channel.sendPresence([wirePresMsg], (err) => (err ? reject(err) : resolve()));\n        });\n      case 'initialized':\n      case 'detached':\n        channel.attach();\n      // eslint-disable-next-line no-fallthrough\n      case 'attaching':\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => (err ? reject(err) : resolve()),\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          'Unable to ' + action + ' presence channel while in ' + channel.state + ' state',\n          90001,\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n\n  async leave(data: unknown): Promise<void> {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo('clientId must have been specified to enter or leave a presence channel', 40012, 400);\n    }\n    return this.leaveClient(undefined, data);\n  }\n\n  async leaveClient(clientId?: string, data?: unknown): Promise<void> {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'RealtimePresence.leaveClient()',\n      'leaving; channel = ' + this.channel.name + ', client = ' + clientId,\n    );\n    const presence = PresenceMessage.fromData(data);\n    presence.action = 'leave';\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions as CipherOptions);\n\n    return new Promise((resolve, reject) => {\n      switch (channel.state) {\n        case 'attached':\n          channel.sendPresence([wirePresMsg], (err) => (err ? reject(err) : resolve()));\n          break;\n        case 'attaching':\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => (err ? reject(err) : resolve()),\n          });\n          break;\n        case 'initialized':\n        case 'failed': {\n          /* we're not attached; therefore we let any entered status\n           * timeout by itself instead of attaching just in order to leave */\n          const err = new PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);\n          reject(err);\n          break;\n        }\n        default:\n          reject(channel.invalidStateError());\n      }\n    });\n  }\n\n  async get(params?: RealtimePresenceParams): Promise<PresenceMessage[]> {\n    const waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);\n\n    return new Promise((resolve, reject) => {\n      function returnMembers(members: PresenceMap) {\n        resolve(params ? members.list(params) : members.values());\n      }\n\n      /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */\n      if (this.channel.state === 'suspended') {\n        if (waitForSync) {\n          reject(\n            ErrorInfo.fromValues({\n              statusCode: 400,\n              code: 91005,\n              message: 'Presence state is out of sync due to channel being in the SUSPENDED state',\n            }),\n          );\n        } else {\n          returnMembers(this.members);\n        }\n        return;\n      }\n\n      waitAttached(\n        this.channel,\n        (err) => reject(err),\n        () => {\n          const members = this.members;\n          if (waitForSync) {\n            members.waitSync(function () {\n              returnMembers(members);\n            });\n          } else {\n            returnMembers(members);\n          }\n        },\n      );\n    });\n  }\n\n  async history(params: RealtimeHistoryParams | null): Promise<PaginatedResult<PresenceMessage>> {\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\n    const restMixin = this.channel.client.rest.presenceMixin;\n\n    if (params && params.untilAttach) {\n      if (this.channel.state === 'attached') {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          'option untilAttach requires the channel to be attached, was: ' + this.channel.state,\n          40000,\n          400,\n        );\n      }\n    }\n\n    return restMixin.history(this, params);\n  }\n\n  setPresence(presenceSet: PresenceMessage[], isSync: boolean, syncChannelSerial?: string): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'RealtimePresence.setPresence()',\n      'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial,\n    );\n    let syncCursor, match;\n    const members = this.members,\n      myMembers = this._myMembers,\n      broadcastMessages = [],\n      connId = this.channel.connectionManager.connectionId;\n\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n\n    for (let presence of presenceSet) {\n      switch (presence.action) {\n        case 'leave':\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case 'enter':\n        case 'present':\n        case 'update':\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    /* if this is the last (or only) message in a sequence of sync updates, end the sync */\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n\n    /* broadcast to listeners */\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action!, presence);\n    }\n  }\n\n  onAttached(hasPresence?: boolean): void {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'RealtimePresence.onAttached()',\n      'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence,\n    );\n\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n\n    // RTP17f: Re-enter own members when moving into the attached state.\n    this._ensureMyMembersPresent();\n\n    /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */\n    const pendingPresence = this.pendingPresence,\n      pendingPresCount = pendingPresence.length;\n\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = Multicaster.create(this.logger);\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MICRO,\n        'RealtimePresence.onAttached',\n        'sending ' + pendingPresCount + ' queued presence messages',\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray, multicaster);\n    }\n  }\n\n  actOnChannelState(state: string, hasPresence?: boolean, err?: ErrorInfo | null): void {\n    switch (state) {\n      case 'attached':\n        this.onAttached(hasPresence);\n        break;\n      case 'detached':\n      case 'failed':\n        this._clearMyMembers();\n        this.members.clear();\n      /* falls through */\n      case 'suspended':\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n\n  failPendingPresence(err?: ErrorInfo | null): void {\n    if (this.pendingPresence.length) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'RealtimeChannel.failPendingPresence',\n        'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err),\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n          // eslint-disable-next-line no-empty\n        } catch (e) {}\n      this.pendingPresence = [];\n    }\n  }\n\n  _clearMyMembers(): void {\n    this._myMembers.clear();\n  }\n\n  _ensureMyMembersPresent(): void {\n    const myMembers = this._myMembers;\n    const connId = this.channel.connectionManager.connectionId;\n\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MICRO,\n        'RealtimePresence._ensureMyMembersPresent()',\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set',\n      );\n      // RTP17g: Send ENTER containing the member id, clientId and data\n      // attributes.\n      // RTP17g1: suppress id if the connId has changed\n      const id = entry.connectionId === connId ? entry.id : undefined;\n      this._enterOrUpdateClient(id, entry.clientId, entry.data, 'enter').catch((err) => {\n        const wrappedErr = new ErrorInfo('Presence auto re-enter failed', 91004, 400, err);\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_ERROR,\n          'RealtimePresence._ensureMyMembersPresent()',\n          'Presence auto re-enter failed; reason = ' + Utils.inspectError(err),\n        );\n        const change = new ChannelStateChange(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit('update', change);\n      });\n    }\n  }\n\n  _synthesizeLeaves(items: PresenceMessage[]): void {\n    const subscriptions = this.subscriptions;\n    items.forEach(function (item) {\n      const presence = PresenceMessage.fromValues({\n        action: 'leave',\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now(),\n      });\n      subscriptions.emit('leave', presence);\n    });\n  }\n\n  async subscribe(..._args: unknown[] /* [event], listener */): Promise<void> {\n    const args = RealtimeChannel.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n\n    if (channel.state === 'failed') {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n\n    this.subscriptions.on(event, listener);\n    await channel.attach();\n  }\n\n  unsubscribe(..._args: unknown[] /* [event], listener */): void {\n    const args = RealtimeChannel.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n}\n\nexport default RealtimePresence;\n", "import Platform from 'common/platform';\nimport * as Utils from '../util/utils';\nimport Transport from './transport';\nimport Defaults from '../util/defaults';\nimport Logger from '../util/logger';\nimport ProtocolMessage, {\n  serialize as serializeProtocolMessage,\n  deserialize as deserializeProtocolMessage,\n} from '../types/protocolmessage';\nimport ErrorInfo from '../types/errorinfo';\nimport NodeWebSocket from 'ws';\nimport ConnectionManager, { TransportParams } from './connectionmanager';\nimport Auth from '../client/auth';\nimport { TransportNames } from 'common/constants/TransportName';\n\nconst shortName = TransportNames.WebSocket;\n\nfunction isNodeWebSocket(ws: WebSocket | NodeWebSocket): ws is NodeWebSocket {\n  return !!(ws as NodeWebSocket).on;\n}\n\nclass WebSocketTransport extends Transport {\n  shortName = shortName;\n  wsHost: string;\n  uri?: string;\n  wsConnection?: WebSocket | NodeWebSocket;\n\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\n    super(connectionManager, auth, params);\n    /* If is a browser, can't detect pings, so request protocol heartbeats */\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host as string;\n  }\n\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n\n  createWebSocket(uri: string, connectParams: Record<string, string>) {\n    this.uri = uri + Utils.toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n\n  toString() {\n    return 'WebSocketTransport; uri=' + this.uri;\n  }\n\n  connect() {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');\n    Transport.prototype.connect.call(this);\n    const self = this,\n      params = this.params,\n      options = params.options;\n    const wsScheme = options.tls ? 'wss://' : 'ws://';\n    const wsUri = wsScheme + this.wsHost + ':' + Defaults.getPort(options) + '/';\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);\n    Utils.whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function (err: ErrorInfo | null, authParams?: Record<string, string>) {\n        if (self.isDisposed) {\n          return;\n        }\n        let paramStr = '';\n        for (const param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';\n        Logger.logAction(\n          self.logger,\n          Logger.LOG_MINOR,\n          'WebSocketTransport.connect()',\n          'authParams:' + paramStr + ' err: ' + err,\n        );\n        if (err) {\n          self.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams!);\n        try {\n          const wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function () {\n            self.onWsOpen();\n          };\n          wsConnection.onclose = function (ev: CloseEvent) {\n            self.onWsClose(ev);\n          };\n          wsConnection.onmessage = function (ev: MessageEvent) {\n            self.onWsData(ev.data);\n          };\n          wsConnection.onerror = function (ev: Event) {\n            self.onWsError(ev as ErrorEvent);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            /* node; browsers currently don't have a general eventemitter and can't detect\n             * pings. Also, no need to reply with a pong explicitly, ws lib handles that */\n            wsConnection.on('ping', function () {\n              self.onActivity();\n            });\n          }\n        } catch (e) {\n          Logger.logAction(\n            self.logger,\n            Logger.LOG_ERROR,\n            'WebSocketTransport.connect()',\n            'Unexpected exception creating websocket: err = ' + ((e as Error).stack || (e as Error).message),\n          );\n          self.disconnect(e as Error);\n        }\n      },\n    );\n  }\n\n  send(message: ProtocolMessage) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');\n      return;\n    }\n    try {\n      (wsConnection as NodeWebSocket).send(\n        serializeProtocolMessage(message, this.connectionManager.realtime._MsgPack, this.params.format),\n      );\n    } catch (e) {\n      const msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'WebSocketTransport.send()', msg);\n      /* Don't try to request a disconnect, that'll just involve sending data\n       * down the websocket again. Just finish the transport. */\n      this.finish('disconnected', new ErrorInfo(msg, 50000, 500));\n    }\n  }\n\n  onWsData(data: string) {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MICRO,\n      'WebSocketTransport.onWsData()',\n      'data received; length = ' + data.length + '; type = ' + typeof data,\n    );\n    try {\n      this.onProtocolMessage(\n        deserializeProtocolMessage(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.format,\n        ),\n      );\n    } catch (e) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_ERROR,\n        'WebSocketTransport.onWsData()',\n        'Unexpected exception handing channel message: ' + (e as Error).stack,\n      );\n    }\n  }\n\n  onWsOpen() {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');\n    this.emit('preconnect');\n  }\n\n  onWsClose(ev: number | CloseEvent) {\n    let wasClean, code;\n    if (typeof ev == 'object') {\n      /* W3C spec-compatible */\n      code = ev.code;\n      // ev.wasClean is undefined in reactnative\n      wasClean = ev.wasClean || code === 1000;\n    } /*if(typeof(ev) == 'number')*/ else {\n      /* ws in node */\n      code = ev;\n      wasClean = code == 1000;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');\n      const err = new ErrorInfo('Websocket closed', 80003, 400);\n      this.finish('disconnected', err);\n    } else {\n      const msg = 'Unclean disconnection of WebSocket ; code = ' + code,\n        err = new ErrorInfo(msg, 80003, 400);\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);\n      this.finish('disconnected', err);\n    }\n    this.emit('disposed');\n  }\n\n  onWsError(err: ErrorEvent) {\n    Logger.logAction(\n      this.logger,\n      Logger.LOG_MINOR,\n      'WebSocketTransport.onError()',\n      'Error from WebSocket: ' + err.message,\n    );\n    /* Wait a tick before aborting: if the websocket was connected, this event\n     * will be immediately followed by an onclose event with a close code. Allow\n     * that to close it (so we see the close code) rather than anticipating it */\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n\n  dispose() {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.dispose()', '');\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      /* Ignore any messages that come through after dispose() is called but before\n       * websocket is actually closed. (mostly would be harmless, but if it's a\n       * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */\n      wsConnection.onmessage = function () {};\n      delete this.wsConnection;\n      /* defer until the next event loop cycle before closing the socket,\n       * giving some implementations the opportunity to send any outstanding close message */\n      Platform.Config.nextTick(() => {\n        Logger.logAction(this.logger, Logger.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');\n        if (!wsConnection) {\n          throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');\n        }\n        wsConnection.close();\n      });\n    }\n  }\n}\n\nexport default WebSocketTransport;\n", "import * as API from '../../../../ably';\nimport RealtimeChannel from './realtimechannel';\nimport Message from '../types/message';\n\nexport class FilteredSubscriptions {\n  static subscribeFilter(channel: RealtimeChannel, filter: API.MessageFilter, listener: API.messageCallback<Message>) {\n    const filteredListener = (m: Message) => {\n      const mapping: { [key in keyof API.MessageFilter]: any } = {\n        name: m.name,\n        refTimeserial: m.extras?.ref?.timeserial,\n        refType: m.extras?.ref?.type,\n        isRef: !!m.extras?.ref?.timeserial,\n        clientId: m.clientId,\n      };\n      // Check if any values are defined in the filter and if they match the value in the message object\n      if (\n        Object.entries(filter).find(([key, value]) =>\n          value !== undefined ? mapping[key as keyof API.MessageFilter] !== value : false,\n        )\n      ) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n\n  // Adds a new filtered subscription\n  static addFilteredSubscription(\n    channel: RealtimeChannel,\n    filter: API.MessageFilter,\n    realListener: API.messageCallback<Message>,\n    filteredListener: API.messageCallback<Message>,\n  ) {\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = new Map<\n        API.messageCallback<Message>,\n        Map<API.MessageFilter, API.messageCallback<Message>[]>\n      >();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\n        API.MessageFilter,\n        API.messageCallback<Message>[]\n      >;\n      // Add the filtered listener to the map, or append to the array if this filter has already been used\n      realListenerMap.set(filter, realListenerMap?.get(filter)?.concat(filteredListener) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        new Map<API.MessageFilter, API.messageCallback<Message>[]>([[filter, [filteredListener]]]),\n      );\n    }\n  }\n\n  static getAndDeleteFilteredSubscriptions(\n    channel: RealtimeChannel,\n    filter: API.MessageFilter | undefined,\n    realListener: API.messageCallback<Message> | undefined,\n  ): API.messageCallback<Message>[] {\n    // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    // Only a filter is passed in with no specific listener\n    if (!realListener && filter) {\n      // Return each listener which is attached to the specified filter object\n      return Array.from(channel.filteredSubscriptions.entries())\n        .map(([key, filterMaps]) => {\n          // Get (then delete) the maps matching this filter\n          let listenerMaps = filterMaps.get(filter);\n          filterMaps.delete(filter);\n          // Clear the parent if nothing is left\n          if (filterMaps.size === 0) {\n            channel.filteredSubscriptions?.delete(key);\n          }\n          return listenerMaps;\n        })\n        .reduce(\n          (prev, cur) => (cur ? (prev as API.messageCallback<Message>[]).concat(...cur) : prev),\n          [],\n        ) as API.messageCallback<Message>[];\n    }\n\n    // No subscriptions for this listener\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\n      API.MessageFilter,\n      API.messageCallback<Message>[]\n    >;\n    // If no filter is specified return all listeners using that function\n    if (!filter) {\n      // array.flat is not available unless we support es2019 or higher\n      const listeners = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      // remove the listener from the map\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners;\n    }\n\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n\n    return listeners || [];\n  }\n}\n", "import BaseRealtime from './baserealtime';\nimport ClientOptions from '../../types/ClientOptions';\nimport { allCommonModularPlugins } from './modularplugins';\nimport * as Utils from '../util/utils';\nimport ConnectionManager from '../transport/connectionmanager';\nimport ProtocolMessage from '../types/protocolmessage';\nimport Platform from 'common/platform';\nimport { DefaultMessage } from '../types/defaultmessage';\nimport { MsgPack } from 'common/types/msgpack';\nimport RealtimePresence from './realtimepresence';\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\nimport WebSocketTransport from '../transport/websockettransport';\nimport { FilteredSubscriptions } from './filteredsubscriptions';\nimport { PresenceMap } from './presencemap';\nimport PresenceMessage, { WirePresenceMessage } from '../types/presencemessage';\nimport { Http } from 'common/types/http';\nimport Defaults from '../util/defaults';\nimport Logger from '../util/logger';\n\n/**\n `DefaultRealtime` is the class that the non tree-shakable version of the SDK exports as `Realtime`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\n */\nexport class DefaultRealtime extends BaseRealtime {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options?: ClientOptions | string) {\n    const MsgPack = DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error('Expected DefaultRealtime._MsgPack to have been set');\n    }\n\n    super(\n      Defaults.objectifyOptions(options, true, 'Realtime', Logger.defaultLogger, {\n        ...allCommonModularPlugins,\n        Crypto: DefaultRealtime.Crypto ?? undefined,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence,\n          PresenceMessage,\n          WirePresenceMessage,\n        },\n        WebSocketTransport,\n        MessageInteractions: FilteredSubscriptions,\n      }),\n    );\n  }\n\n  static Utils = Utils;\n  static ConnectionManager = ConnectionManager;\n  static ProtocolMessage = ProtocolMessage;\n\n  private static _Crypto: typeof Platform.Crypto = null;\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\n    }\n\n    return this._Crypto;\n  }\n  static set Crypto(newValue: typeof Platform.Crypto) {\n    this._Crypto = newValue;\n  }\n\n  static Message = DefaultMessage;\n  static PresenceMessage = DefaultPresenceMessage;\n\n  static _MsgPack: MsgPack | null = null;\n\n  // Used by tests\n  static _Http = Http;\n  static _PresenceMap = PresenceMap;\n}\n", "import IBufferUtils from 'common/types/IBufferUtils';\nimport crypto from 'crypto';\n\nexport type Bufferlike = Buffer | ArrayBuffer | ArrayBufferView;\nexport type Output = Buffer;\nexport type ToBufferOutput = Buffer;\n\nclass BufferUtils implements IBufferUtils<Bufferlike, Output, ToBufferOutput> {\n  base64CharSet: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  hexCharSet: string = '0123456789abcdef';\n\n  base64Decode(string: string): Output {\n    return Buffer.from(string, 'base64');\n  }\n\n  base64Encode(buffer: Bufferlike): string {\n    return this.toBuffer(buffer).toString('base64');\n  }\n\n  areBuffersEqual(buffer1: Bufferlike, buffer2: Bufferlike): boolean {\n    if (!buffer1 || !buffer2) return false;\n    return this.toBuffer(buffer1).compare(this.toBuffer(buffer2)) == 0;\n  }\n\n  byteLength(buffer: Bufferlike): number {\n    return buffer.byteLength;\n  }\n\n  hexDecode(string: string): Output {\n    return Buffer.from(string, 'hex');\n  }\n\n  hexEncode(buffer: Bufferlike): string {\n    return this.toBuffer(buffer).toString('hex');\n  }\n\n  /* In node, BufferUtils methods that return binary objects return a Buffer\n   * for historical reasons; the browser equivalents return ArrayBuffers */\n  isBuffer(buffer: unknown): buffer is Bufferlike {\n    return Buffer.isBuffer(buffer) || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n\n  toArrayBuffer(buffer: Bufferlike): ArrayBuffer {\n    const nodeBuffer = this.toBuffer(buffer);\n    return nodeBuffer.buffer.slice(nodeBuffer.byteOffset, nodeBuffer.byteOffset + nodeBuffer.byteLength);\n  }\n\n  toBuffer(buffer: Bufferlike): ToBufferOutput {\n    if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return Buffer.from(buffer);\n    }\n    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  }\n\n  arrayBufferViewToBuffer(arrayBufferView: ArrayBufferView): Buffer {\n    return this.toBuffer(arrayBufferView);\n  }\n\n  utf8Decode(buffer: Bufferlike): string {\n    if (!this.isBuffer(buffer)) {\n      throw new Error('Expected input of utf8Decode to be a buffer, arraybuffer, or view');\n    }\n    return this.toBuffer(buffer).toString('utf8');\n  }\n\n  utf8Encode(string: string): Output {\n    return Buffer.from(string, 'utf8');\n  }\n\n  hmacSha256(message: Bufferlike, key: Bufferlike): Output {\n    const messageBuffer = this.toBuffer(message);\n    const keyBuffer = this.toBuffer(key);\n\n    const hmac = crypto.createHmac('SHA256', keyBuffer);\n    hmac.update(messageBuffer);\n\n    return hmac.digest();\n  }\n}\n\nexport default new BufferUtils();\n", "'use strict';\nimport Logger from '../../../../common/lib/util/logger';\nimport crypto from 'crypto';\nimport ErrorInfo from '../../../../common/lib/types/errorinfo';\nimport * as API from '../../../../../ably';\nimport ICryptoStatic, { IGetCipherParams } from '../../../../common/types/ICryptoStatic';\nimport ICipher from '../../../../common/types/ICipher';\nimport { CryptoDataTypes } from '../../../../common/types/cryptoDataTypes';\nimport { Cipher as NodeCipher, CipherKey as NodeCipherKey } from 'crypto';\nimport BufferUtils, { Bufferlike, Output as BufferUtilsOutput } from './bufferutils';\nimport util from 'util';\n\n// The type to which ably-forks/msgpack-js deserializes elements of the `bin` or `ext` type\ntype MessagePackBinaryType = Buffer;\n\ntype IV = CryptoDataTypes.IV<BufferUtilsOutput>;\ntype InputPlaintext = CryptoDataTypes.InputPlaintext<Bufferlike, BufferUtilsOutput>;\ntype OutputCiphertext = Buffer;\ntype InputCiphertext = CryptoDataTypes.InputCiphertext<MessagePackBinaryType, BufferUtilsOutput>;\ntype OutputPlaintext = Buffer;\n\nvar createCryptoClass = function (bufferUtils: typeof BufferUtils) {\n  var DEFAULT_ALGORITHM = 'aes';\n  var DEFAULT_KEYLENGTH = 256; // bits\n  var DEFAULT_MODE = 'cbc';\n  var DEFAULT_BLOCKLENGTH = 16; // bytes\n\n  /**\n   * Internal: generate a buffer of secure random bytes of the given length\n   * @param bytes\n   */\n  async function generateRandom(bytes: number): Promise<Buffer> {\n    return util.promisify(crypto.randomBytes)(bytes);\n  }\n\n  /**\n   * Internal: calculate the padded length of a given plaintext\n   * using PKCS5.\n   * @param plaintextLength\n   * @return\n   */\n  function getPaddedLength(plaintextLength: number) {\n    return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;\n  }\n\n  /**\n   * Internal: checks that the cipherParams are a valid combination. Currently\n   * just checks that the calculated keyLength is a valid one for aes-cbc\n   */\n  function validateCipherParams(params: API.CipherParams) {\n    if (params.algorithm === 'aes' && params.mode === 'cbc') {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        'Unsupported key length ' +\n          params.keyLength +\n          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)',\n      );\n    }\n  }\n\n  function normaliseBase64(string: string) {\n    /* url-safe base64 strings use _ and - instread of / and + */\n    return string.replace('_', '/').replace('-', '+');\n  }\n\n  /**\n   * Internal: obtain the pkcs5 padding string for a given padded length;\n   */\n  function filledBuffer(length: number, value: number) {\n    var result = Buffer.alloc(length);\n    result.fill(value);\n    return result;\n  }\n  var pkcs5Padding = [filledBuffer(16, 16)];\n  for (var i = 1; i <= 16; i++) pkcs5Padding.push(filledBuffer(i, i));\n\n  /**\n   * A class encapsulating the client-specifiable parameters for\n   * the cipher.\n   *\n   * algorithm is the name of the algorithm in the default system provider,\n   * or the lower-cased version of it; eg \"aes\" or \"AES\".\n   *\n   * Clients may instance a CipherParams directly and populate it, or may\n   * query the implementation to obtain a default system CipherParams.\n   */\n  class CipherParams implements API.CipherParams {\n    algorithm: string;\n    keyLength: number;\n    mode: string;\n    key: NodeCipherKey;\n    iv: unknown;\n\n    constructor(algorithm: string, keyLength: number, mode: string, key: NodeCipherKey) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n      this.iv = null;\n    }\n  }\n\n  function isInstCipherParams(params: API.CipherParams | API.CipherParamOptions): params is API.CipherParams {\n    /* In node, can't use instanceof CipherParams due to the vm context problem (see\n     * https://github.com/nwjs/nw.js/wiki/Differences-of-JavaScript-contexts).\n     * So just test for presence of all necessary attributes */\n    return !!(params.algorithm && params.key && params.keyLength && params.mode);\n  }\n\n  /**\n   * Utility classes and interfaces for message payload encryption.\n   *\n   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits\n   * but supporting other keylengths. Other algorithms and chaining modes are\n   * not supported directly, but supportable by extending/implementing the base\n   * classes and interfaces here.\n   *\n   * Secure random data for creation of Initialization Vectors (IVs) and keys\n   * is obtained from the default system SecureRandom. Future extensions of this\n   * class might make the SecureRandom pluggable or at least seedable with\n   * client-provided entropy.\n   *\n   * Each message payload is encrypted with an IV in CBC mode, and the IV is\n   * concatenated with the resulting raw ciphertext to construct the \"ciphertext\"\n   * data passed to the recipient.\n   */\n  class Crypto {\n    static CipherParams = CipherParams;\n\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params: API.CipherParamOptions) {\n      var key: NodeCipherKey;\n\n      if (!params.key) {\n        throw new Error('Crypto.getDefaultParams: a key is required');\n      }\n\n      if (typeof params.key === 'string') {\n        key = bufferUtils.base64Decode(normaliseBase64(params.key));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = Buffer.from(params.key);\n      } else {\n        key = params.key;\n      }\n\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.length * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          'Crypto.getDefaultParams: a keyLength of ' +\n            params.keyLength +\n            ' was specified, but the key actually has length ' +\n            cipherParams.keyLength,\n        );\n      }\n\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as a Buffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength?: number): Promise<API.CipherKey> {\n      try {\n        return generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo('Failed to generate random key: ' + (err as Error).message, 500, 50000, err as Error);\n      }\n    }\n\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params: IGetCipherParams<IV>, logger: Logger) {\n      var cipherParams = isInstCipherParams(params) ? (params as CipherParams) : this.getDefaultParams(params);\n\n      return {\n        cipherParams: cipherParams,\n        cipher: new CBCCipher(cipherParams, params.iv ?? null, logger),\n      };\n    }\n  }\n\n  Crypto satisfies ICryptoStatic<IV, InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext>;\n\n  class CBCCipher implements ICipher<InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext> {\n    algorithm: string;\n    key: NodeCipherKey;\n    iv: Buffer | null;\n    encryptCipher: NodeCipher | null = null;\n\n    constructor(\n      params: CipherParams,\n      iv: Buffer | null,\n      private readonly logger: Logger,\n    ) {\n      this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;\n      this.key = params.key;\n      this.iv = iv;\n    }\n\n    async encrypt(plaintext: InputPlaintext): Promise<OutputCiphertext> {\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'CBCCipher.encrypt()', '');\n\n      const iv = await this.getIv();\n      if (!this.encryptCipher) {\n        this.encryptCipher = crypto.createCipheriv(this.algorithm, this.key, iv);\n      }\n\n      var plaintextBuffer = bufferUtils.toBuffer(plaintext);\n      var plaintextLength = plaintextBuffer.length,\n        paddedLength = getPaddedLength(plaintextLength);\n      var cipherOut = this.encryptCipher.update(\n        Buffer.concat([plaintextBuffer, pkcs5Padding[paddedLength - plaintextLength]]),\n      );\n      var ciphertext = Buffer.concat([iv, cipherOut]);\n      return ciphertext;\n    }\n\n    async decrypt(ciphertext: InputCiphertext): Promise<OutputPlaintext> {\n      var decryptCipher = crypto.createDecipheriv(this.algorithm, this.key, ciphertext.slice(0, DEFAULT_BLOCKLENGTH)),\n        plaintext = decryptCipher.update(ciphertext.slice(DEFAULT_BLOCKLENGTH)),\n        final = decryptCipher.final();\n      if (final && final.length) plaintext = Buffer.concat([plaintext, final]);\n      return plaintext;\n    }\n\n    async getIv(): Promise<Buffer> {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n\n      var randomBlock = await generateRandom(DEFAULT_BLOCKLENGTH);\n\n      if (!this.encryptCipher) {\n        return randomBlock;\n      } else {\n        /* Since the iv for a new block is the ciphertext of the last, this\n         * sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as\n         * returning it */\n        return this.encryptCipher.update(randomBlock);\n      }\n    }\n  }\n\n  return Crypto;\n};\n\nexport { createCryptoClass };\n", "import Platform from 'common/platform';\nimport Defaults from 'common/lib/util/defaults';\nimport ErrorInfo from 'common/lib/types/errorinfo';\nimport {\n  ErrnoException,\n  RequestBody,\n  IPlatformHttpStatic,\n  RequestResultError,\n  RequestParams,\n  RequestResult,\n} from '../../../../common/types/http';\nimport HttpMethods from '../../../../common/constants/HttpMethods';\nimport got, { Response, Options, CancelableRequest, Agents } from 'got';\nimport http from 'http';\nimport https from 'https';\nimport BaseClient from 'common/lib/client/baseclient';\nimport { RestAgentOptions } from 'common/types/ClientOptions';\nimport { isSuccessCode } from 'common/constants/HttpStatusCodes';\nimport { createMissingPluginError, shallowEquals } from 'common/lib/util/utils';\n\n/***************************************************\n *\n * These Http operations are used for REST operations\n * and assume that the system is stateless - ie\n * there is no connection state that tells us\n * anything about the state of the network or the\n * viability of any of the hosts we know about.\n * Therefore all requests will respond to specific\n * errors by attempting the fallback hosts, and no\n * assumptions about host or network is retained to\n * influence the handling of any subsequent request.\n *\n ***************************************************/\n\nconst globalAgentPool: Array<{ options: RestAgentOptions; agents: Agents }> = [];\n\nconst Http: IPlatformHttpStatic = class {\n  static methods = [HttpMethods.Get, HttpMethods.Delete, HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\n  static methodsWithoutBody = [HttpMethods.Get, HttpMethods.Delete];\n  static methodsWithBody = [HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\n  private agent: Agents | null = null;\n  supportsAuthHeaders = true;\n  supportsLinkHeaders = true;\n  private client: BaseClient | null;\n\n  constructor(client?: BaseClient) {\n    this.client = client ?? null;\n  }\n\n  async doUri(\n    method: HttpMethods,\n    uri: string,\n    headers: Record<string, string> | null,\n    body: RequestBody | null,\n    params: RequestParams,\n  ): Promise<RequestResult> {\n    /* Will generally be making requests to one or two servers exclusively\n     * (Ably and perhaps an auth server), so for efficiency, use the\n     * foreverAgent to keep the TCP stream alive between requests where possible */\n    const agentOptions =\n      (this.client && this.client.options.restAgentOptions) || (Defaults.restAgentOptions as RestAgentOptions);\n    const doOptions: Options = { headers: headers || undefined, responseType: 'buffer' };\n\n    if (!this.agent) {\n      const persistedAgent = globalAgentPool.find((x) => shallowEquals(agentOptions, x.options))?.agents;\n      if (persistedAgent) {\n        this.agent = persistedAgent;\n      } else {\n        this.agent = {\n          http: new http.Agent(agentOptions),\n          https: new https.Agent(agentOptions),\n        };\n        globalAgentPool.push({\n          options: agentOptions,\n          agents: this.agent,\n        });\n      }\n    }\n\n    if (body) {\n      doOptions.body = body as Buffer;\n    }\n    if (params) doOptions.searchParams = params;\n\n    doOptions.agent = this.agent;\n\n    doOptions.url = uri;\n    doOptions.timeout = {\n      request: ((this.client && this.client.options.timeouts) || Defaults.TIMEOUTS).httpRequestTimeout,\n    };\n    // We have our own logic that retries appropriate statuscodes to fallback endpoints,\n    // with timeouts constructed appropriately. Don't want `got` doing its own retries to\n    // the same endpoint, inappropriately retrying 429s, etc\n    doOptions.retry = { limit: 0 };\n\n    try {\n      const res = await (got[method](doOptions) as CancelableRequest<Response>);\n      return this._handler(null, res, res.body);\n    } catch (err) {\n      if (err instanceof got.HTTPError) {\n        return this._handler(null, err.response, err.response.body);\n      }\n      return this._handler(err as ErrnoException);\n    }\n  }\n\n  checkConnectivity = async (): Promise<boolean> => {\n    if (this.client?.options.disableConnectivityCheck) {\n      return true;\n    }\n    const connectivityCheckUrl = this.client?.options.connectivityCheckUrl || Defaults.connectivityCheckUrl;\n    const connectivityCheckParams = this.client?.options.connectivityCheckParams ?? null;\n    const connectivityUrlIsDefault = !this.client?.options.connectivityCheckUrl;\n\n    const { error, statusCode, body } = await this.doUri(\n      HttpMethods.Get,\n      connectivityCheckUrl,\n      null,\n      null,\n      connectivityCheckParams,\n    );\n\n    if (!error && !connectivityUrlIsDefault) {\n      return isSuccessCode(statusCode as number);\n    }\n    return !error && (body as Buffer | string)?.toString().trim() === 'yes';\n  };\n\n  shouldFallback(err: RequestResultError) {\n    const { code, statusCode } = err as ErrnoException;\n    return (\n      code === 'ENETUNREACH' ||\n      code === 'EHOSTUNREACH' ||\n      code === 'EHOSTDOWN' ||\n      code === 'ETIMEDOUT' ||\n      code === 'ESOCKETTIMEDOUT' ||\n      code === 'ENOTFOUND' ||\n      code === 'ECONNRESET' ||\n      code === 'ECONNREFUSED' ||\n      (statusCode >= 500 && statusCode <= 504)\n    );\n  }\n\n  private _handler(err: ErrnoException | null, response?: Response, body?: unknown) {\n    if (err) {\n      return { error: err };\n    }\n\n    const statusCode = (response as Response).statusCode,\n      headers = (response as Response).headers;\n\n    if (statusCode >= 300) {\n      switch (headers['content-type']) {\n        case 'application/json':\n          body = JSON.parse(body as string);\n          break;\n\n        case 'application/x-msgpack':\n          if (!this.client?._MsgPack) {\n            return { error: createMissingPluginError('MsgPack') };\n          }\n          body = this.client._MsgPack.decode(body as Buffer);\n          break;\n      }\n\n      const error = (body as { error: ErrorInfo }).error\n        ? ErrorInfo.fromValues((body as { error: ErrorInfo }).error)\n        : new ErrorInfo(\n            (headers['x-ably-errormessage'] as string) ||\n              'Error response received from server: ' + statusCode + ' body was: ' + Platform.Config.inspect(body),\n            Number(headers['x-ably-errorcode']),\n            statusCode,\n          );\n\n      return { error, body, headers, unpacked: true, statusCode };\n    }\n\n    return { error: null, body, headers, unpacked: false, statusCode };\n  }\n};\n\nexport default Http;\n", "import { IPlatformConfig } from '../../common/types/IPlatformConfig';\nimport crypto from 'crypto';\nimport WebSocket from 'ws';\nimport util from 'util';\n\nconst Config: IPlatformConfig = {\n  agent: 'nodejs/' + process.versions.node,\n  logTimestamps: true,\n  userAgent: null,\n  binaryType: 'nodebuffer' as BinaryType,\n  WebSocket,\n  useProtocolHeartbeats: false,\n  supportsBinary: true,\n  preferBinary: true,\n  nextTick: process.nextTick,\n  inspect: util.inspect,\n  stringByteSize: Buffer.byteLength,\n  inherits: util.inherits,\n  addEventListener: null,\n  getRandomArrayBuffer: async function (byteLength: number): Promise<Buffer> {\n    return util.promisify(crypto.randomBytes)(byteLength);\n  },\n};\n\nexport default Config;\n", "enum XHRStates {\n  REQ_SEND = 0,\n  REQ_RECV = 1,\n  REQ_RECV_POLL = 2,\n  REQ_RECV_STREAM = 3,\n}\n\nexport default XHRStates;\n", "import * as Utils from '../util/utils';\nimport { actions } from '../types/protocolmessagecommon';\nimport ProtocolMessage, {\n  fromValues as protocolMessageFromValues,\n  fromDeserialized as protocolMessageFromDeserialized,\n} from '../types/protocolmessage';\nimport Transport from './transport';\nimport Logger from '../util/logger';\nimport Defaults from '../util/defaults';\nimport ConnectionErrors from './connectionerrors';\nimport Auth from '../client/auth';\nimport ErrorInfo from '../types/errorinfo';\nimport IXHRRequest from '../../types/IXHRRequest';\nimport * as API from '../../../../ably';\nimport ConnectionManager, { TransportParams } from './connectionmanager';\nimport XHRStates from '../../constants/XHRStates';\nimport Platform from 'common/platform';\n\n/* TODO: can remove once realtime sends protocol message responses for comet errors */\nfunction shouldBeErrorAction(err: ErrorInfo) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (Auth.isTokenErr(err)) return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code)) return true;\n    return err.code >= 40000 && err.code < 50000;\n  } else {\n    /* Likely a network or transport error of some kind. Certainly not fatal to the connection */\n    return false;\n  }\n}\n\nfunction protocolMessageFromRawError(err: ErrorInfo) {\n  /* err will be either a legacy (non-protocolmessage) comet error response\n   * (which will have an err.code), or a xhr/network error (which won't). */\n  if (shouldBeErrorAction(err)) {\n    return [protocolMessageFromValues({ action: actions.ERROR, error: err })];\n  } else {\n    return [protocolMessageFromValues({ action: actions.DISCONNECTED, error: err })];\n  }\n}\n\n/*\n * A base comet transport class\n */\nabstract class CometTransport extends Transport {\n  stream: string | boolean;\n  sendRequest: IXHRRequest | null;\n  recvRequest: null | IXHRRequest;\n  pendingCallback: null;\n  pendingItems: null | Array<ProtocolMessage>;\n  baseUri?: string;\n  authParams?: Record<string, any>;\n  closeUri?: string;\n  disconnectUri?: string;\n  sendUri?: string;\n  recvUri?: string;\n\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\n    super(connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true);\n    this.stream = 'stream' in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n\n  abstract createRequest(\n    uri: string,\n    headers: Record<string, string> | null,\n    params?: Record<string, unknown> | null,\n    body?: unknown,\n    requestMode?: number,\n  ): IXHRRequest;\n\n  connect(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.connect()', 'starting');\n    Transport.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = Defaults.getHost(options, params.host);\n    const port = Defaults.getPort(options);\n    const cometScheme = options.tls ? 'https://' : 'http://';\n\n    this.baseUri = cometScheme + host + ':' + port + '/comet/';\n    const connectUri = this.baseUri + 'connect';\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);\n    Utils.whenPromiseSettles(this.auth.getAuthParams(), (err: Error | null, authParams?: Record<string, any>) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams!);\n      if ('stream' in connectParams) this.stream = connectParams.stream;\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_MINOR,\n        'CometTransport.connect()',\n        'connectParams:' + Utils.toQueryString(connectParams),\n      );\n\n      /* this will be the 'recvRequest' so this connection can stream messages */\n      let preconnected = false;\n      const connectRequest = (this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV,\n      ));\n\n      connectRequest.on('data', (data: any) => {\n        if (!this.recvRequest) {\n          /* the transport was disposed before we connected */\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit('preconnect');\n        }\n        this.onData(data);\n      });\n      connectRequest.on('complete', (err: ErrorInfo) => {\n        if (!this.recvRequest) {\n          /* the transport was disposed before we connected */\n          err = err || new ErrorInfo('Request cancelled', 80003, 400);\n        }\n        this.recvRequest = null;\n        /* Connect request may complete without a emitting 'data' event since that is not\n         * emitted for e.g. a non-streamed error response. Still implies preconnect. */\n        if (!preconnected && !err) {\n          preconnected = true;\n          this.emit('preconnect');\n        }\n        this.onActivity();\n        if (err) {\n          if (err.code) {\n            /* A protocol error received from realtime. TODO: once realtime\n             * consistendly sends errors wrapped in protocol messages, should be\n             * able to remove this */\n            this.onData(protocolMessageFromRawError(err));\n          } else {\n            /* A network/xhr error. Don't bother wrapping in a protocol message,\n             * just disconnect the transport */\n            this.disconnect(err);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n\n  requestClose(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.requestClose()');\n    this._requestCloseOrDisconnect(true);\n  }\n\n  requestDisconnect(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.requestDisconnect()');\n    this._requestCloseOrDisconnect(false);\n  }\n\n  _requestCloseOrDisconnect(closing: boolean): void {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates.REQ_SEND);\n\n      request.on('complete', (err: ErrorInfo) => {\n        if (err) {\n          Logger.logAction(\n            this.logger,\n            Logger.LOG_ERROR,\n            'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'),\n            'request returned err = ' + Utils.inspectError(err),\n          );\n          this.finish('disconnected', err);\n        }\n      });\n      request.exec();\n    }\n  }\n\n  dispose(): void {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.dispose()', '');\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      /* In almost all cases the transport will be finished before it's\n       * disposed. Finish here just to make sure. */\n      this.finish('disconnected', ConnectionErrors.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit('disposed');\n      });\n    }\n  }\n\n  onConnect(message: ProtocolMessage): void {\n    /* if this transport has been disposed whilst awaiting connection, do nothing */\n    if (this.isDisposed) {\n      return;\n    }\n\n    /* the connectionKey in a comet connected response is really\n     * <instId>-<connectionKey> */\n    const connectionStr = message.connectionDetails?.connectionKey;\n    Transport.prototype.onConnect.call(this, message);\n\n    const baseConnectionUri = (this.baseUri as string) + connectionStr;\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);\n    this.sendUri = baseConnectionUri + '/send';\n    this.recvUri = baseConnectionUri + '/recv';\n    this.closeUri = baseConnectionUri + '/close';\n    this.disconnectUri = baseConnectionUri + '/disconnect';\n  }\n\n  send(message: ProtocolMessage): void {\n    if (this.sendRequest) {\n      /* there is a pending send, so queue this message */\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    /* send this, plus any pending, now */\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n\n    this.sendItems(pendingItems);\n  }\n\n  sendAnyPending(): void {\n    const pendingItems = this.pendingItems;\n\n    if (!pendingItems) {\n      return;\n    }\n\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n\n  sendItems(items: Array<ProtocolMessage>): void {\n    const sendRequest = (this.sendRequest = this.createRequest(\n      this.sendUri as string,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates.REQ_SEND,\n    ));\n\n    sendRequest.on('complete', (err: ErrorInfo, data: string) => {\n      if (err)\n        Logger.logAction(\n          this.logger,\n          Logger.LOG_ERROR,\n          'CometTransport.sendItems()',\n          'on complete: err = ' + Utils.inspectError(err),\n        );\n      this.sendRequest = null;\n\n      /* the result of the request, even if a nack, is usually a protocol response\n       * contained in the data. An err is anomolous, and indicates some issue with the\n       * network,transport, or connection */\n      if (err) {\n        if (err.code) {\n          /* A protocol error received from realtime. TODO: once realtime\n           * consistendly sends errors wrapped in protocol messages, should be\n           * able to remove this */\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\n           * just disconnect the transport */\n          this.disconnect(err);\n        }\n        return;\n      }\n\n      if (data) {\n        this.onData(data);\n      }\n\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          /* If there's a new send request by now, any pending items will have\n           * been picked up by that; any new ones added since then will be\n           * picked up after that one completes */\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n\n  recv(): void {\n    /* do nothing if there is an active request, which might be streaming */\n    if (this.recvRequest) return;\n\n    /* If we're no longer connected, do nothing */\n    if (!this.isConnected) return;\n\n    const recvRequest = (this.recvRequest = this.createRequest(\n      this.recvUri as string,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV_POLL,\n    ));\n\n    recvRequest.on('data', (data: string) => {\n      this.onData(data);\n    });\n    recvRequest.on('complete', (err: ErrorInfo) => {\n      this.recvRequest = null;\n      /* A request completing must be considered activity, as realtime sends\n       * heartbeats every 15s since a request began, not every 15s absolutely */\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          /* A protocol error received from realtime. TODO: once realtime\n           * consistently sends errors wrapped in protocol messages, should be\n           * able to remove this */\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\n           * just disconnect the transport */\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n\n  onData(responseData: string | Record<string, any>): void {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            protocolMessageFromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence),\n          );\n    } catch (e) {\n      Logger.logAction(\n        this.logger,\n        Logger.LOG_ERROR,\n        'CometTransport.onData()',\n        'Unexpected exception handing channel event: ' + (e as Error).stack,\n      );\n    }\n  }\n\n  encodeRequest(requestItems: Array<ProtocolMessage>): string {\n    return JSON.stringify(requestItems);\n  }\n\n  decodeResponse(responseData: string | Record<string, any>): Record<string, any> {\n    if (typeof responseData == 'string') return JSON.parse(responseData);\n    return responseData;\n  }\n\n  /* Historical comment, back from when we supported JSONP:\n   *\n   * > For comet, we could do the auth update by aborting the current recv and\n   * > starting a new one with the new token, that'd be sufficient for realtime.\n   * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n   * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n   * > comet transports the same and do it for all of them. So we send the AUTH\n   * > instead, and don't need to abort the recv\n   *\n   * Now that we\u2019ve dropped JSONP support, we may be able to revisit the above;\n   * see https://github.com/ably/ably-js/issues/1214.\n   */\n  onAuthUpdated = (tokenDetails: API.TokenDetails): void => {\n    this.authParams = { access_token: tokenDetails.token };\n  };\n}\n\nexport default CometTransport;\n", "'use strict';\nimport CometTransport from '../../../../common/lib/transport/comettransport';\nimport Logger from '../../../../common/lib/util/logger';\nimport * as Utils from '../../../../common/lib/util/utils';\nimport ErrorInfo, { PartialErrorInfo } from '../../../../common/lib/types/errorinfo';\nimport EventEmitter from '../../../../common/lib/util/eventemitter';\nimport HttpStatusCodes from '../../../../common/constants/HttpStatusCodes';\nimport XHRStates from '../../../../common/constants/XHRStates';\nimport http from 'http';\nimport https from 'https';\nimport url from 'url';\nimport util from 'util';\nimport { TransportNames } from '../../../../common/constants/TransportName';\n\nvar noop = function () {};\nvar shortName = TransportNames.Comet;\n\n/*\n * A transport to use with nodejs\n * to simulate an XHR transport for test purposes\n */\nclass NodeCometTransport extends CometTransport {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.httpAgent = null;\n    this.httpsAgent = null;\n    this.pendingRequests = 0;\n    this.shortName = shortName;\n  }\n\n  static isAvailable() {\n    return true;\n  }\n\n  toString() {\n    return (\n      'NodeCometTransport; uri=' +\n      this.baseUri +\n      '; isConnected=' +\n      this.isConnected +\n      '; format=' +\n      this.format +\n      '; stream=' +\n      this.stream\n    );\n  }\n\n  getAgent(tls) {\n    var prop = tls ? 'httpsAgent' : 'httpAgent',\n      agent = this[prop];\n\n    if (!agent) agent = this[prop] = new (tls ? https : http).Agent({ keepAlive: true });\n\n    return agent;\n  }\n\n  dispose() {\n    var self = this;\n    this.onceNoPending(function () {\n      if (self.httpAgent) self.httpAgent.destroy();\n      if (self.httpsAgent) self.httpsAgent.destroy();\n    });\n    CometTransport.prototype.dispose.call(this);\n  }\n\n  /* valid in non-streaming mode only, or data only contains last update */\n  request(uri, params, body, requestMode, callback) {\n    var req = this.createRequest(uri, params, body, requestMode);\n    req.once('complete', callback);\n    req.exec();\n    return req;\n  }\n\n  createRequest(uri, headers, params, body, requestMode) {\n    return new Request(uri, headers, params, body, requestMode, this.format, this.timeouts, this);\n  }\n\n  addPending() {\n    ++this.pendingRequests;\n  }\n\n  removePending() {\n    if (--this.pendingRequests <= 0) {\n      this.emit('nopending');\n    }\n  }\n\n  onceNoPending(listener) {\n    if (this.pendingRequests == 0) {\n      listener();\n      return;\n    }\n    this.once('nopending', listener);\n  }\n}\n\nclass Request extends EventEmitter {\n  constructor(uri, headers, params, body, requestMode, format, timeouts, transport) {\n    super(transport.logger);\n\n    if (typeof uri == 'string') uri = url.parse(uri);\n    var tls = uri.protocol == 'https:';\n    this.client = tls ? https : http;\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.transport = transport;\n    this.requestComplete = false;\n    this.req = this.res = null;\n\n    var method = 'GET',\n      contentType = format == 'msgpack' ? 'application/x-msgpack' : 'application/json';\n\n    headers = headers ? Utils.mixin({}, headers) : {};\n    headers['accept'] = contentType;\n\n    if (body) {\n      method = 'POST';\n      if (!Buffer.isBuffer(body)) {\n        if (typeof body == 'object') body = JSON.stringify(body);\n        body = Buffer.from(body);\n      }\n      this.body = body;\n      headers['Content-Length'] = body.length;\n      headers['Content-Type'] = contentType;\n    }\n    var requestOptions = (this.requestOptions = {\n      hostname: uri.hostname,\n      port: uri.port,\n      path: uri.path + Utils.toQueryString(params),\n      method: method,\n      headers: headers,\n    });\n    if (transport) requestOptions.agent = transport.getAgent(tls);\n  }\n\n  exec() {\n    var timeout = this.requestMode == XHRStates.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,\n      self = this;\n\n    var timer = (this.timer = setTimeout(function () {\n        self.abort();\n      }, timeout)),\n      req = (this.req = this.client.request(this.requestOptions));\n\n    req.on(\n      'error',\n      (this.onReqError = function (err) {\n        err = new PartialErrorInfo('Request error: ' + err.message, null, 400);\n        clearTimeout(timer);\n        self.timer = null;\n        self.complete(err);\n      }),\n    );\n\n    req.on('response', function (res) {\n      clearTimeout(timer);\n      self.timer = null;\n\n      var statusCode = res.statusCode;\n      if (statusCode == HttpStatusCodes.NoContent) {\n        /* cause the stream to flow, and thus end */\n        res.resume();\n        self.complete();\n        return;\n      }\n\n      res.on(\n        'error',\n        (self.onResError = function (err) {\n          err = new PartialErrorInfo('Response error: ' + err.message, null, 400);\n          self.complete(err);\n        }),\n      );\n\n      self.res = res;\n      /* responses with an non-success statusCode are never streamed */\n      if (self.requestMode == XHRStates.REQ_RECV_STREAM && statusCode < 400) {\n        self.readStream();\n      } else {\n        self.readFully();\n      }\n    });\n\n    if (this.transport) this.transport.addPending();\n\n    req.end(this.body);\n  }\n\n  readStream() {\n    var res = this.res,\n      self = this;\n\n    /* an array of text blocks to concatenate and parse once complete */\n    this.chunks = [];\n    this.streamComplete = false;\n\n    function onChunk(chunk) {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        var msg = 'Malformed response body from server: ' + e.message;\n        Logger.logAction(self.logger, Logger.LOG_ERROR, 'NodeCometTransport.Request.readStream()', msg);\n        self.complete(new PartialErrorInfo(msg, null, 400));\n        return;\n      }\n      self.emit('data', chunk);\n    }\n\n    res.on(\n      'data',\n      (this.ondata = function (data) {\n        var newChunks = String(data).split('\\n'),\n          chunks = self.chunks;\n\n        if (newChunks.length > 1 && chunks.length > 0) {\n          /* there is a \\n in this chunk, so it completes the partial chunks we had */\n          chunks.push(newChunks.shift());\n          self.chunks = [];\n          onChunk(chunks.join(''));\n        }\n\n        /* if the trailing chunk wasn't empty, it's a new fragment */\n        var trailingNewChunk = newChunks.pop();\n        if (trailingNewChunk.length) {\n          self.chunks.push(trailingNewChunk);\n        }\n\n        /* the remaining new chunks are complete */\n        newChunks.map(onChunk);\n      }),\n    );\n\n    res.on('end', function () {\n      self.streamComplete = true;\n      process.nextTick(function () {\n        self.complete();\n      });\n    });\n  }\n\n  readFully() {\n    var res = this.res,\n      chunks = [],\n      self = this;\n\n    res.on('data', function (chunk) {\n      chunks.push(chunk);\n    });\n\n    res.on('end', function () {\n      process.nextTick(function () {\n        var body = Buffer.concat(chunks),\n          statusCode = res.statusCode;\n\n        try {\n          body = JSON.parse(String(body));\n        } catch (e) {\n          var msg = 'Malformed response body from server: ' + e.message;\n          Logger.logAction(self.logger, Logger.LOG_ERROR, 'NodeCometTransport.Request.readFully()', msg);\n          self.complete(new PartialErrorInfo(msg, null, 400));\n          return;\n        }\n\n        /* If response is an array, it's an array of protocol messages -- even if\n         * is contains an error action (hence the nonsuccess statuscode), we can\n         * consider the request to have succeeded, just pass it on to\n         * onProtocolMessage to decide what to do */\n        if (statusCode < 400 || Array.isArray(body)) {\n          self.complete(null, body);\n          return;\n        }\n\n        var err = body.error && ErrorInfo.fromValues(body.error);\n        if (!err) {\n          err = new PartialErrorInfo(\n            'Error response received from server: ' + statusCode + ', body was: ' + util.inspect(body),\n            null,\n            statusCode,\n          );\n        }\n        self.complete(err);\n      });\n    });\n  }\n\n  complete(err, body) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (body) this.emit('data', body);\n      this.emit('complete', err, body);\n      if (err) {\n        /* if there was an error mid-stream, ensure\n         * we get no new data events from the stream */\n        if (this.ondata && !this.streamComplete)\n          if (this.ondata && this.res) this.res.removeListener('data', this.ondata);\n      }\n      if (this.transport) {\n        this.transport.removePending();\n      }\n    }\n  }\n\n  abort() {\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'NodeCometTransport.Request.abort()', '');\n    var timer = this.timer;\n    if (timer) {\n      clearTimeout(timer);\n      this.timer = null;\n    }\n    var req = this.req;\n    if (req) {\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'NodeCometTransport.Request.abort()', 'aborting request');\n      req.removeListener('error', this.onReqError);\n      req.on('error', noop);\n      req.abort();\n      this.req = null;\n    }\n    this.complete({ statusCode: 400, code: 80003, message: 'Cancelled' });\n  }\n}\n\nexport default NodeCometTransport;\n", "import { TransportNames } from 'common/constants/TransportName';\nimport NodeCometTransport from './nodecomettransport';\nimport { default as WebSocketTransport } from '../../../../common/lib/transport/websockettransport';\nimport { TransportCtor } from 'common/lib/transport/transport';\n\nexport default {\n  order: [TransportNames.Comet],\n  bundledImplementations: {\n    [TransportNames.WebSocket]: WebSocketTransport as TransportCtor,\n    [TransportNames.Comet]: NodeCometTransport as unknown as TransportCtor,\n  },\n};\n", "import IDefaults from '../../../../common/types/IDefaults';\nimport { TransportNames } from '../../../../common/constants/TransportName';\n\nconst Defaults: IDefaults = {\n  connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',\n  wsConnectivityCheckUrl: 'wss://ws-up.ably-realtime.com',\n  /* Note: order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's supported. */\n  defaultTransports: [TransportNames.WebSocket],\n  restAgentOptions: { maxSockets: 40, keepAlive: true },\n};\n\nexport default Defaults;\n", "// Common\nimport { DefaultRest } from '../../common/lib/client/defaultrest';\nimport { DefaultRealtime } from '../../common/lib/client/defaultrealtime';\nimport Platform from '../../common/platform';\nimport ErrorInfo from '../../common/lib/types/errorinfo';\nimport { fromDeserializedIncludingDependencies as protocolMessageFromDeserialized } from '../../common/lib/types/protocolmessage';\n\n// Platform Specific\nimport BufferUtils from './lib/util/bufferutils';\n// @ts-ignore\nimport { createCryptoClass } from './lib/util/crypto';\nimport Http from './lib/util/http';\nimport Config from './config';\n// @ts-ignore\nimport Transports from './lib/transport';\nimport Logger from '../../common/lib/util/logger';\nimport { getDefaults } from '../../common/lib/util/defaults';\nimport PlatformDefaults from './lib/util/defaults';\nimport msgpack = require('@ably/msgpack-js');\n\nconst Crypto = createCryptoClass(BufferUtils);\n\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = BufferUtils as typeof Platform.BufferUtils;\nPlatform.Http = Http;\nPlatform.Config = Config;\nPlatform.Transports = Transports;\nPlatform.WebStorage = null;\n\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack;\n}\n\nLogger.initLogHandlers();\n\nPlatform.Defaults = getDefaults(PlatformDefaults);\n\nif (Platform.Config.agent) {\n  // @ts-ignore\n  Platform.Defaults.agent += ' ' + Platform.Config.agent;\n}\n\nmodule.exports = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: null,\n  protocolMessageFromDeserialized,\n};\n"],
  "mappings": "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",
  "names": ["exports", "module", "Buffer", "version", "exports", "module", "exports", "module", "Buffer", "exports", "module", "exports", "module", "Buffer", "exports", "module", "copy", "exports", "module", "Buffer", "version", "exports", "module", "key", "exports", "module", "Buffer", "key", "exports", "module", "exports", "encode", "decode", "_a", "Format", "_a", "agent", "Crypto", "HttpMethods", "HttpStatusCodes", "tokenDetails", "_a", "err", "_a", "_a", "version", "_a", "logResult", "headers", "params", "_a", "self", "_a", "_a", "headers", "Crypto", "actions", "Crypto", "headers", "actions", "fromEncoded", "Crypto", "fromEncodedArray", "_fromEncoded", "_fromEncodedArray", "_a", "headers", "_fromEncodedArray", "headers", "headers", "version", "_a", "fromEncoded", "fromEncodedArray", "_a", "self", "serialize", "_a", "TransportNames", "globalObject", "_a", "self", "connectionDetails", "noop", "_a", "_a", "Channels", "self", "serialize", "_a", "listeners", "_a", "hmac", "crypto", "import_crypto", "util", "crypto", "Crypto", "_a", "import_http", "Http", "_a", "http", "https", "got", "import_crypto", "import_util", "WebSocket", "util", "crypto", "XHRStates", "err", "_a", "import_http", "import_https", "import_util", "noop", "shortName", "agent", "https", "http", "self", "url", "util", "transport_default", "Defaults", "defaults_default", "transport_default", "defaults_default"]
}
