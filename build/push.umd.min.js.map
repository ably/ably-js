{
  "version": 3,
  "sources": ["../node_modules/ulid/stubs/crypto.js", "../src/plugins/push/index.ts", "../src/plugins/push/pushchannel.ts", "../src/plugins/push/getW3CDeviceDetails.ts", "../node_modules/ulid/dist/index.esm.js", "../src/plugins/push/pushactivation.ts"],
  "sourcesContent": ["", "import PushChannel from './pushchannel';\nimport { getW3CPushDeviceDetails } from './getW3CDeviceDetails';\nimport { ActivationStateMachine, CalledActivate, CalledDeactivate, localDeviceFactory } from './pushactivation';\n\nexport {\n  ActivationStateMachine,\n  localDeviceFactory,\n  CalledActivate,\n  CalledDeactivate,\n  PushChannel,\n  getW3CPushDeviceDetails,\n};\n\nexport default {\n  ActivationStateMachine,\n  localDeviceFactory,\n  CalledActivate,\n  CalledDeactivate,\n  PushChannel,\n  getW3CPushDeviceDetails,\n};\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\nimport type RestChannel from 'common/lib/client/restchannel';\nimport type { LocalDevice } from 'plugins/push/pushactivation';\n\nclass PushChannel {\n  client: BaseClient;\n  channel: RestChannel | RealtimeChannel;\n\n  constructor(channel: RestChannel | RealtimeChannel) {\n    this.channel = channel;\n    this.client = channel.client;\n  }\n\n  async subscribeDevice() {\n    const client = this.client;\n    const device = client.device as LocalDevice;\n    const format = client.options.useBinaryProtocol ? client.Utils.Format.msgpack : client.Utils.Format.json,\n      body = { deviceId: device.id, channel: this.channel.name },\n      headers = client.Defaults.defaultPostHeaders(client.options, { format });\n\n    if (client.options.headers) client.Utils.mixin(headers, client.options.headers);\n\n    client.Utils.mixin(headers, this._getPushAuthHeaders());\n\n    const requestBody = client.Utils.encodeBody(body, client._MsgPack, format);\n    await client.rest.Resource.post(client, '/push/channelSubscriptions', requestBody, headers, {}, format, true);\n  }\n\n  async unsubscribeDevice() {\n    const client = this.client;\n    const device = client.device as LocalDevice;\n    const format = client.options.useBinaryProtocol ? client.Utils.Format.msgpack : client.Utils.Format.json,\n      headers = client.Defaults.defaultPostHeaders(client.options, { format });\n\n    if (client.options.headers) client.Utils.mixin(headers, client.options.headers);\n\n    client.Utils.mixin(headers, this._getPushAuthHeaders());\n\n    await client.rest.Resource.delete(\n      client,\n      '/push/channelSubscriptions',\n      headers,\n      { deviceId: device.id, channel: this.channel.name },\n      format,\n      true,\n    );\n  }\n\n  async subscribeClient() {\n    const client = this.client;\n    const clientId = this.client.auth.clientId;\n    if (!clientId) {\n      throw new this.client.ErrorInfo('Cannot subscribe from client without client ID', 50000, 500);\n    }\n    const format = client.options.useBinaryProtocol ? client.Utils.Format.msgpack : client.Utils.Format.json,\n      body = { clientId: clientId, channel: this.channel.name },\n      headers = client.Defaults.defaultPostHeaders(client.options, { format });\n\n    if (client.options.headers) client.Utils.mixin(headers, client.options.headers);\n\n    const requestBody = client.Utils.encodeBody(body, client._MsgPack, format);\n    await client.rest.Resource.post(client, '/push/channelSubscriptions', requestBody, headers, {}, format, true);\n  }\n\n  async unsubscribeClient() {\n    const client = this.client;\n\n    const clientId = this.client.auth.clientId;\n    if (!clientId) {\n      throw new this.client.ErrorInfo('Cannot unsubscribe from client without client ID', 50000, 500);\n    }\n    const format = client.options.useBinaryProtocol ? client.Utils.Format.msgpack : client.Utils.Format.json,\n      headers = client.Defaults.defaultPostHeaders(client.options, { format });\n\n    if (client.options.headers) client.Utils.mixin(headers, client.options.headers);\n\n    await client.rest.Resource.delete(\n      client,\n      '/push/channelSubscriptions',\n      headers,\n      { clientId: clientId, channel: this.channel.name },\n      format,\n      true,\n    );\n  }\n\n  async listSubscriptions(params?: Record<string, string>) {\n    this.client.Logger.logAction(\n      this.client.logger,\n      this.client.Logger.LOG_MICRO,\n      'PushChannel.listSubscriptions()',\n      'channel = ' + this.channel.name,\n    );\n\n    return this.client.push.admin.channelSubscriptions.list({\n      ...params,\n      channel: this.channel.name,\n      concatFilters: true,\n    });\n  }\n\n  private _getDeviceIdentityToken() {\n    const device = this.client.device as LocalDevice;\n    const deviceIdentityToken = device.deviceIdentityToken;\n    if (deviceIdentityToken) {\n      return deviceIdentityToken;\n    } else {\n      throw new this.client.ErrorInfo('Cannot subscribe from client without deviceIdentityToken', 50000, 500);\n    }\n  }\n\n  private _getPushAuthHeaders() {\n    const deviceIdentityToken = this._getDeviceIdentityToken();\n    return { 'X-Ably-DeviceToken': deviceIdentityToken };\n  }\n}\n\nexport default PushChannel;\n", "import { ActivationStateMachine } from 'plugins/push/pushactivation';\n\nfunction toBase64Url(arrayBuffer: ArrayBuffer) {\n  const buffer = new Uint8Array(arrayBuffer.slice(0, arrayBuffer.byteLength));\n  return btoa(String.fromCharCode.apply(null, Array.from(buffer)));\n}\n\nfunction urlBase64ToBase64(base64String: string) {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');\n  return base64;\n}\n\nfunction base64ToUint8Array(base64String: string) {\n  const rawData = window.atob(base64String);\n  const rawDataChars = [];\n  for (let i = 0; i < rawData.length; i++) {\n    rawDataChars.push(rawData[i].charCodeAt(0));\n  }\n  return Uint8Array.from(rawDataChars);\n}\n\nexport async function getW3CPushDeviceDetails(machine: ActivationStateMachine) {\n  const GettingPushDeviceDetailsFailed = machine.GettingPushDeviceDetailsFailed;\n  const GotPushDeviceDetails = machine.GotPushDeviceDetails;\n  const { ErrorInfo, Defaults } = machine.client;\n\n  const permission = await Notification.requestPermission();\n\n  if (permission !== 'granted') {\n    machine.handleEvent(\n      new GettingPushDeviceDetailsFailed(new ErrorInfo('User denied permission to send notifications', 400, 40000)),\n    );\n    return;\n  }\n\n  const swUrl = machine.client.options.pushServiceWorkerUrl;\n  if (!swUrl) {\n    machine.handleEvent(\n      new GettingPushDeviceDetailsFailed(new ErrorInfo('Missing ClientOptions.pushServiceWorkerUrl', 400, 40000)),\n    );\n    return;\n  }\n\n  try {\n    const worker = await navigator.serviceWorker.register(swUrl);\n\n    machine._pushManager = worker.pushManager;\n\n    const headers = Defaults.defaultGetHeaders(machine.client.options, { format: 'text' });\n    const appServerKey = (\n      await machine.client.rest.Resource.get(machine.client, '/push/publicVapidKey', headers, {}, null, true)\n    ).body as string;\n\n    if (!worker.active) {\n      await navigator.serviceWorker.ready;\n    }\n\n    const subscription = await worker.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: base64ToUint8Array(urlBase64ToBase64(appServerKey)),\n    });\n\n    const endpoint = subscription.endpoint;\n\n    const [p256dh, auth] = [subscription.getKey('p256dh'), subscription.getKey('auth')];\n\n    if (!p256dh || !auth) {\n      throw new ErrorInfo('Public key not found', 50000, 500);\n    }\n\n    const device = machine.client.device;\n    device.push.recipient = {\n      transportType: 'web',\n      targetUrl: btoa(endpoint),\n      publicVapidKey: appServerKey,\n      encryptionKey: {\n        p256dh: toBase64Url(p256dh),\n        auth: toBase64Url(auth),\n      },\n    };\n    device.persist();\n\n    machine.handleEvent(new GotPushDeviceDetails());\n  } catch (err) {\n    machine.handleEvent(\n      new GettingPushDeviceDetailsFailed(new ErrorInfo('Failed to register service worker', 50000, 500, err as Error)),\n    );\n  }\n}\n", "function createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = require(\"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };\n", "import * as API from '../../../ably';\nimport { IPlatformPushConfig } from 'common/types/IPlatformConfig';\nimport { ulid } from 'ulid';\nimport type { ErrCallback, StandardCallback } from 'common/types/utils';\nimport type ErrorInfo from 'common/lib/types/errorinfo';\nimport DeviceDetails, { DevicePlatform, DevicePushDetails } from 'common/lib/types/devicedetails';\nimport { getW3CPushDeviceDetails } from './getW3CDeviceDetails';\nimport type BaseClient from 'common/lib/client/baseclient';\n\nconst persistKeys = {\n  deviceId: 'ably.push.deviceId',\n  deviceSecret: 'ably.push.deviceSecret',\n  deviceIdentityToken: 'ably.push.deviceIdentityToken',\n  pushRecipient: 'ably.push.pushRecipient',\n  activationState: 'ably.push.activationState',\n};\n\ntype DeviceRegistration = Required<{\n  [K in keyof DeviceDetails]: K extends 'deviceIdentityToken' ? API.TokenDetails : DeviceDetails[K];\n}>;\n\nexport type RegisterCallback = (device: DeviceDetails, callback: StandardCallback<DeviceRegistration>) => void;\nexport type DeregisterCallback = (device: DeviceDetails, callback: StandardCallback<string>) => void;\n\nexport interface LocalDeviceAuthDetails {\n  headers: Record<string, string>;\n  params: Record<string, unknown>;\n}\n\nexport type LocalDeviceFactory = ReturnType<typeof localDeviceFactory>;\nexport type LocalDevice = ReturnType<LocalDeviceFactory['load']>;\n\n/**\n * LocalDevice extends DeviceDetails, but DeviceDetails is part of core ably-js and LocalDevice is part of the Push plugin\n * In order to avoid bundling the DeviceDetails class in both core ably-js and the plugin, the LocalDevice is exported as\n * a factory, and the DeviceDetails constructor is used to create the class declaration for LocalDevice when the plugin is\n * loaded.\n */\nexport function localDeviceFactory(deviceDetails: typeof DeviceDetails) {\n  return class LocalDevice extends deviceDetails {\n    rest: BaseClient;\n    push: DevicePushDetails;\n\n    private constructor(rest: BaseClient) {\n      super();\n      this.push = {};\n      this.rest = rest;\n    }\n\n    static load(rest: BaseClient) {\n      const device = new LocalDevice(rest);\n      device.loadPersisted();\n      return device;\n    }\n\n    loadPersisted() {\n      const Platform = this.rest.Platform;\n      if (!Platform.Config.push) {\n        throw new this.rest.ErrorInfo('Push activation is not available on this platform', 40000, 400);\n      }\n      this.platform = Platform.Config.push.platform;\n      this.clientId = this.rest.auth.clientId ?? undefined;\n      this.formFactor = Platform.Config.push.formFactor;\n      this.id = Platform.Config.push.storage.get(persistKeys.deviceId);\n\n      if (this.id) {\n        this.deviceSecret = Platform.Config.push.storage.get(persistKeys.deviceSecret) || undefined;\n        this.deviceIdentityToken = JSON.parse(\n          Platform.Config.push.storage.get(persistKeys.deviceIdentityToken) || 'null',\n        );\n        this.push.recipient = JSON.parse(Platform.Config.push.storage.get(persistKeys.pushRecipient) || 'null');\n      } else {\n        this.resetId();\n      }\n    }\n\n    persist() {\n      const config = this.rest.Platform.Config;\n      if (!config.push) {\n        throw new this.rest.ErrorInfo('Push activation is not available on this platform', 40000, 400);\n      }\n      if (this.id) {\n        config.push.storage.set(persistKeys.deviceId, this.id);\n      }\n      if (this.deviceSecret) {\n        config.push.storage.set(persistKeys.deviceSecret, this.deviceSecret);\n      }\n      if (this.deviceIdentityToken) {\n        config.push.storage.set(persistKeys.deviceIdentityToken, JSON.stringify(this.deviceIdentityToken));\n      }\n      if (this.push.recipient) {\n        config.push.storage.set(persistKeys.pushRecipient, JSON.stringify(this.push.recipient));\n      }\n    }\n\n    resetId() {\n      this.id = ulid();\n      this.deviceSecret = ulid();\n      this.persist();\n    }\n\n    getAuthDetails(\n      rest: BaseClient,\n      headers: Record<string, string>,\n      params: Record<string, unknown>,\n    ): LocalDeviceAuthDetails {\n      if (!this.deviceIdentityToken) {\n        throw new this.rest.ErrorInfo('Unable to update device registration; no deviceIdentityToken', 50000, 500);\n      }\n      if (this.rest.http.supportsAuthHeaders) {\n        return {\n          headers: rest.Utils.mixin(\n            { authorization: 'Bearer ' + rest.Utils.toBase64(this.deviceIdentityToken) },\n            headers,\n          ) as Record<string, string>,\n          params,\n        };\n      } else {\n        return { headers, params: rest.Utils.mixin({ access_token: this.deviceIdentityToken }, params) };\n      }\n    }\n  };\n}\n\nexport class ActivationStateMachine {\n  client: BaseClient;\n  current: ActivationState;\n  pendingEvents: ActivationEvent[];\n  handling: boolean;\n  deactivatedCallback?: ErrCallback;\n  activatedCallback?: ErrCallback;\n  _pushConfig?: IPlatformPushConfig;\n  registerCallback?: RegisterCallback;\n  deregisterCallback?: DeregisterCallback;\n  updateFailedCallback?: ErrCallback;\n\n  // Used for testing\n  _pushManager?: PushManager;\n\n  // exported for testing\n  GettingPushDeviceDetailsFailed = GettingPushDeviceDetailsFailed;\n  GotPushDeviceDetails = GotPushDeviceDetails;\n\n  constructor(rest: BaseClient) {\n    this.client = rest;\n    this._pushConfig = rest.Platform.Config.push;\n    this.current = new ActivationStates[\n      (this.pushConfig.storage.get(persistKeys.activationState) as ActivationStateName) || 'NotActivated'\n    ](null);\n    this.pendingEvents = [];\n    this.handling = false;\n  }\n\n  get pushConfig() {\n    if (!this._pushConfig) {\n      throw new this.client.ErrorInfo('This platform is not supported as a target of push notifications', 40000, 400);\n    }\n    return this._pushConfig;\n  }\n\n  persist() {\n    if (isPersistentState(this.current)) {\n      this.pushConfig.storage.set(persistKeys.activationState, this.current.name);\n    }\n  }\n\n  callUpdateRegistrationFailedCallback(reason: ErrorInfo) {\n    if (this.updateFailedCallback) {\n      this.updateFailedCallback(reason);\n    } else {\n      this.client.Logger.logAction(\n        this.client.logger,\n        this.client.Logger.LOG_ERROR,\n        'UpdateRegistrationFailed',\n        'Failed updating device push registration: ' + this.client.Utils.inspectError(reason),\n      );\n    }\n  }\n\n  callCustomRegisterer(device: LocalDevice, isNew: boolean) {\n    this.registerCallback?.(device, (error: ErrorInfo, deviceRegistration?: DeviceRegistration) => {\n      if (error) {\n        if (isNew) {\n          this.handleEvent(new GettingDeviceRegistrationFailed(error));\n        } else {\n          this.handleEvent(new SyncRegistrationFailed(error));\n        }\n        return;\n      }\n\n      if (!deviceRegistration) {\n        this.handleEvent(\n          new GettingDeviceRegistrationFailed(\n            new this.client.ErrorInfo('registerCallback did not return deviceRegistration', 40000, 400),\n          ),\n        );\n      }\n\n      if (isNew) {\n        this.handleEvent(new GotDeviceRegistration(deviceRegistration as any));\n      } else {\n        this.handleEvent(new RegistrationSynced());\n      }\n    });\n  }\n\n  callCustomDeregisterer(device: LocalDevice) {\n    this.deregisterCallback?.(device, (err: ErrorInfo) => {\n      if (err) {\n        this.handleEvent(new DeregistrationFailed(err));\n        return;\n      }\n      this.handleEvent(new Deregistered());\n    });\n  }\n\n  async updateRegistration() {\n    const localDevice = this.client.device as LocalDevice;\n    if (this.registerCallback) {\n      this.callCustomRegisterer(localDevice, false);\n    } else {\n      const client = this.client;\n      const format = client.options.useBinaryProtocol\n          ? this.client.Utils.Format.msgpack\n          : this.client.Utils.Format.json,\n        body = client.rest.DeviceDetails.fromLocalDevice(localDevice),\n        headers = this.client.Defaults.defaultPostHeaders(this.client.options, { format }),\n        params = {};\n\n      if (client.options.headers) {\n        this.client.Utils.mixin(headers, client.options.headers);\n      }\n\n      if (client.options.pushFullWait) {\n        this.client.Utils.mixin(params, { fullWait: 'true' });\n      }\n\n      const requestBody = this.client.Utils.encodeBody(body, client._MsgPack, format);\n      const authDetails = localDevice.getAuthDetails(client, headers, params);\n      try {\n        const response = await this.client.rest.Resource.patch(\n          client,\n          '/push/deviceRegistrations',\n          requestBody,\n          authDetails.headers,\n          authDetails.params,\n          format,\n          true,\n        );\n        this.handleEvent(new GotDeviceRegistration(response.body as DeviceRegistration));\n      } catch (err) {\n        this.handleEvent(new GettingDeviceRegistrationFailed(err as ErrorInfo));\n      }\n    }\n  }\n\n  async deregister() {\n    const device = this.client.device as LocalDevice;\n    if (this.deregisterCallback) {\n      this.callCustomDeregisterer(device);\n    } else {\n      const rest = this.client;\n      const format = rest.options.useBinaryProtocol ? this.client.Utils.Format.msgpack : this.client.Utils.Format.json,\n        headers = this.client.Defaults.defaultPostHeaders(rest.options, { format }),\n        params = { deviceId: device.id };\n\n      if (rest.options.headers) this.client.Utils.mixin(headers, rest.options.headers);\n\n      if (rest.options.pushFullWait) this.client.Utils.mixin(params, { fullWait: 'true' });\n\n      try {\n        await this.client.rest.Resource.delete(rest, '/push/deviceRegistrations', headers, params, format, true);\n        this.handleEvent(new Deregistered());\n      } catch (err) {\n        this.handleEvent(new DeregistrationFailed(err as ErrorInfo));\n      }\n    }\n  }\n\n  callActivatedCallback(err: ErrorInfo | null) {\n    this.activatedCallback?.(err);\n    delete this.activatedCallback;\n  }\n\n  callDeactivatedCallback(err: ErrorInfo | null) {\n    this.deactivatedCallback?.(err);\n    delete this.deactivatedCallback;\n  }\n\n  handleEvent(event: ActivationEvent) {\n    if (this.handling) {\n      this.client.Platform.Config.nextTick(() => {\n        this.handleEvent(event);\n      });\n      return;\n    }\n\n    this.handling = true;\n    this.client.Logger.logAction(\n      this.client.logger,\n      this.client.Logger.LOG_MAJOR,\n      'Push.ActivationStateMachine.handleEvent()',\n      'handling event ' + event.name + ' from ' + this.current.name,\n    );\n\n    let maybeNext = this.current.processEvent(this, event);\n    if (!maybeNext) {\n      this.client.Logger.logAction(\n        this.client.logger,\n        this.client.Logger.LOG_MAJOR,\n        'Push.ActivationStateMachine.handleEvent()',\n        'enqueing event: ' + event.name,\n      );\n      this.pendingEvents.push(event);\n      this.handling = false;\n      return;\n    }\n\n    this.client.Logger.logAction(\n      this.client.logger,\n      this.client.Logger.LOG_MAJOR,\n      'Push.ActivationStateMachine.handleEvent()',\n      'transition: ' + this.current.name + ' -(' + event.name + ')-> ' + maybeNext.name,\n    );\n    this.current = maybeNext;\n\n    while (this.pendingEvents.length > 0) {\n      const pending = this.pendingEvents[0];\n\n      this.client.Logger.logAction(\n        this.client.logger,\n        this.client.Logger.LOG_MAJOR,\n        'Push.ActivationStateMachine.handleEvent()',\n        'attempting to consume pending event: ' + pending.name,\n      );\n\n      maybeNext = this.current.processEvent(this, pending);\n      if (!maybeNext) {\n        break;\n      }\n      this.pendingEvents.splice(0, 1);\n\n      this.client.Logger.logAction(\n        this.client.logger,\n        this.client.Logger.LOG_MAJOR,\n        'Push.ActivationStateMachine.handleEvent()',\n        'transition: ' + this.current.name + ' -(' + pending.name + ')-> ' + maybeNext.name,\n      );\n      this.current = maybeNext;\n    }\n\n    this.persist();\n    this.handling = false;\n  }\n}\n\n// Events\nexport class CalledActivate {\n  name = 'CalledActivate';\n\n  constructor(machine: ActivationStateMachine, registerCallback?: RegisterCallback) {\n    if (registerCallback) {\n      machine.registerCallback = registerCallback;\n    }\n    machine.persist();\n  }\n}\n\nexport class CalledDeactivate {\n  name = 'CalledDeactivate';\n\n  constructor(machine: ActivationStateMachine, deregisterCallback?: DeregisterCallback) {\n    machine.deregisterCallback = deregisterCallback;\n    machine.persist();\n  }\n}\n\nexport class GotPushDeviceDetails {\n  name = 'GotPushDeviceDetails';\n}\n\nexport class GettingPushDeviceDetailsFailed {\n  name = 'GettingPushDeviceDetailsFailed';\n  reason: ErrorInfo;\n\n  constructor(reason: ErrorInfo) {\n    this.reason = reason;\n  }\n}\n\nclass GotDeviceRegistration {\n  name = 'GotDeviceRegistration';\n  tokenDetails: API.TokenDetails;\n\n  constructor(deviceRegistration: DeviceRegistration) {\n    this.tokenDetails = deviceRegistration.deviceIdentityToken;\n  }\n}\n\nclass GettingDeviceRegistrationFailed {\n  name = 'GettingDeviceRegistrationFailed';\n  reason: ErrorInfo;\n  constructor(reason: ErrorInfo) {\n    this.reason = reason;\n  }\n}\n\nclass RegistrationSynced {\n  name = 'RegistrationSynced';\n}\n\nclass SyncRegistrationFailed {\n  name = 'SyncRegistrationFailed';\n  reason: ErrorInfo;\n\n  constructor(reason: ErrorInfo) {\n    this.reason = reason;\n  }\n}\n\nclass Deregistered {\n  name = 'Deregistered';\n}\n\nclass DeregistrationFailed {\n  name = 'DeregistrationFailed';\n  reason: ErrorInfo;\n  constructor(reason: ErrorInfo) {\n    this.reason = reason;\n  }\n}\n\ntype ActivationEvent =\n  | CalledActivate\n  | CalledDeactivate\n  | GotPushDeviceDetails\n  | GettingPushDeviceDetailsFailed\n  | GotDeviceRegistration\n  | GettingDeviceRegistrationFailed\n  | RegistrationSynced\n  | SyncRegistrationFailed\n  | Deregistered\n  | DeregistrationFailed;\n\n// States\nabstract class ActivationState {\n  name: ActivationStateName;\n\n  constructor(name: ActivationStateName) {\n    this.name = name;\n  }\n\n  abstract processEvent(machine: ActivationStateMachine, event: ActivationEvent): ActivationState | null;\n}\n\nclass NotActivated extends ActivationState {\n  constructor() {\n    super('NotActivated');\n  }\n\n  processEvent(machine: ActivationStateMachine, event: ActivationEvent): ActivationState | null {\n    if (event instanceof CalledDeactivate) {\n      machine.callDeactivatedCallback(null);\n      return new NotActivated();\n    } else if (event instanceof CalledActivate) {\n      const device = machine.client.device as LocalDevice;\n\n      if (device.deviceIdentityToken != null) {\n        if (device.clientId && device.clientId !== machine.client.auth.clientId) {\n          machine.handleEvent(\n            new SyncRegistrationFailed(\n              new machine.client.ErrorInfo('clientId not compatible with local device clientId', 61002, 400),\n            ),\n          );\n          return null;\n        }\n        // Already registered.\n        machine.pendingEvents.push(event);\n        return new WaitingForNewPushDeviceDetails();\n      }\n\n      if (device.push.recipient) {\n        machine.pendingEvents.push(new GotPushDeviceDetails());\n      } else if (machine.pushConfig.getPushDeviceDetails) {\n        machine.pushConfig.getPushDeviceDetails?.(machine);\n      } else if (machine.pushConfig.platform === DevicePlatform.Browser) {\n        getW3CPushDeviceDetails(machine);\n      } else {\n        machine.handleEvent(\n          new GettingPushDeviceDetailsFailed(\n            new machine.client.ErrorInfo('No available implementation to get push device details', 50000, 500),\n          ),\n        );\n      }\n\n      return new WaitingForPushDeviceDetails();\n    } else if (event instanceof GotPushDeviceDetails) {\n      return new NotActivated();\n    }\n    return null;\n  }\n}\n\nclass WaitingForPushDeviceDetails extends ActivationState {\n  constructor() {\n    super('WaitingForPushDeviceDetails');\n  }\n\n  processEvent(machine: ActivationStateMachine, event: ActivationEvent) {\n    if (event instanceof CalledActivate) {\n      return new WaitingForPushDeviceDetails();\n    } else if (event instanceof CalledDeactivate) {\n      machine.callDeactivatedCallback(null);\n      return new NotActivated();\n    } else if (event instanceof GotPushDeviceDetails) {\n      const client = machine.client;\n      const device = client.device as LocalDevice;\n\n      if (machine.registerCallback) {\n        machine.callCustomRegisterer(device, true);\n      } else {\n        const format = client.options.useBinaryProtocol\n            ? machine.client.Utils.Format.msgpack\n            : machine.client.Utils.Format.json,\n          body = client.rest.DeviceDetails.fromLocalDevice(device),\n          headers = machine.client.Defaults.defaultPostHeaders(client.options, { format }),\n          params = {};\n\n        if (client.options.headers) machine.client.Utils.mixin(headers, client.options.headers);\n\n        if (client.options.pushFullWait) machine.client.Utils.mixin(params, { fullWait: 'true' });\n\n        const requestBody = machine.client.Utils.encodeBody(body, client._MsgPack, format);\n\n        machine.client.rest.Resource.post(client, '/push/deviceRegistrations', requestBody, headers, params, null, true)\n          .then((response) => {\n            const deviceDetails = response.unpacked\n              ? response.body\n              : client.rest.DeviceDetails.fromResponseBody(response.body as any, client._MsgPack, format);\n            machine.handleEvent(new GotDeviceRegistration(deviceDetails as DeviceRegistration));\n          })\n          .catch((err) => {\n            machine.handleEvent(new GettingDeviceRegistrationFailed(err as ErrorInfo));\n          });\n      }\n\n      return new WaitingForDeviceRegistration();\n    } else if (event instanceof GettingPushDeviceDetailsFailed) {\n      machine.callActivatedCallback(event.reason);\n      return new NotActivated();\n    }\n    return null;\n  }\n}\n\nclass WaitingForDeviceRegistration extends ActivationState {\n  constructor() {\n    super('WaitingForDeviceRegistration');\n  }\n\n  processEvent(machine: ActivationStateMachine, event: ActivationEvent) {\n    if (event instanceof CalledActivate) {\n      return new WaitingForDeviceRegistration();\n    } else if (event instanceof GotDeviceRegistration) {\n      const device = machine.client.device as LocalDevice;\n      device.deviceIdentityToken = event.tokenDetails.token;\n      device.persist();\n      machine.callActivatedCallback(null);\n      return new WaitingForNewPushDeviceDetails();\n    } else if (event instanceof GettingDeviceRegistrationFailed) {\n      machine.callActivatedCallback(event.reason);\n      return new NotActivated();\n    }\n    return null;\n  }\n}\n\nclass WaitingForNewPushDeviceDetails extends ActivationState {\n  constructor() {\n    super('WaitingForNewPushDeviceDetails');\n  }\n\n  processEvent(machine: ActivationStateMachine, event: ActivationEvent) {\n    if (event instanceof CalledActivate) {\n      machine.callActivatedCallback(null);\n      return new WaitingForNewPushDeviceDetails();\n    } else if (event instanceof CalledDeactivate) {\n      machine.deregister();\n      return new WaitingForDeregistration(this);\n    } else if (event instanceof GotPushDeviceDetails) {\n      machine.updateRegistration();\n      return new WaitingForRegistrationSync();\n    }\n    return null;\n  }\n}\n\nclass WaitingForRegistrationSync extends ActivationState {\n  triggeredByCalledActivate: boolean | null;\n\n  constructor(triggeredByCalledActivate: boolean | null = false) {\n    super('WaitingForRegistrationSync');\n    this.triggeredByCalledActivate = triggeredByCalledActivate;\n  }\n\n  processEvent(machine: ActivationStateMachine, event: ActivationEvent) {\n    if (event instanceof CalledActivate && !this.triggeredByCalledActivate) {\n      machine.callActivatedCallback(null);\n      return new WaitingForRegistrationSync(true);\n    } else if (event instanceof RegistrationSynced) {\n      return new WaitingForNewPushDeviceDetails();\n    } else if (event instanceof SyncRegistrationFailed) {\n      machine.callUpdateRegistrationFailedCallback(event.reason);\n      return new AfterRegistrationSyncFailed();\n    }\n    return null;\n  }\n}\n\nclass AfterRegistrationSyncFailed extends ActivationState {\n  constructor() {\n    super('AfterRegistrationSyncFailed');\n  }\n\n  processEvent(machine: ActivationStateMachine, event: ActivationEvent) {\n    if (event instanceof CalledActivate || event instanceof GotPushDeviceDetails) {\n      machine.updateRegistration();\n      return new WaitingForRegistrationSync(event instanceof CalledActivate);\n    } else if (event instanceof CalledDeactivate) {\n      machine.deregister();\n      return new WaitingForDeregistration(this);\n    }\n    return null;\n  }\n}\n\nclass WaitingForDeregistration extends ActivationState {\n  previousState: ActivationState | null;\n\n  constructor(previousState: ActivationState | null) {\n    super('WaitingForDeregistration');\n    this.previousState = previousState;\n  }\n\n  processEvent(machine: ActivationStateMachine, event: ActivationEvent): ActivationState | null {\n    if (event instanceof CalledDeactivate) {\n      return new WaitingForDeregistration(this.previousState);\n    } else if (event instanceof Deregistered) {\n      const device = machine.client.device as LocalDevice;\n      delete device.deviceIdentityToken;\n      delete device.push.recipient;\n      device.resetId();\n      device.persist();\n      machine.callDeactivatedCallback(null);\n      return new NotActivated();\n    } else if (event instanceof DeregistrationFailed) {\n      machine.callDeactivatedCallback(event.reason);\n      return this.previousState;\n    }\n    return null;\n  }\n}\n\ntype ActivationStateName =\n  | 'NotActivated'\n  | 'WaitingForPushDeviceDetails'\n  | 'WaitingForDeviceRegistration'\n  | 'WaitingForNewPushDeviceDetails'\n  | 'WaitingForRegistrationSync'\n  | 'AfterRegistrationSyncFailed'\n  | 'WaitingForDeregistration';\n\nexport const ActivationStates = {\n  NotActivated,\n  WaitingForPushDeviceDetails,\n  WaitingForDeviceRegistration,\n  WaitingForNewPushDeviceDetails,\n  WaitingForRegistrationSync,\n  AfterRegistrationSyncFailed,\n  WaitingForDeregistration,\n};\n\nfunction isPersistentState(state: ActivationState) {\n  return state.name == 'NotActivated' || state.name == 'WaitingForNewPushDeviceDetails';\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;60BAAA,IAAAA,EAAAC,GAAA,QCAA,IAAAC,GAAA,GAAAC,GAAAD,GAAA,4BAAAE,EAAA,mBAAAC,EAAA,qBAAAC,EAAA,gBAAAC,EAAA,YAAAC,GAAA,4BAAAC,EAAA,uBAAAC,IAAA,eAAAC,GAAAT,ICKA,IAAMU,EAAN,KAAkB,CAIhB,YAAYC,EAAwC,CAClD,KAAK,QAAUA,EACf,KAAK,OAASA,EAAQ,MACxB,CAEA,MAAM,iBAAkB,CACtB,IAAMC,EAAS,KAAK,OACdC,EAASD,EAAO,OAChBE,EAASF,EAAO,QAAQ,kBAAoBA,EAAO,MAAM,OAAO,QAAUA,EAAO,MAAM,OAAO,KAClGG,EAAO,CAAE,SAAUF,EAAO,GAAI,QAAS,KAAK,QAAQ,IAAK,EACzDG,EAAUJ,EAAO,SAAS,mBAAmBA,EAAO,QAAS,CAAE,OAAAE,CAAO,CAAC,EAErEF,EAAO,QAAQ,SAASA,EAAO,MAAM,MAAMI,EAASJ,EAAO,QAAQ,OAAO,EAE9EA,EAAO,MAAM,MAAMI,EAAS,KAAK,oBAAoB,CAAC,EAEtD,IAAMC,EAAcL,EAAO,MAAM,WAAWG,EAAMH,EAAO,SAAUE,CAAM,EACzE,MAAMF,EAAO,KAAK,SAAS,KAAKA,EAAQ,6BAA8BK,EAAaD,EAAS,CAAC,EAAGF,EAAQ,EAAI,CAC9G,CAEA,MAAM,mBAAoB,CACxB,IAAMF,EAAS,KAAK,OACdC,EAASD,EAAO,OAChBE,EAASF,EAAO,QAAQ,kBAAoBA,EAAO,MAAM,OAAO,QAAUA,EAAO,MAAM,OAAO,KAClGI,EAAUJ,EAAO,SAAS,mBAAmBA,EAAO,QAAS,CAAE,OAAAE,CAAO,CAAC,EAErEF,EAAO,QAAQ,SAASA,EAAO,MAAM,MAAMI,EAASJ,EAAO,QAAQ,OAAO,EAE9EA,EAAO,MAAM,MAAMI,EAAS,KAAK,oBAAoB,CAAC,EAEtD,MAAMJ,EAAO,KAAK,SAAS,OACzBA,EACA,6BACAI,EACA,CAAE,SAAUH,EAAO,GAAI,QAAS,KAAK,QAAQ,IAAK,EAClDC,EACA,EACF,CACF,CAEA,MAAM,iBAAkB,CACtB,IAAMF,EAAS,KAAK,OACdM,EAAW,KAAK,OAAO,KAAK,SAClC,GAAI,CAACA,EACH,MAAM,IAAI,KAAK,OAAO,UAAU,iDAAkD,IAAO,GAAG,EAE9F,IAAMJ,EAASF,EAAO,QAAQ,kBAAoBA,EAAO,MAAM,OAAO,QAAUA,EAAO,MAAM,OAAO,KAClGG,EAAO,CAAE,SAAUG,EAAU,QAAS,KAAK,QAAQ,IAAK,EACxDF,EAAUJ,EAAO,SAAS,mBAAmBA,EAAO,QAAS,CAAE,OAAAE,CAAO,CAAC,EAErEF,EAAO,QAAQ,SAASA,EAAO,MAAM,MAAMI,EAASJ,EAAO,QAAQ,OAAO,EAE9E,IAAMK,EAAcL,EAAO,MAAM,WAAWG,EAAMH,EAAO,SAAUE,CAAM,EACzE,MAAMF,EAAO,KAAK,SAAS,KAAKA,EAAQ,6BAA8BK,EAAaD,EAAS,CAAC,EAAGF,EAAQ,EAAI,CAC9G,CAEA,MAAM,mBAAoB,CACxB,IAAMF,EAAS,KAAK,OAEdM,EAAW,KAAK,OAAO,KAAK,SAClC,GAAI,CAACA,EACH,MAAM,IAAI,KAAK,OAAO,UAAU,mDAAoD,IAAO,GAAG,EAEhG,IAAMJ,EAASF,EAAO,QAAQ,kBAAoBA,EAAO,MAAM,OAAO,QAAUA,EAAO,MAAM,OAAO,KAClGI,EAAUJ,EAAO,SAAS,mBAAmBA,EAAO,QAAS,CAAE,OAAAE,CAAO,CAAC,EAErEF,EAAO,QAAQ,SAASA,EAAO,MAAM,MAAMI,EAASJ,EAAO,QAAQ,OAAO,EAE9E,MAAMA,EAAO,KAAK,SAAS,OACzBA,EACA,6BACAI,EACA,CAAE,SAAUE,EAAU,QAAS,KAAK,QAAQ,IAAK,EACjDJ,EACA,EACF,CACF,CAEA,MAAM,kBAAkBK,EAAiC,CACvD,YAAK,OAAO,OAAO,UACjB,KAAK,OAAO,OACZ,KAAK,OAAO,OAAO,UACnB,kCACA,aAAe,KAAK,QAAQ,IAC9B,EAEO,KAAK,OAAO,KAAK,MAAM,qBAAqB,KAAKC,EAAAC,EAAA,GACnDF,GADmD,CAEtD,QAAS,KAAK,QAAQ,KACtB,cAAe,EACjB,EAAC,CACH,CAEQ,yBAA0B,CAEhC,IAAMG,EADS,KAAK,OAAO,OACQ,oBACnC,GAAIA,EACF,OAAOA,EAEP,MAAM,IAAI,KAAK,OAAO,UAAU,2DAA4D,IAAO,GAAG,CAE1G,CAEQ,qBAAsB,CAE5B,MAAO,CAAE,qBADmB,KAAK,wBAAwB,CACN,CACrD,CACF,EAEOC,EAAQb,ECpHf,SAASc,EAAYC,EAA0B,CAC7C,IAAMC,EAAS,IAAI,WAAWD,EAAY,MAAM,EAAGA,EAAY,UAAU,CAAC,EAC1E,OAAO,KAAK,OAAO,aAAa,MAAM,KAAM,MAAM,KAAKC,CAAM,CAAC,CAAC,CACjE,CAEA,SAASC,GAAkBC,EAAsB,CAC/C,IAAMC,EAAU,IAAI,QAAQ,EAAKD,EAAa,OAAS,GAAM,CAAC,EAE9D,OADgBA,EAAeC,GAAS,QAAQ,KAAM,GAAG,EAAE,QAAQ,KAAM,GAAG,CAE9E,CAEA,SAASC,GAAmBF,EAAsB,CAChD,IAAMG,EAAU,OAAO,KAAKH,CAAY,EAClCI,EAAe,CAAC,EACtB,QAASC,EAAI,EAAGA,EAAIF,EAAQ,OAAQE,IAClCD,EAAa,KAAKD,EAAQE,CAAC,EAAE,WAAW,CAAC,CAAC,EAE5C,OAAO,WAAW,KAAKD,CAAY,CACrC,CAEA,eAAsBE,EAAwBC,EAAiC,CAC7E,IAAMC,EAAiCD,EAAQ,+BACzCE,EAAuBF,EAAQ,qBAC/B,CAAE,UAAAG,EAAW,SAAAC,CAAS,EAAIJ,EAAQ,OAIxC,GAFmB,MAAM,aAAa,kBAAkB,IAErC,UAAW,CAC5BA,EAAQ,YACN,IAAIC,EAA+B,IAAIE,EAAU,+CAAgD,IAAK,GAAK,CAAC,CAC9G,EACA,MACF,CAEA,IAAME,EAAQL,EAAQ,OAAO,QAAQ,qBACrC,GAAI,CAACK,EAAO,CACVL,EAAQ,YACN,IAAIC,EAA+B,IAAIE,EAAU,6CAA8C,IAAK,GAAK,CAAC,CAC5G,EACA,MACF,CAEA,GAAI,CACF,IAAMG,EAAS,MAAM,UAAU,cAAc,SAASD,CAAK,EAE3DL,EAAQ,aAAeM,EAAO,YAE9B,IAAMC,EAAUH,EAAS,kBAAkBJ,EAAQ,OAAO,QAAS,CAAE,OAAQ,MAAO,CAAC,EAC/EQ,GACJ,MAAMR,EAAQ,OAAO,KAAK,SAAS,IAAIA,EAAQ,OAAQ,uBAAwBO,EAAS,CAAC,EAAG,KAAM,EAAI,GACtG,KAEGD,EAAO,QACV,MAAM,UAAU,cAAc,MAGhC,IAAMG,EAAe,MAAMH,EAAO,YAAY,UAAU,CACtD,gBAAiB,GACjB,qBAAsBX,GAAmBH,GAAkBgB,CAAY,CAAC,CAC1E,CAAC,EAEKE,EAAWD,EAAa,SAExB,CAACE,EAAQC,CAAI,EAAI,CAACH,EAAa,OAAO,QAAQ,EAAGA,EAAa,OAAO,MAAM,CAAC,EAElF,GAAI,CAACE,GAAU,CAACC,EACd,MAAM,IAAIT,EAAU,uBAAwB,IAAO,GAAG,EAGxD,IAAMU,EAASb,EAAQ,OAAO,OAC9Ba,EAAO,KAAK,UAAY,CACtB,cAAe,MACf,UAAW,KAAKH,CAAQ,EACxB,eAAgBF,EAChB,cAAe,CACb,OAAQnB,EAAYsB,CAAM,EAC1B,KAAMtB,EAAYuB,CAAI,CACxB,CACF,EACAC,EAAO,QAAQ,EAEfb,EAAQ,YAAY,IAAIE,CAAsB,CAChD,OAASY,EAAK,CACZd,EAAQ,YACN,IAAIC,EAA+B,IAAIE,EAAU,oCAAqC,IAAO,IAAKW,CAAY,CAAC,CACjH,CACF,CACF,CCzFA,SAASC,EAAYC,EAAS,CAC1B,IAAIC,EAAM,IAAI,MAAMD,CAAO,EAC3B,OAAAC,EAAI,OAAS,OACNA,CACX,CAGA,IAAIC,EAAW,mCACXC,EAAeD,EAAS,OACxBE,EAAW,KAAK,IAAI,EAAG,EAAE,EAAI,EAC7BC,GAAW,GACXC,GAAa,GA8BjB,SAASC,GAAWC,EAAM,CACtB,IAAIC,EAAO,KAAK,MAAMD,EAAK,EAAIE,CAAY,EAC3C,OAAID,IAASC,IACTD,EAAOC,EAAe,GAEnBC,EAAS,OAAOF,CAAI,CAC/B,CACA,SAASG,GAAWC,EAAKC,EAAK,CAC1B,GAAI,MAAMD,CAAG,EACT,MAAM,IAAI,MAAMA,EAAM,mBAAmB,EAE7C,GAAIA,EAAME,EACN,MAAMC,EAAY,mCAAqCD,CAAQ,EAEnE,GAAIF,EAAM,EACN,MAAMG,EAAY,uBAAuB,EAE7C,GAAI,OAAO,UAAUH,CAAG,IAAM,GAC1B,MAAMG,EAAY,yBAAyB,EAI/C,QAFIC,EAAM,OACNC,EAAM,GACHJ,EAAM,EAAGA,IACZG,EAAMJ,EAAMH,EACZQ,EAAMP,EAAS,OAAOM,CAAG,EAAIC,EAC7BL,GAAOA,EAAMI,GAAOP,EAExB,OAAOQ,CACX,CACA,SAASC,GAAaL,EAAKN,EAAM,CAE7B,QADIU,EAAM,GACHJ,EAAM,EAAGA,IACZI,EAAMX,GAAWC,CAAI,EAAIU,EAE7B,OAAOA,CACX,CAiBA,SAASE,IAAa,CAClB,IAAIC,EAAgB,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAY,UAAU,CAAC,EAAI,GACpFC,EAAO,UAAU,CAAC,EAEjBA,IACDA,EAAO,OAAO,QAAW,YAAc,OAAS,MAEpD,IAAIC,EAAgBD,IAASA,EAAK,QAAUA,EAAK,UACjD,GAAIC,EACA,OAAO,UAAY,CACf,IAAIC,EAAS,IAAI,WAAW,CAAC,EAC7B,OAAAD,EAAc,gBAAgBC,CAAM,EAC7BA,EAAO,CAAC,EAAI,GACvB,EAEA,GAAI,CACA,IAAIC,EAAa,IACjB,OAAO,UAAY,CACf,OAAOA,EAAW,YAAY,CAAC,EAAE,UAAU,EAAI,GACnD,CACJ,OAASC,EAAG,CAAC,CAEjB,GAAIL,EAAe,CACf,GAAI,CACA,QAAQ,MAAM,iEAAiE,CACnF,OAASK,EAAG,CAAC,CACb,OAAO,UAAY,CACf,OAAO,KAAK,OAAO,CACvB,CACJ,CACA,MAAMC,EAAY,0DAA0D,CAChF,CACA,SAASC,GAAQC,EAAU,CACvB,OAAKA,IACDA,EAAWT,GAAW,GAEnB,SAAcU,EAAU,CAC3B,OAAI,MAAMA,CAAQ,IACdA,EAAW,KAAK,IAAI,GAEjBC,GAAWD,EAAUE,EAAQ,EAAIC,GAAaC,GAAYL,CAAQ,CAC7E,CACJ,CAoBA,IAAIM,EAAOC,GAAQ,EClJnB,IAAMC,EAAc,CAClB,SAAU,qBACV,aAAc,yBACd,oBAAqB,gCACrB,cAAe,0BACf,gBAAiB,2BACnB,EAuBO,SAASC,EAAmBC,EAAqC,CACtE,OAAO,MAAMC,UAAoBD,CAAc,CAIrC,YAAYE,EAAkB,CACpC,MAAM,EACN,KAAK,KAAO,CAAC,EACb,KAAK,KAAOA,CACd,CAEA,OAAO,KAAKA,EAAkB,CAC5B,IAAMC,EAAS,IAAIF,EAAYC,CAAI,EACnC,OAAAC,EAAO,cAAc,EACdA,CACT,CAEA,eAAgB,CAvDpB,IAAAC,EAwDM,IAAMC,EAAW,KAAK,KAAK,SAC3B,GAAI,CAACA,EAAS,OAAO,KACnB,MAAM,IAAI,KAAK,KAAK,UAAU,oDAAqD,IAAO,GAAG,EAE/F,KAAK,SAAWA,EAAS,OAAO,KAAK,SACrC,KAAK,UAAWD,EAAA,KAAK,KAAK,KAAK,WAAf,KAAAA,EAA2B,OAC3C,KAAK,WAAaC,EAAS,OAAO,KAAK,WACvC,KAAK,GAAKA,EAAS,OAAO,KAAK,QAAQ,IAAIP,EAAY,QAAQ,EAE3D,KAAK,IACP,KAAK,aAAeO,EAAS,OAAO,KAAK,QAAQ,IAAIP,EAAY,YAAY,GAAK,OAClF,KAAK,oBAAsB,KAAK,MAC9BO,EAAS,OAAO,KAAK,QAAQ,IAAIP,EAAY,mBAAmB,GAAK,MACvE,EACA,KAAK,KAAK,UAAY,KAAK,MAAMO,EAAS,OAAO,KAAK,QAAQ,IAAIP,EAAY,aAAa,GAAK,MAAM,GAEtG,KAAK,QAAQ,CAEjB,CAEA,SAAU,CACR,IAAMQ,EAAS,KAAK,KAAK,SAAS,OAClC,GAAI,CAACA,EAAO,KACV,MAAM,IAAI,KAAK,KAAK,UAAU,oDAAqD,IAAO,GAAG,EAE3F,KAAK,IACPA,EAAO,KAAK,QAAQ,IAAIR,EAAY,SAAU,KAAK,EAAE,EAEnD,KAAK,cACPQ,EAAO,KAAK,QAAQ,IAAIR,EAAY,aAAc,KAAK,YAAY,EAEjE,KAAK,qBACPQ,EAAO,KAAK,QAAQ,IAAIR,EAAY,oBAAqB,KAAK,UAAU,KAAK,mBAAmB,CAAC,EAE/F,KAAK,KAAK,WACZQ,EAAO,KAAK,QAAQ,IAAIR,EAAY,cAAe,KAAK,UAAU,KAAK,KAAK,SAAS,CAAC,CAE1F,CAEA,SAAU,CACR,KAAK,GAAKS,EAAK,EACf,KAAK,aAAeA,EAAK,EACzB,KAAK,QAAQ,CACf,CAEA,eACEL,EACAM,EACAC,EACwB,CACxB,GAAI,CAAC,KAAK,oBACR,MAAM,IAAI,KAAK,KAAK,UAAU,+DAAgE,IAAO,GAAG,EAE1G,OAAI,KAAK,KAAK,KAAK,oBACV,CACL,QAASP,EAAK,MAAM,MAClB,CAAE,cAAe,UAAYA,EAAK,MAAM,SAAS,KAAK,mBAAmB,CAAE,EAC3EM,CACF,EACA,OAAAC,CACF,EAEO,CAAE,QAAAD,EAAS,OAAQN,EAAK,MAAM,MAAM,CAAE,aAAc,KAAK,mBAAoB,EAAGO,CAAM,CAAE,CAEnG,CACF,CACF,CAEO,IAAMC,EAAN,KAA6B,CAmBlC,YAAYR,EAAkB,CAH9B,oCAAiCS,EACjC,0BAAuBC,EAGrB,KAAK,OAASV,EACd,KAAK,YAAcA,EAAK,SAAS,OAAO,KACxC,KAAK,QAAU,IAAIW,GAChB,KAAK,WAAW,QAAQ,IAAIf,EAAY,eAAe,GAA6B,cACvF,EAAE,IAAI,EACN,KAAK,cAAgB,CAAC,EACtB,KAAK,SAAW,EAClB,CAEA,IAAI,YAAa,CACf,GAAI,CAAC,KAAK,YACR,MAAM,IAAI,KAAK,OAAO,UAAU,mEAAoE,IAAO,GAAG,EAEhH,OAAO,KAAK,WACd,CAEA,SAAU,CACJgB,GAAkB,KAAK,OAAO,GAChC,KAAK,WAAW,QAAQ,IAAIhB,EAAY,gBAAiB,KAAK,QAAQ,IAAI,CAE9E,CAEA,qCAAqCiB,EAAmB,CAClD,KAAK,qBACP,KAAK,qBAAqBA,CAAM,EAEhC,KAAK,OAAO,OAAO,UACjB,KAAK,OAAO,OACZ,KAAK,OAAO,OAAO,UACnB,2BACA,6CAA+C,KAAK,OAAO,MAAM,aAAaA,CAAM,CACtF,CAEJ,CAEA,qBAAqBZ,EAAqBa,EAAgB,CAnL5D,IAAAZ,GAoLIA,EAAA,KAAK,mBAAL,MAAAA,EAAA,UAAwBD,EAAQ,CAACc,EAAkBC,IAA4C,CAC7F,GAAID,EAAO,CACLD,EACF,KAAK,YAAY,IAAIG,EAAgCF,CAAK,CAAC,EAE3D,KAAK,YAAY,IAAIG,EAAuBH,CAAK,CAAC,EAEpD,MACF,CAEKC,GACH,KAAK,YACH,IAAIC,EACF,IAAI,KAAK,OAAO,UAAU,qDAAsD,IAAO,GAAG,CAC5F,CACF,EAGEH,EACF,KAAK,YAAY,IAAIK,EAAsBH,CAAyB,CAAC,EAErE,KAAK,YAAY,IAAII,CAAoB,CAE7C,EACF,CAEA,uBAAuBnB,EAAqB,CA9M9C,IAAAC,GA+MIA,EAAA,KAAK,qBAAL,MAAAA,EAAA,UAA0BD,EAASoB,GAAmB,CACpD,GAAIA,EAAK,CACP,KAAK,YAAY,IAAIC,EAAqBD,CAAG,CAAC,EAC9C,MACF,CACA,KAAK,YAAY,IAAIE,CAAc,CACrC,EACF,CAEA,MAAM,oBAAqB,CACzB,IAAMC,EAAc,KAAK,OAAO,OAChC,GAAI,KAAK,iBACP,KAAK,qBAAqBA,EAAa,EAAK,MACvC,CACL,IAAMC,EAAS,KAAK,OACdC,EAASD,EAAO,QAAQ,kBACxB,KAAK,OAAO,MAAM,OAAO,QACzB,KAAK,OAAO,MAAM,OAAO,KAC7BE,EAAOF,EAAO,KAAK,cAAc,gBAAgBD,CAAW,EAC5DlB,EAAU,KAAK,OAAO,SAAS,mBAAmB,KAAK,OAAO,QAAS,CAAE,OAAAoB,CAAO,CAAC,EACjFnB,EAAS,CAAC,EAERkB,EAAO,QAAQ,SACjB,KAAK,OAAO,MAAM,MAAMnB,EAASmB,EAAO,QAAQ,OAAO,EAGrDA,EAAO,QAAQ,cACjB,KAAK,OAAO,MAAM,MAAMlB,EAAQ,CAAE,SAAU,MAAO,CAAC,EAGtD,IAAMqB,EAAc,KAAK,OAAO,MAAM,WAAWD,EAAMF,EAAO,SAAUC,CAAM,EACxEG,EAAcL,EAAY,eAAeC,EAAQnB,EAASC,CAAM,EACtE,GAAI,CACF,IAAMuB,EAAW,MAAM,KAAK,OAAO,KAAK,SAAS,MAC/CL,EACA,4BACAG,EACAC,EAAY,QACZA,EAAY,OACZH,EACA,EACF,EACA,KAAK,YAAY,IAAIP,EAAsBW,EAAS,IAA0B,CAAC,CACjF,OAAST,EAAK,CACZ,KAAK,YAAY,IAAIJ,EAAgCI,CAAgB,CAAC,CACxE,CACF,CACF,CAEA,MAAM,YAAa,CACjB,IAAMpB,EAAS,KAAK,OAAO,OAC3B,GAAI,KAAK,mBACP,KAAK,uBAAuBA,CAAM,MAC7B,CACL,IAAMD,EAAO,KAAK,OACZ0B,EAAS1B,EAAK,QAAQ,kBAAoB,KAAK,OAAO,MAAM,OAAO,QAAU,KAAK,OAAO,MAAM,OAAO,KAC1GM,EAAU,KAAK,OAAO,SAAS,mBAAmBN,EAAK,QAAS,CAAE,OAAA0B,CAAO,CAAC,EAC1EnB,EAAS,CAAE,SAAUN,EAAO,EAAG,EAE7BD,EAAK,QAAQ,SAAS,KAAK,OAAO,MAAM,MAAMM,EAASN,EAAK,QAAQ,OAAO,EAE3EA,EAAK,QAAQ,cAAc,KAAK,OAAO,MAAM,MAAMO,EAAQ,CAAE,SAAU,MAAO,CAAC,EAEnF,GAAI,CACF,MAAM,KAAK,OAAO,KAAK,SAAS,OAAOP,EAAM,4BAA6BM,EAASC,EAAQmB,EAAQ,EAAI,EACvG,KAAK,YAAY,IAAIH,CAAc,CACrC,OAASF,EAAK,CACZ,KAAK,YAAY,IAAIC,EAAqBD,CAAgB,CAAC,CAC7D,CACF,CACF,CAEA,sBAAsBA,EAAuB,CAvR/C,IAAAnB,GAwRIA,EAAA,KAAK,oBAAL,MAAAA,EAAA,UAAyBmB,GACzB,OAAO,KAAK,iBACd,CAEA,wBAAwBA,EAAuB,CA5RjD,IAAAnB,GA6RIA,EAAA,KAAK,sBAAL,MAAAA,EAAA,UAA2BmB,GAC3B,OAAO,KAAK,mBACd,CAEA,YAAYU,EAAwB,CAClC,GAAI,KAAK,SAAU,CACjB,KAAK,OAAO,SAAS,OAAO,SAAS,IAAM,CACzC,KAAK,YAAYA,CAAK,CACxB,CAAC,EACD,MACF,CAEA,KAAK,SAAW,GAChB,KAAK,OAAO,OAAO,UACjB,KAAK,OAAO,OACZ,KAAK,OAAO,OAAO,UACnB,4CACA,kBAAoBA,EAAM,KAAO,SAAW,KAAK,QAAQ,IAC3D,EAEA,IAAIC,EAAY,KAAK,QAAQ,aAAa,KAAMD,CAAK,EACrD,GAAI,CAACC,EAAW,CACd,KAAK,OAAO,OAAO,UACjB,KAAK,OAAO,OACZ,KAAK,OAAO,OAAO,UACnB,4CACA,mBAAqBD,EAAM,IAC7B,EACA,KAAK,cAAc,KAAKA,CAAK,EAC7B,KAAK,SAAW,GAChB,MACF,CAUA,IARA,KAAK,OAAO,OAAO,UACjB,KAAK,OAAO,OACZ,KAAK,OAAO,OAAO,UACnB,4CACA,eAAiB,KAAK,QAAQ,KAAO,MAAQA,EAAM,KAAO,OAASC,EAAU,IAC/E,EACA,KAAK,QAAUA,EAER,KAAK,cAAc,OAAS,GAAG,CACpC,IAAMC,EAAU,KAAK,cAAc,CAAC,EAUpC,GARA,KAAK,OAAO,OAAO,UACjB,KAAK,OAAO,OACZ,KAAK,OAAO,OAAO,UACnB,4CACA,wCAA0CA,EAAQ,IACpD,EAEAD,EAAY,KAAK,QAAQ,aAAa,KAAMC,CAAO,EAC/C,CAACD,EACH,MAEF,KAAK,cAAc,OAAO,EAAG,CAAC,EAE9B,KAAK,OAAO,OAAO,UACjB,KAAK,OAAO,OACZ,KAAK,OAAO,OAAO,UACnB,4CACA,eAAiB,KAAK,QAAQ,KAAO,MAAQC,EAAQ,KAAO,OAASD,EAAU,IACjF,EACA,KAAK,QAAUA,CACjB,CAEA,KAAK,QAAQ,EACb,KAAK,SAAW,EAClB,CACF,EAGaE,EAAN,KAAqB,CAG1B,YAAYC,EAAiCC,EAAqC,CAFlF,UAAO,iBAGDA,IACFD,EAAQ,iBAAmBC,GAE7BD,EAAQ,QAAQ,CAClB,CACF,EAEaE,EAAN,KAAuB,CAG5B,YAAYF,EAAiCG,EAAyC,CAFtF,UAAO,mBAGLH,EAAQ,mBAAqBG,EAC7BH,EAAQ,QAAQ,CAClB,CACF,EAEazB,EAAN,KAA2B,CAA3B,cACL,UAAO,uBACT,EAEaD,EAAN,KAAqC,CAI1C,YAAYI,EAAmB,CAH/B,UAAO,iCAIL,KAAK,OAASA,CAChB,CACF,EAEMM,EAAN,KAA4B,CAI1B,YAAYH,EAAwC,CAHpD,UAAO,wBAIL,KAAK,aAAeA,EAAmB,mBACzC,CACF,EAEMC,EAAN,KAAsC,CAGpC,YAAYJ,EAAmB,CAF/B,UAAO,kCAGL,KAAK,OAASA,CAChB,CACF,EAEMO,EAAN,KAAyB,CAAzB,cACE,UAAO,qBACT,EAEMF,EAAN,KAA6B,CAI3B,YAAYL,EAAmB,CAH/B,UAAO,yBAIL,KAAK,OAASA,CAChB,CACF,EAEMU,EAAN,KAAmB,CAAnB,cACE,UAAO,eACT,EAEMD,EAAN,KAA2B,CAGzB,YAAYT,EAAmB,CAF/B,UAAO,uBAGL,KAAK,OAASA,CAChB,CACF,EAee0B,EAAf,KAA+B,CAG7B,YAAYC,EAA2B,CACrC,KAAK,KAAOA,CACd,CAGF,EAEMC,EAAN,MAAMC,UAAqBH,CAAgB,CACzC,aAAc,CACZ,MAAM,cAAc,CACtB,CAEA,aAAaJ,EAAiCJ,EAAgD,CA5chG,IAAA7B,EAAAyC,EA6cI,GAAIZ,aAAiBM,EACnB,OAAAF,EAAQ,wBAAwB,IAAI,EAC7B,IAAIO,EACN,GAAIX,aAAiBG,EAAgB,CAC1C,IAAMjC,EAASkC,EAAQ,OAAO,OAE9B,OAAIlC,EAAO,qBAAuB,KAC5BA,EAAO,UAAYA,EAAO,WAAakC,EAAQ,OAAO,KAAK,UAC7DA,EAAQ,YACN,IAAIjB,EACF,IAAIiB,EAAQ,OAAO,UAAU,qDAAsD,MAAO,GAAG,CAC/F,CACF,EACO,OAGTA,EAAQ,cAAc,KAAKJ,CAAK,EACzB,IAAIa,IAGT3C,EAAO,KAAK,UACdkC,EAAQ,cAAc,KAAK,IAAIzB,CAAsB,EAC5CyB,EAAQ,WAAW,sBAC5BQ,GAAAzC,EAAAiC,EAAQ,YAAW,uBAAnB,MAAAQ,EAAA,KAAAzC,EAA0CiC,GACjCA,EAAQ,WAAW,qBAC5BU,EAAwBV,CAAO,EAE/BA,EAAQ,YACN,IAAI1B,EACF,IAAI0B,EAAQ,OAAO,UAAU,yDAA0D,IAAO,GAAG,CACnG,CACF,EAGK,IAAIW,EACb,SAAWf,aAAiBrB,EAC1B,OAAO,IAAIgC,EAEb,OAAO,IACT,CACF,EAEMI,EAAN,MAAMC,UAAoCR,CAAgB,CACxD,aAAc,CACZ,MAAM,6BAA6B,CACrC,CAEA,aAAaJ,EAAiCJ,EAAwB,CACpE,GAAIA,aAAiBG,EACnB,OAAO,IAAIa,EACN,GAAIhB,aAAiBM,EAC1B,OAAAF,EAAQ,wBAAwB,IAAI,EAC7B,IAAIM,EACN,GAAIV,aAAiBrB,EAAsB,CAChD,IAAMe,EAASU,EAAQ,OACjBlC,EAASwB,EAAO,OAEtB,GAAIU,EAAQ,iBACVA,EAAQ,qBAAqBlC,EAAQ,EAAI,MACpC,CACL,IAAMyB,EAASD,EAAO,QAAQ,kBACxBU,EAAQ,OAAO,MAAM,OAAO,QAC5BA,EAAQ,OAAO,MAAM,OAAO,KAChCR,EAAOF,EAAO,KAAK,cAAc,gBAAgBxB,CAAM,EACvDK,EAAU6B,EAAQ,OAAO,SAAS,mBAAmBV,EAAO,QAAS,CAAE,OAAAC,CAAO,CAAC,EAC/EnB,EAAS,CAAC,EAERkB,EAAO,QAAQ,SAASU,EAAQ,OAAO,MAAM,MAAM7B,EAASmB,EAAO,QAAQ,OAAO,EAElFA,EAAO,QAAQ,cAAcU,EAAQ,OAAO,MAAM,MAAM5B,EAAQ,CAAE,SAAU,MAAO,CAAC,EAExF,IAAMqB,EAAcO,EAAQ,OAAO,MAAM,WAAWR,EAAMF,EAAO,SAAUC,CAAM,EAEjFS,EAAQ,OAAO,KAAK,SAAS,KAAKV,EAAQ,4BAA6BG,EAAatB,EAASC,EAAQ,KAAM,EAAI,EAC5G,KAAMuB,GAAa,CAClB,IAAMhC,EAAgBgC,EAAS,SAC3BA,EAAS,KACTL,EAAO,KAAK,cAAc,iBAAiBK,EAAS,KAAaL,EAAO,SAAUC,CAAM,EAC5FS,EAAQ,YAAY,IAAIhB,EAAsBrB,CAAmC,CAAC,CACpF,CAAC,EACA,MAAOuB,GAAQ,CACdc,EAAQ,YAAY,IAAIlB,EAAgCI,CAAgB,CAAC,CAC3E,CAAC,CACL,CAEA,OAAO,IAAI2B,CACb,SAAWjB,aAAiBtB,EAC1B,OAAA0B,EAAQ,sBAAsBJ,EAAM,MAAM,EACnC,IAAIU,EAEb,OAAO,IACT,CACF,EAEMO,EAAN,MAAMC,UAAqCV,CAAgB,CACzD,aAAc,CACZ,MAAM,8BAA8B,CACtC,CAEA,aAAaJ,EAAiCJ,EAAwB,CACpE,GAAIA,aAAiBG,EACnB,OAAO,IAAIe,EACN,GAAIlB,aAAiBZ,EAAuB,CACjD,IAAMlB,EAASkC,EAAQ,OAAO,OAC9B,OAAAlC,EAAO,oBAAsB8B,EAAM,aAAa,MAChD9B,EAAO,QAAQ,EACfkC,EAAQ,sBAAsB,IAAI,EAC3B,IAAIS,CACb,SAAWb,aAAiBd,EAC1B,OAAAkB,EAAQ,sBAAsBJ,EAAM,MAAM,EACnC,IAAIU,EAEb,OAAO,IACT,CACF,EAEMG,EAAN,MAAMM,UAAuCX,CAAgB,CAC3D,aAAc,CACZ,MAAM,gCAAgC,CACxC,CAEA,aAAaJ,EAAiCJ,EAAwB,CACpE,OAAIA,aAAiBG,GACnBC,EAAQ,sBAAsB,IAAI,EAC3B,IAAIe,GACFnB,aAAiBM,GAC1BF,EAAQ,WAAW,EACZ,IAAIgB,EAAyB,IAAI,GAC/BpB,aAAiBrB,GAC1ByB,EAAQ,mBAAmB,EACpB,IAAIiB,GAEN,IACT,CACF,EAEMA,EAAN,MAAMC,UAAmCd,CAAgB,CAGvD,YAAYe,EAA4C,GAAO,CAC7D,MAAM,4BAA4B,EAClC,KAAK,0BAA4BA,CACnC,CAEA,aAAanB,EAAiCJ,EAAwB,CACpE,OAAIA,aAAiBG,GAAkB,CAAC,KAAK,2BAC3CC,EAAQ,sBAAsB,IAAI,EAC3B,IAAIkB,EAA2B,EAAI,GACjCtB,aAAiBX,EACnB,IAAIwB,EACFb,aAAiBb,GAC1BiB,EAAQ,qCAAqCJ,EAAM,MAAM,EAClD,IAAIwB,GAEN,IACT,CACF,EAEMA,EAAN,cAA0ChB,CAAgB,CACxD,aAAc,CACZ,MAAM,6BAA6B,CACrC,CAEA,aAAaJ,EAAiCJ,EAAwB,CACpE,OAAIA,aAAiBG,GAAkBH,aAAiBrB,GACtDyB,EAAQ,mBAAmB,EACpB,IAAIiB,EAA2BrB,aAAiBG,CAAc,GAC5DH,aAAiBM,GAC1BF,EAAQ,WAAW,EACZ,IAAIgB,EAAyB,IAAI,GAEnC,IACT,CACF,EAEMA,EAAN,MAAMK,UAAiCjB,CAAgB,CAGrD,YAAYkB,EAAuC,CACjD,MAAM,0BAA0B,EAChC,KAAK,cAAgBA,CACvB,CAEA,aAAatB,EAAiCJ,EAAgD,CAC5F,GAAIA,aAAiBM,EACnB,OAAO,IAAImB,EAAyB,KAAK,aAAa,EACjD,GAAIzB,aAAiBR,EAAc,CACxC,IAAMtB,EAASkC,EAAQ,OAAO,OAC9B,cAAOlC,EAAO,oBACd,OAAOA,EAAO,KAAK,UACnBA,EAAO,QAAQ,EACfA,EAAO,QAAQ,EACfkC,EAAQ,wBAAwB,IAAI,EAC7B,IAAIM,CACb,SAAWV,aAAiBT,EAC1B,OAAAa,EAAQ,wBAAwBJ,EAAM,MAAM,EACrC,KAAK,cAEd,OAAO,IACT,CACF,EAWapB,GAAmB,CAC9B,aAAA8B,EACA,4BAAAK,EACA,6BAAAE,EACA,+BAAAJ,EACA,2BAAAQ,EACA,4BAAAG,EACA,yBAAAJ,CACF,EAEA,SAASvC,GAAkB8C,EAAwB,CACjD,OAAOA,EAAM,MAAQ,gBAAkBA,EAAM,MAAQ,gCACvD,CJ/pBA,IAAOC,GAAQ,CACb,uBAAAC,EACA,mBAAAC,EACA,eAAAC,EACA,iBAAAC,EACA,YAAAC,EACA,wBAAAC,CACF",
  "names": ["require_crypto", "__commonJSMin", "push_exports", "__export", "ActivationStateMachine", "CalledActivate", "CalledDeactivate", "pushchannel_default", "push_default", "getW3CPushDeviceDetails", "localDeviceFactory", "__toCommonJS", "PushChannel", "channel", "client", "device", "format", "body", "headers", "requestBody", "clientId", "params", "__spreadProps", "__spreadValues", "deviceIdentityToken", "pushchannel_default", "toBase64Url", "arrayBuffer", "buffer", "urlBase64ToBase64", "base64String", "padding", "base64ToUint8Array", "rawData", "rawDataChars", "i", "getW3CPushDeviceDetails", "machine", "GettingPushDeviceDetailsFailed", "GotPushDeviceDetails", "ErrorInfo", "Defaults", "swUrl", "worker", "headers", "appServerKey", "subscription", "endpoint", "p256dh", "auth", "device", "err", "createError", "message", "err", "ENCODING", "ENCODING_LEN", "TIME_MAX", "TIME_LEN", "RANDOM_LEN", "randomChar", "prng", "rand", "ENCODING_LEN", "ENCODING", "encodeTime", "now", "len", "TIME_MAX", "createError", "mod", "str", "encodeRandom", "detectPrng", "allowInsecure", "root", "browserCrypto", "buffer", "nodeCrypto", "e", "createError", "factory", "currPrng", "seedTime", "encodeTime", "TIME_LEN", "encodeRandom", "RANDOM_LEN", "ulid", "factory", "persistKeys", "localDeviceFactory", "deviceDetails", "LocalDevice", "rest", "device", "_a", "Platform", "config", "ulid", "headers", "params", "ActivationStateMachine", "GettingPushDeviceDetailsFailed", "GotPushDeviceDetails", "ActivationStates", "isPersistentState", "reason", "isNew", "error", "deviceRegistration", "GettingDeviceRegistrationFailed", "SyncRegistrationFailed", "GotDeviceRegistration", "RegistrationSynced", "err", "DeregistrationFailed", "Deregistered", "localDevice", "client", "format", "body", "requestBody", "authDetails", "response", "event", "maybeNext", "pending", "CalledActivate", "machine", "registerCallback", "CalledDeactivate", "deregisterCallback", "ActivationState", "name", "NotActivated", "_NotActivated", "_b", "WaitingForNewPushDeviceDetails", "getW3CPushDeviceDetails", "WaitingForPushDeviceDetails", "_WaitingForPushDeviceDetails", "WaitingForDeviceRegistration", "_WaitingForDeviceRegistration", "_WaitingForNewPushDeviceDetails", "WaitingForDeregistration", "WaitingForRegistrationSync", "_WaitingForRegistrationSync", "triggeredByCalledActivate", "AfterRegistrationSyncFailed", "_WaitingForDeregistration", "previousState", "state", "push_default", "ActivationStateMachine", "localDeviceFactory", "CalledActivate", "CalledDeactivate", "pushchannel_default", "getW3CPushDeviceDetails"]
}
