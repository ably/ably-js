'use strict';

define(['ably', 'shared_helper'], function (Ably, Helper) {
  // copied from crypto test
  var msgpack = typeof window == 'object' ? Ably.msgpack : require('@ably/msgpack-js');
  // similar approach
  var WebSocket = typeof window == 'object' ? window.WebSocket : require('ws');
  var BufferUtils = Ably.Realtime.Platform.BufferUtils;

  function log(...args) {
    console.log('Interception proxy client:', ...args);
  }

  class InterceptionProxyClient {
    currentContext = null;

    // this expects the interception proxy to already be running (i.e. the test suite doesn't launch it)
    // this method is called by test suite’s root hooks. test cases shouldn't call this method; rather, they should use `intercept`
    async connect() {
      this.webSocket = new WebSocket('ws://localhost:8001');

      await new Promise((resolve, reject) => {
        this.webSocket.addEventListener('open', () => {
          log('connected to interception proxy');
          resolve();
        });
        this.webSocket.addEventListener('error', (error) => {
          log('failed to connect to interception proxy:', error);
          reject(error);
        });
        this.webSocket.addEventListener('message', (message) => {
          log('got control API message', message.data);
          this.handleJSONRPCMessage(JSON.parse(message.data));
        });
      });

      await this.startInterception();
      log('startInterception completed');

      // TODO something if connection lost
    }

    async startInterception() {
      const promise = new Promise((resolve, reject) => {
        this.onStartedInterception = resolve;
        this.onFailedToStartInterception = reject;
      });

      // i.e. for browser we use proxy, for Node we use local
      const params = typeof window == 'object' ? { mode: 'proxy' } : { mode: 'local', pid: process.pid };

      const request = {
        jsonrpc: '2.0',
        method: 'startInterception',
        params,
        id: Helper.randomString(),
      };
      const requestData = JSON.stringify(request);

      log('sending startInterception request', request);
      this.webSocket.send(requestData);

      return promise;
    }

    async disconnect() {
      if (this.webSocket.readyState === 3) {
        // already closed
        log('already disconnected');
        return;
      }

      this.webSocket.close();

      return new Promise((resolve) => {
        this.webSocket.addEventListener('close', () => {
          log('disconnected');
          resolve();
        });
      });
    }

    // TODO explain motivation for this API (so that a lingering test can’t accidentally override the interception in your test; of course, the interception in your test might accidentally _intercept_ messages sent by a lingering test but that’s a separate issue)
    //
    // This is written as (done, action) for compatibility with the way our tests are currently written; a promise-based version would be good to have too
    //
    // action receives a context object. it can modify the following properties of this object to modify the interception:
    //
    // - `transformClientMessage` or `transformServerMessage` (for message from client or server respectively)
    //
    //   Receives an object with the following properties:
    //
    //   - id: a unique identifier for this WebSocket message (generated by the interception proxy)
    //   - connectionID: a unique identifier for this WebSocket connection (generated by the interception proxy)
    //   - deserialized: a JSON-like object (i.e. the result of JSON.parse or msgpack.decode)
    //
    //   And returns one of:
    //
    //   - a JSON-like object (to modify the message)
    //   - `null` (to drop the message)
    //
    //   Can also return a promise.
    //
    //   If not set, then messages will be passed through unaltered.
    //
    //   TODO some thoughts on API:
    //
    //   - user currently has to make sure they remember to return something from the transform* function, even if they’re failing their test in some exceptional manner — this is to make sure that the connection can be allowed to disconnect at the proxy
    //
    //   - users might think that they can directly mutate the object passed to transform* functions
    intercept(done, action) {
      if (this.currentContext !== null) {
        throw new Error(
          'A call to `intercept` is already active; check you’re not running multiple tests at the same time',
        );
      }

      this.currentContext = {
        transformClientMessage: null,
        transformServerMessage: null,
      };

      const newDone = (error) => {
        this.currentContext = null;
        done(error);
      };

      action(newDone, this.currentContext);
    }

    handleJSONRPCMessage(message) {
      if (message.method === 'transformInterceptedMessage') {
        let deserialized;
        if (message.params.type === 'binary') {
          const data = BufferUtils.base64Decode(message.params.data);
          deserialized = msgpack.decode(data);
        } else if (message.params.type === 'text') {
          const data = message.params.data;
          deserialized = JSON.parse(data);
        }

        log('awaiting response of transformInterceptedMessage for message', message, 'deserialized to', deserialized);

        const messageForTransform = { id: message.params.id, connectionID: message.params.connectionID, deserialized };

        const noOpTransformInterceptedMessage = (message) => {
          log(`default transformInterceptedMessage implementation passing message ${message.id} unaltered`);
          return message.deserialized;
        };

        const transformInterceptedMessage =
          (message.params.fromClient
            ? this.currentContext?.transformClientMessage
            : this.currentContext?.transformServerMessage) ?? noOpTransformInterceptedMessage;

        Promise.resolve(transformInterceptedMessage(messageForTransform)).then((result) => {
          try {
            log(`got result of transforming message ${messageForTransform.id}`, result);

            let responseResult;

            if (result === null) {
              responseResult = { action: 'drop' };
            } else {
              let data;

              if (message.params.type === 'binary') {
                const serialized = msgpack.encode(result);
                data = BufferUtils.base64Encode(serialized);
              } else if (message.params.type === 'text') {
                data = JSON.stringify(result);
              }

              responseResult = { action: 'replace', type: message.params.type, data };
            }

            const response = { jsonrpc: '2.0', id: message.id, result: responseResult };
            log('sending transformInterceptedMessage response', response);

            const responseJSON = JSON.stringify(response);
            this.webSocket.send(responseJSON);
          } catch (err) {
            // TODO better error handling
            log('caught', err);
          }
        });
      } else {
        // assume it's the response to our startInterception call; TODO sort this out
        if ('error' in message) {
          this.onFailedToStartInterception(new Error(message.error.message));
        } else {
          this.onStartedInterception();
        }
      }
    }
  }

  return (module.exports = new InterceptionProxyClient());
});
